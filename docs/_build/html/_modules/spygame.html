
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spygame &#8212; spygame 0.1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/sphinxdoc.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">spygame 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spygame</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd"> -------------------------------------------------------------------------</span>
<span class="sd"> spygame (pygame based 2D game engine for the openAI gym)</span>
<span class="sd"> -------------------------------------------------------------------------</span>

<span class="sd"> created: 2017/04/04 in PyCharm</span>
<span class="sd"> (c) 2017 Sven Mika - ducandu GmbH</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span>
<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Tuple</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">pytmx</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>


<span class="c1"># some debug flags that we can set to switch on debug rendering, collision handling, etc..</span>
<span class="n">DEBUG_NONE</span> <span class="o">=</span> <span class="mh">0x0</span>  <span class="c1"># no debugging</span>
<span class="n">DEBUG_ALL</span> <span class="o">=</span> <span class="mh">0xffff</span>  <span class="c1"># full debugging</span>
<span class="c1"># will not render TiledTileLayers that are marked as &#39;do_render&#39;==true in the tmx files</span>
<span class="n">DEBUG_DONT_RENDER_TILED_TILE_LAYERS</span> <span class="o">=</span> <span class="mh">0x1</span>
<span class="c1"># will render all collision tiles (those layers that have a type) with a square frame and - when being considered - filled green</span>
<span class="n">DEBUG_RENDER_COLLISION_TILES</span> <span class="o">=</span> <span class="mh">0x2</span>
<span class="n">DEBUG_RENDER_COLLISION_TILES_COLOR_DEFAULT</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">DEBUG_RENDER_COLLISION_TILES_COLOR_OTHER</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;cyan&quot;</span><span class="p">)</span>
<span class="c1"># render the tiles currently under consideration for colliding with a sprite</span>
<span class="n">DEBUG_RENDER_ACTIVE_COLLISION_TILES</span> <span class="o">=</span> <span class="mh">0x4</span>
<span class="n">DEBUG_RENDER_ACTIVE_COLLISION_TILES_COLOR</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="c1"># will render all Sprites (even those without an image (e.g. when blinking) with a rectangular frame representing the Sprite&#39;s .rect property</span>
<span class="n">DEBUG_RENDER_SPRITES_RECTS</span> <span class="o">=</span> <span class="mh">0x8</span>
<span class="n">DEBUG_RENDER_SPRITES_RECTS_COLOR</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;orange&quot;</span><span class="p">)</span>
<span class="c1"># will render every Sprite before the Sprite&#39;s tick method was called</span>
<span class="n">DEBUG_RENDER_SPRITES_BEFORE_EACH_TICK</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">DEBUG_RENDER_SPRITES_AFTER_EACH_TICK</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="c1"># will render every Sprite before the Sprite&#39;s collision detection algo runs</span>
<span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span> <span class="o">=</span> <span class="mh">0x40</span>

<span class="c1"># by default, no debugging (you can set this through a Game&#39;s c&#39;tor using the debug_flags kwarg)</span>
<span class="n">DEBUG_FLAGS</span> <span class="o">=</span> <span class="n">DEBUG_NONE</span>


<div class="viewcode-block" id="EventObject"><a class="viewcode-back" href="../spygame.html#spygame.EventObject">[docs]</a><span class="k">class</span> <span class="nc">EventObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    an EventObject introduces event handling and most objects that occur in spygame games will inherit from this class</span>
<span class="sd">    - NOTE: spygame events are not(!) pygame events</span>
<span class="sd">    - EventObject can &#39;have&#39; some events, which are simple strings (the names of the events, e.g. &#39;hit&#39;, &#39;jump&#39;, &#39;collided&#39;, etc..)</span>
<span class="sd">    - EventObject can trigger any event by their name</span>
<span class="sd">    - if an EventObject wants to trigger an event, this event must have been registered with the EventObject beforehand (will raise exception otherwise)</span>
<span class="sd">    -</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># - listeners keeps a list of callbacks indexed by event name for quick lookup</span>
        <span class="c1"># - a listener is an array of 2 elements: 0=target, 1=callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># keys=event names; values=list of 2 elements (0=target object, 1=callback method)</span>
        <span class="c1"># stores all valid event names; that way, we can check validity of event when subscribers subscribe to some event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<div class="viewcode-block" id="EventObject.register_event"><a class="viewcode-back" href="../spygame.html#spygame.EventObject.register_event">[docs]</a>    <span class="k">def</span> <span class="nf">register_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">events</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        registers a possible event (str) with this object; only registered events are allowed to be triggered later</span>

<span class="sd">        :param str events: the event (or events) that should be registered</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">event</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventObject.unregister_event"><a class="viewcode-back" href="../spygame.html#spygame.EventObject.unregister_event">[docs]</a>    <span class="k">def</span> <span class="nf">unregister_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">events</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        removes one or more events from this EventObject&#39;s event registry; unregistered events are no longer allowed to be triggered</span>

<span class="sd">        :param str events: the event(s) that should be removed from the registry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">event</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventObject.unregister_events"><a class="viewcode-back" href="../spygame.html#spygame.EventObject.unregister_events">[docs]</a>    <span class="k">def</span> <span class="nf">unregister_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        unregisters all events from this GameObject (see &#39;unregister_event&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="EventObject.check_event"><a class="viewcode-back" href="../spygame.html#spygame.EventObject.check_event">[docs]</a>    <span class="k">def</span> <span class="nf">check_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        checks whether the given event is in this EventObject&#39;s registry (raises exception if not)</span>

<span class="sd">        :param str event: the event to be checked</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure the event is valid (registered)</span>
        <span class="k">if</span> <span class="n">event</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: event &#39;</span><span class="si">{}</span><span class="s2">&#39; not valid in this EventObject (</span><span class="si">{}</span><span class="s2">); event has not been registered!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span></div>

<div class="viewcode-block" id="EventObject.on_event"><a class="viewcode-back" href="../spygame.html#spygame.EventObject.on_event">[docs]</a>    <span class="k">def</span> <span class="nf">on_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        binds a callback to an event on this EventObject</span>
<span class="sd">        - if you provide a `target` object, that object will add this event to it&#39;s list of binds, allowing it to automatically remove it when</span>
<span class="sd">        it is destroyed.</span>
<span class="sd">        - from here on, if the event gets triggered, the callback will be called on the target object</span>
<span class="sd">        - note: only previously registered events may be triggered (we can register the event here by setting register=True)</span>

<span class="sd">        :param Union[str,List[str]] event: the name of the event to be bound to the callback (e.g. tick, got_hit, etc..)</span>
<span class="sd">        :param target (EventObject): The target object on which to call the callback (defaults to self if not given)</span>
<span class="sd">        :param callable callback: the bound method to call on target if the event gets triggered</span>
<span class="sd">        :param bool register: whether we should register this event right now (only registered events are allowed to be triggered later)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">register</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>  <span class="c1"># checks whether it&#39;s already registered</span>

        <span class="c1"># more than one event given</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">target</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># handle the case where there is no target provided, swapping the target and callback parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">target</span>
            <span class="n">target</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># if there&#39;s still no callback, default to the event name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event</span>

        <span class="c1"># handle case for callback that is a string, this will pull the callback from the target object or from this object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

        <span class="c1"># listener is an array of 2 elements: 0=target, 1=callback</span>
        <span class="k">if</span> <span class="n">event</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">target</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">])</span>

        <span class="c1"># with a provided target, the events bound to the target, so we can erase these events if the target no longer exists</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;binds&quot;</span><span class="p">):</span>
                <span class="n">target</span><span class="o">.</span><span class="n">event_binds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">target</span><span class="o">.</span><span class="n">event_binds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">callback</span><span class="p">])</span></div>

    <span class="c1"># TODO: good debugging: warn if a registered event doesn&#39;t get triggered for a long time?</span>
<div class="viewcode-block" id="EventObject.trigger_event"><a class="viewcode-back" href="../spygame.html#spygame.EventObject.trigger_event">[docs]</a>    <span class="k">def</span> <span class="nf">trigger_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        triggers an event and specifies the parameters to be passed to the bound event handlers (callbacks) as \*params</span>

<span class="sd">        :param str event: the name of the event that should be triggered; note: this event name will have to be registered with the EventObject</span>
<span class="sd">            in order for the trigger to succeed</span>
<span class="sd">        :param any params: the parameters to be passed to the handler methods as \*args</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

        <span class="c1"># make sure there are any listeners for this specific event, if not, early out</span>
        <span class="k">if</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
            <span class="c1"># call each listener in the context of either the target passed into `on_event` ([0]) or the object itself</span>
            <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]:</span>
                <span class="n">listener</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventObject.off_event"><a class="viewcode-back" href="../spygame.html#spygame.EventObject.off_event">[docs]</a>    <span class="k">def</span> <span class="nf">off_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unregister</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        unbinds an event from a target/callback</span>
<span class="sd">        - can be called with 1, 2, or 3 parameters, each of which unbinds a more specific listener</span>

<span class="sd">        :param str event: the name of the event to unbind from the callback</span>
<span class="sd">        :param EventObject target: the target EventObject to unbind this event from (callback would be a member of this target)</span>
<span class="sd">        :param callable callback: the callback to unbind the event from</span>
<span class="sd">        :param bool unregister: whether we should unregister this event as well</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unregister</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unregister_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

        <span class="c1"># without a target, remove all the listeners</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;listeners&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if the callback is a string, find a method of the same name on the target</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
                <span class="n">callback</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;listeners&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]</span>
                <span class="c1"># loop from the end to the beginning, which allows us to remove elements without having to affect the loop</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">target</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback</span> <span class="ow">or</span> <span class="n">callback</span> <span class="ow">is</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventObject.debind_events"><a class="viewcode-back" href="../spygame.html#spygame.EventObject.debind_events">[docs]</a>    <span class="k">def</span> <span class="nf">debind_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        called to remove any listeners from this object</span>
<span class="sd">        - e.g. when this object is destroyed you&#39;ll want all the event listeners to be removed from this object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;event_binds&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_binds</span><span class="p">:</span>
                <span class="n">source</span><span class="o">.</span><span class="n">off_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div></div>


<span class="c1"># can handle events as well as</span>
<div class="viewcode-block" id="State"><a class="viewcode-back" href="../spygame.html#spygame.State">[docs]</a><span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="n">EventObject</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># sets a value in our dict and triggers a changed event</span>
<div class="viewcode-block" id="State.set"><a class="viewcode-back" href="../spygame.html#spygame.State.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">trigger_event</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># trigger an event that the value changed</span>
        <span class="k">if</span> <span class="n">trigger_event</span><span class="p">:</span>
            <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;changed.&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>
        <span class="c1"># set to new value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>

    <span class="c1"># retrieve a value from the dict</span>
<div class="viewcode-block" id="State.get"><a class="viewcode-back" href="../spygame.html#spygame.State.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="s2">&quot;ERROR: key </span><span class="si">{}</span><span class="s2"> not in dict!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

    <span class="c1"># decrease value by amount</span>
<div class="viewcode-block" id="State.dec"><a class="viewcode-back" href="../spygame.html#spygame.State.dec">[docs]</a>    <span class="k">def</span> <span class="nf">dec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-=</span> <span class="n">amount</span></div>

    <span class="c1"># increase value by amount</span>
<div class="viewcode-block" id="State.inc"><a class="viewcode-back" href="../spygame.html#spygame.State.inc">[docs]</a>    <span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amount</span></div></div>


<div class="viewcode-block" id="KeyboardInputs"><a class="viewcode-back" href="../spygame.html#spygame.KeyboardInputs">[docs]</a><span class="k">class</span> <span class="nc">KeyboardInputs</span><span class="p">(</span><span class="n">EventObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a class to handle keyboard inputs by the user playing the spygame game</span>
<span class="sd">    - a KeyboardInput object is passed to the GameLoop c&#39;tor, so that the GameLoop can `tick` the KeyboardInput object each frame</span>
<span class="sd">    - single keys to watch out for can be registered via the `update_keys` method (not registered keys will be ignored)</span>
<span class="sd">    - the tick method collects all keydown/keyup pygame events and stores the currently registered keys in the `keyboard_registry` as True (currently pressed)</span>
<span class="sd">    or False (currently not pressed)</span>
<span class="sd">    - all keys are described by their pygame names (without the leading `K_`), e.g. pygame.K_UP=`up`, pygame.K_ESCAPE=`escape`, etc..</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># stores the keys that we would like to be registered as important</span>
        <span class="c1"># - key: pygame keyboard code (e.g. pygame.K_ESCAPE, pygame.K_UP, etc..)</span>
        <span class="c1"># - value: True if currently pressed, False otherwise</span>
        <span class="c1"># - needs to be ticked in order to yield up-to-date information (this will be done by a GameLoop playing a Screen)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc_to_key</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># for reverse mapping from description (e.g. &#39;up&#39;) to int (e.g. pygame.K_UP)</span>

        <span class="k">if</span> <span class="n">key_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_keys</span><span class="p">(</span><span class="n">key_list</span><span class="p">)</span>

<div class="viewcode-block" id="KeyboardInputs.update_keys"><a class="viewcode-back" href="../spygame.html#spygame.KeyboardInputs.update_keys">[docs]</a>    <span class="k">def</span> <span class="nf">update_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_key_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        populates our registry and other dicts with the new key-list given (may be an empty list)</span>

<span class="sd">        :param Union[List,None] new_key_list: the new key list, where each item is the lower-case pygame keycode without the leading</span>
<span class="sd">            `K_` e.g. `up` for pygame.K_UP; use None for clearing out the registry (no keys assigned)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unregister_events</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">desc_to_key</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">new_key_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">new_key_list</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pygame</span><span class="p">,</span> <span class="s2">&quot;K_&quot;</span> <span class="o">+</span> <span class="n">desc</span><span class="o">.</span><span class="n">upper</span><span class="p">())</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">desc_to_key</span><span class="p">[</span><span class="n">desc</span><span class="p">]</span> <span class="o">=</span> <span class="n">key</span>
                <span class="c1"># signal that we might trigger the following events:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;key_down.&quot;</span> <span class="o">+</span> <span class="n">desc</span><span class="p">,</span> <span class="s2">&quot;key_up.&quot;</span> <span class="o">+</span> <span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="KeyboardInputs.tick"><a class="viewcode-back" href="../spygame.html#spygame.KeyboardInputs.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pulls all keyboard events from the event queue and processes them according to our keyboard_registry/descriptions</span>
<span class="sd">        - triggers events for all registered keys like: &#39;key_down.[desc]&#39; (when  pressed) and &#39;key_up.[desc]&#39; (when released),</span>
<span class="sd">        where desc is the lowercase string after `pygame.K_`... (e.g. &#39;down&#39;, &#39;up&#39;, etc..)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="n">pygame</span><span class="o">.</span><span class="n">KEYDOWN</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">KEYUP</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="c1"># a key was pressed that we are interested in -&gt; set to True or False</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">KEYDOWN</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;key_down.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;key_up.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="GameObject"><a class="viewcode-back" href="../spygame.html#spygame.GameObject">[docs]</a><span class="k">class</span> <span class="nc">GameObject</span><span class="p">(</span><span class="n">EventObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a GameObject adds the capability to add one or more Component objects to the GameObject</span>
<span class="sd">    (e.g. animation, physics, etc..)</span>
<span class="sd">    - Component objects are stored by their name in the GameObject.components dict</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># stores all GameObjects by a unique int ID</span>
    <span class="n">id_to_obj</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">next_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dict of added components by component&#39;s name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_destroyed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">GameObject</span><span class="o">.</span><span class="n">next_id</span>
        <span class="n">GameObject</span><span class="o">.</span><span class="n">id_to_obj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">GameObject</span><span class="o">.</span><span class="n">next_id</span> <span class="o">+=</span> <span class="mi">1</span>

<div class="viewcode-block" id="GameObject.add_component"><a class="viewcode-back" href="../spygame.html#spygame.GameObject.add_component">[docs]</a>    <span class="k">def</span> <span class="nf">add_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a component object to this GameObject -&gt; calls the component&#39;s added method</span>

<span class="sd">        :param Component component: component to be added to GameObject under game_obj.components[component.name]</span>
<span class="sd">        :return: the same Component for chaining</span>
<span class="sd">        :rtype: Component</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">component</span><span class="o">.</span><span class="n">game_object</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">assert</span> <span class="n">component</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="s2">&quot;ERROR: component with name </span><span class="si">{}</span><span class="s2"> already exists in Entity!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">component</span>
        <span class="n">component</span><span class="o">.</span><span class="n">added</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">component</span></div>

<div class="viewcode-block" id="GameObject.remove_component"><a class="viewcode-back" href="../spygame.html#spygame.GameObject.remove_component">[docs]</a>    <span class="k">def</span> <span class="nf">remove_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        removes the given component from this GameObject</span>

<span class="sd">        :param Component component: the Component object to be removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">component</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="s2">&quot;ERROR: component with name </span><span class="si">{}</span><span class="s2"> does no exist in Entity!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># call the removed handler (if implemented)</span>
        <span class="n">component</span><span class="o">.</span><span class="n">removed</span><span class="p">()</span>
        <span class="c1"># only then erase the component from the GameObject</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="GameObject.destroy"><a class="viewcode-back" href="../spygame.html#spygame.GameObject.destroy">[docs]</a>    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroys the GameObject by calling debind and removing the object from it&#39;s parent</span>
<span class="sd">        - will trigger a `destroyed` event (callback)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we are already dead -&gt; return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_destroyed</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># debind events where we are the target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debind_events</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_destroyed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># tell everyone we are done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;destroyed&quot;</span><span class="p">)</span>

        <span class="c1"># remove ourselves from the id_to_obj dict</span>
        <span class="k">del</span> <span class="n">GameObject</span><span class="o">.</span><span class="n">id_to_obj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">]</span></div>

<div class="viewcode-block" id="GameObject.tick"><a class="viewcode-back" href="../spygame.html#spygame.GameObject.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a tick (coming from the GameObject containing Stage); override this if you want your GameObject to do something each frame</span>
<span class="sd">        :param GameLoop game_loop: the GameLoop that&#39;s currently playing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="SpriteSheet"><a class="viewcode-back" href="../spygame.html#spygame.SpriteSheet">[docs]</a><span class="k">class</span> <span class="nc">SpriteSheet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    represents a spritesheet loaded from a tsx file</span>
<span class="sd">    - stores each single image (as pygame.Surface) in the sheet by its position</span>
<span class="sd">    - allows for already doing flip transformations (x/y and/or both axes) so we save time during the game</span>
<span class="sd">    - stores single tile properties in tile_props_by_id dict (only for those tiles that actually have custom properties defined in the tsx file)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">store_flips</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str file: the tsx file name to be loaded into this object</span>
<span class="sd">        :param dict store_flips: dictionary ({&quot;x&quot;: [True|False], &quot;y&quot;: [True|False]}) with the flip-options; None for default (only x)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">etree</span><span class="o">.</span><span class="n">ElementTree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span><span class="s2">&quot;ERROR: could not open xml file: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>

        <span class="n">elem</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
        <span class="n">props</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tw</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;tilewidth&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">th</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;tileheight&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;tilecount&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the list of all Surfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_x</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the list of all Surfaces (flipped on x-axis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_y</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the list of all Surfaces (flipped on y-axis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_xy</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the list of all Surfaces (flipped on both axes)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tile_props_by_id</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># contains tile properties set in the tmx file for each tile by tile ID</span>

        <span class="c1"># by default, only flip on x-axis (usually that&#39;s enough for 2D games)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">store_flips</span><span class="p">:</span>
            <span class="n">store_flips</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="c1"># the image asset -&gt; load and save all Surfaces</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span>
                <span class="n">props</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">])</span>
                <span class="n">image_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">file</span><span class="p">)),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">])))</span>
                <span class="c1"># image_file = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(file)), os.path.relpath(&quot;../images/debug.png&quot;)))</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">image_file</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
                <span class="n">col</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
                    <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">surf</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">th</span><span class="p">),</span> <span class="n">flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">SRCALPHA</span><span class="p">)</span>
                    <span class="n">surf</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                              <span class="n">area</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="n">row</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">th</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">th</span><span class="p">))</span>  <span class="c1"># blits the correct frame of the image to this new surface</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>
                    <span class="c1"># do the necessary flippings (will save time later when rendering the Sprite)</span>
                    <span class="k">if</span> <span class="n">store_flips</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]:</span>
                        <span class="n">surf_x_flipped</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf_x_flipped</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">store_flips</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>  <span class="c1"># x and y</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">surf_x_flipped</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">store_flips</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

            <span class="c1"># single tiles (and their properties)</span>
            <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;tile&quot;</span><span class="p">:</span>
                <span class="n">id_</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tile_props_by_id</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># create new dict for this tile</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
                    <span class="c1"># the expected properties tag</span>
                    <span class="k">if</span> <span class="n">tag</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">tag</span><span class="p">:</span>
                            <span class="n">val</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                            <span class="n">type_</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span> <span class="k">else</span> <span class="kc">None</span>
                            <span class="k">if</span> <span class="n">type_</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
                                    <span class="n">val</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span> <span class="k">else</span> <span class="kc">False</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="k">else</span> <span class="n">val</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tile_props_by_id</span><span class="p">[</span><span class="n">id_</span><span class="p">][</span><span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="p">(</span><span class="s2">&quot;ERROR: expected only &lt;properties&gt; tag within &lt;tile&gt; in tsx file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file</span><span class="p">))</span></div>


<div class="viewcode-block" id="Sprite"><a class="viewcode-back" href="../spygame.html#spygame.Sprite">[docs]</a><span class="k">class</span> <span class="nc">Sprite</span><span class="p">(</span><span class="n">GameObject</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a Sprite can be added to a Stage; has a type and a collision mask for collision detection with other Sprites or TiledTileLayers also on the Stage</span>
<span class="sd">    - Sprite objects inherit from pygame.sprite.Sprite, so a Sprite has an image and a position via rect</span>
<span class="sd">    - each Sprite can have either a static image or hold a SpriteSheet object from which it can pull images for animation purposes; either way, the image</span>
<span class="sd">    property is set that way</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># dict of Sprite types (by name) to bitmappable-int (1, 2, 4, 8, 16, etc..)</span>
    <span class="c1"># - this can be used to determine which Sprites collide with which other Sprites</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;none&quot;</span>          <span class="p">:</span> <span class="mh">0x0</span><span class="p">,</span>
        <span class="s2">&quot;default&quot;</span>       <span class="p">:</span> <span class="mh">0x1</span><span class="p">,</span>
        <span class="s2">&quot;default_ground&quot;</span><span class="p">:</span> <span class="mh">0x2</span><span class="p">,</span>
        <span class="s2">&quot;default_wall&quot;</span>  <span class="p">:</span> <span class="mh">0x4</span><span class="p">,</span>
        <span class="s2">&quot;particle&quot;</span>      <span class="p">:</span> <span class="mh">0x8</span><span class="p">,</span>
        <span class="s2">&quot;friendly&quot;</span>      <span class="p">:</span> <span class="mh">0x10</span><span class="p">,</span>
        <span class="s2">&quot;enemy&quot;</span>         <span class="p">:</span> <span class="mh">0x20</span><span class="p">,</span>
        <span class="s2">&quot;character&quot;</span>     <span class="p">:</span> <span class="mh">0x40</span><span class="p">,</span>
        <span class="s2">&quot;ui&quot;</span>            <span class="p">:</span> <span class="mh">0x80</span><span class="p">,</span>
        <span class="s2">&quot;all&quot;</span>           <span class="p">:</span> <span class="mh">0x100</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">next_type</span> <span class="o">=</span> <span class="mh">0x200</span>

<div class="viewcode-block" id="Sprite.get_type"><a class="viewcode-back" href="../spygame.html#spygame.Sprite.get_type">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_type</span><span class="p">(</span><span class="nb">type</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the bitmap code for an already existing Sprite type or for a new type (the code will be created then)</span>
<span class="sd">        - types are usually used for collision masks</span>

<span class="sd">        :param str type: the type, whose code should be returned</span>
<span class="sd">        :return: the type as an int</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">types</span><span class="p">:</span>
            <span class="n">Sprite</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">next_type</span>
            <span class="n">Sprite</span><span class="o">.</span><span class="n">next_type</span> <span class="o">*=</span> <span class="mi">2</span>
        <span class="k">return</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="nb">type</span><span class="p">]</span></div>

    <span class="c1"># TODO: make Sprite accept an image file as well (png will be loaded and simply set as image)</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">sheet_or_wh_or_file</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SpriteSheet</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int x: the initial x position of this Sprite</span>
<span class="sd">        :param int y: the initial y position of this Sprite</span>
<span class="sd">        :param Union[SpriteSheet,str,Tuple[int],None] sheet_or_wh_or_file: if SpriteSheet -&gt; use that SpriteSheet (set initial image to first frame in the</span>
<span class="sd">        SpriteSheet); if str -&gt; use str as file name for a static image; if Tuple[int] -&gt; empty image (no rendering) with a rect of given tuple sizes;</span>
<span class="sd">        if None: no image, rect=1x1, no rendering</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">GameObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># all sprites need to have a position</span>
        <span class="c1"># - but support Sprites without SpriteSheets:</span>
        <span class="c1"># -- some Rect without image</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sheet_or_wh_or_file</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pygame.Surface((sheet_or_wh_or_file[0], sheet_or_wh_or_file[1]))</span>
            <span class="c1"># self.image.fill(pygame.Color(0, 0, 0, 255))  # all transparent image</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sheet_or_wh_or_file</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sheet_or_wh_or_file</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># -- with SpriteSheet</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sheet_or_wh_or_file</span><span class="p">,</span> <span class="n">SpriteSheet</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span> <span class="o">=</span> <span class="n">sheet_or_wh_or_file</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">sheet_or_wh_or_file</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">th</span><span class="p">)</span>
        <span class="c1"># an image file -&gt; fixed image -&gt; store as Surface in self.image</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sheet_or_wh_or_file</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">sheet_or_wh_or_file</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">get_rect</span><span class="p">()</span>
        <span class="c1"># -- tiny-size rect (no image)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># pygame.Surface((0, 0))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># GameObject specific stuff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>  <span class="c1"># specifies the type of the GameObject (can be used e.g. for collision detection)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handles_own_collisions</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># set to True if this object takes care of its own collision handling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>  <span class="c1"># set the bits here that we would like to collide with (all other types will be ignored)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stage</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the current Stage this Sprite is in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the current Groups that this Sprite belongs to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">render_order</span> <span class="o">=</span> <span class="mi">50</span>  <span class="c1"># the higher this number the later this Sprite will be rendered in the Stage&#39;s render function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flip</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>  <span class="c1"># &#39;x&#39;: flip in x direction, &#39;y&#39;: flip in y direction, False: don&#39;t flip</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;added_to_stage&quot;</span><span class="p">)</span>  <span class="c1"># allow any Stage to trigger this event using this Sprite</span>

<div class="viewcode-block" id="Sprite.move"><a class="viewcode-back" href="../spygame.html#spygame.Sprite.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">precheck</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        moves us by x/y pixels</span>
<span class="sd">        OBSOLETE: - if precheck is set to True: pre-checks the planned move via call to stage.locate and only moves entity as far as possible</span>

<span class="sd">        :param int x: the amount in pixels to move in x-direction</span>
<span class="sd">        :param int y: the amount in pixels to move in y-direction</span>
<span class="sd">        :param bool precheck: ???</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#if precheck:</span>
        <span class="c1">#    testcol = self.stage.locate(p.x+x, p.y+y, Q._SPRITE_DEFAULT, p.w, p.h);</span>
        <span class="c1">#    if ((!testcol) || (testcol.tileprops &amp;&amp; testcol.tileprops[&#39;liquid&#39;])) {</span>
        <span class="c1">#        return True</span>
        <span class="c1">#</span>
        <span class="c1">#    return False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">y</span>

        <span class="c1"># TODO: move the obj_to_follow into collide of stage (stage knows its borders best, then we don&#39;t need to define xmax/xmin, etc.. anymore)</span>
        <span class="c1"># TODO: maybe we could even build a default collision-frame around every stage when inserting the collision layer</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if sprite.rect.x &lt; self.x_min:</span>
<span class="sd">            sprite.rect.x = self.x_min</span>
<span class="sd">            self.vx = 0</span>
<span class="sd">        elif sprite.rect.x &gt; self.x_max:</span>
<span class="sd">            sprite.rect.x = self.x_max</span>
<span class="sd">            self.vx = 0</span>
<span class="sd">        if sprite.rect.y &lt; self.y_min:</span>
<span class="sd">            sprite.rect.y = self.y_min</span>
<span class="sd">            self.vy = 0</span>
<span class="sd">        elif sprite.rect.y &gt; self.y_max:</span>
<span class="sd">            sprite.rect.y = self.y_max</span>
<span class="sd">            self.vy = 0</span>
<span class="sd">        &quot;&quot;&quot;</span></div>

    <span class="c1"># @override(GameObject)</span>
<div class="viewcode-block" id="Sprite.destroy"><a class="viewcode-back" href="../spygame.html#spygame.Sprite.destroy">[docs]</a>    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>

        <span class="c1"># if we are on a stage -&gt; remove us from that stage</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">remove_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># remove us from all our pygame.sprite.Groups</span>
        <span class="k">for</span> <span class="n">sprite_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">:</span>
            <span class="n">sprite_group</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sprite.render"><a class="viewcode-back" href="../spygame.html#spygame.Sprite.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        paints the Sprite with its current image onto the given Display object</span>

<span class="sd">        :param Display display: the Display object to render on (Display has a pygame.Surface, on which we blit our image)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">:</span>
            <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_RECTS</span><span class="p">:</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="p">,</span> <span class="n">DEBUG_RENDER_SPRITES_RECTS_COLOR</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">h</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Repeater"><a class="viewcode-back" href="../spygame.html#spygame.Repeater">[docs]</a><span class="k">class</span> <span class="nc">Repeater</span><span class="p">(</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a background 2D repeater that scrolls slower than the Viewport</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image_file</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vx&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vy&quot;</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat_x</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;repeat_x&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat_y</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;repeat_y&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat_w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;repeat_w&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat_h</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;repeat_h&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
        <span class="c1"># don&#39;t collide with anything</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># @override(Sprite)</span>
<div class="viewcode-block" id="Repeater.render"><a class="viewcode-back" href="../spygame.html#spygame.Repeater.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="n">view_x</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">view_y</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">offset_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">view_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span>
        <span class="n">offset_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">view_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span>
        <span class="n">cur_x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">cur_y</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">start_x</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_x</span><span class="p">:</span>
            <span class="n">cur_x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="o">-</span><span class="n">offset_x</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cur_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cur_x</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">centerx</span> <span class="o">-</span> <span class="n">view_x</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_y</span><span class="p">:</span>
            <span class="n">cur_y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="o">-</span><span class="n">offset_y</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cur_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cur_y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_h</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cur_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">centery</span> <span class="o">-</span> <span class="n">view_y</span>

        <span class="n">start_x</span> <span class="o">=</span> <span class="n">cur_x</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">while</span> <span class="n">cur_y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">scale</span><span class="p">:</span>
            <span class="n">cur_x</span> <span class="o">=</span> <span class="n">start_x</span>
            <span class="k">while</span> <span class="n">cur_x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">scale</span><span class="p">:</span>
                <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">cur_x</span> <span class="o">+</span> <span class="n">view_x</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">cur_y</span> <span class="o">+</span> <span class="n">view_y</span><span class="p">)))</span>
                <span class="n">cur_x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_w</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_x</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="n">cur_y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_h</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_y</span><span class="p">:</span>
                <span class="k">break</span></div></div>


<div class="viewcode-block" id="AnimatedSprite"><a class="viewcode-back" href="../spygame.html#spygame.AnimatedSprite">[docs]</a><span class="k">class</span> <span class="nc">AnimatedSprite</span><span class="p">(</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    adds an Animation component to each Sprite instance</span>
<span class="sd">    - AnimatedSprites need a SpriteSheet (no static images or no-render allowed)</span>

<span class="sd">    :param int x: the initial x position of the Sprite</span>
<span class="sd">    :param int y: the initial y position of the Sprite</span>
<span class="sd">    :param SpriteSheet spritesheet: the SpriteSheet object to use for this Sprite</span>
<span class="sd">    :param dict animation_setup: the dictionary with the animation setup data to be sent to Animation.register_settings (the name of the registry record will</span>
<span class="sd">            be spritesheet.name)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">spritesheet</span><span class="p">,</span> <span class="n">animation_setup</span><span class="p">:</span> <span class="nb">dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int x: the initial x position of the AnimatedSprite</span>
<span class="sd">        :param int y: the initial y position of the AnimatedSprite</span>
<span class="sd">        :param SpriteSheet spritesheet: the SpriteSheet to use for animamations</span>
<span class="sd">        :param dict animation_setup: a dictionary with all the different animation name and their settings (animation speed, frames to use, etc..)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">spritesheet</span><span class="p">,</span> <span class="n">SpriteSheet</span><span class="p">),</span> <span class="s2">&quot;ERROR: AnimatedSprite needs a SpriteSheet in its c&#39;tor!&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">spritesheet</span><span class="p">)</span>  <span class="c1"># assign the image/rect for the Sprite</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmp_animation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">Animation</span><span class="p">(</span><span class="s2">&quot;animation&quot;</span><span class="p">))</span>

        <span class="n">Animation</span><span class="o">.</span><span class="n">register_settings</span><span class="p">(</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">animation_setup</span><span class="p">,</span> <span class="n">register_events_on</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># play the default animation (now that we have added the Animation Component, we can call play_animation on ourselves)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">play_animation</span><span class="p">(</span><span class="n">animation_setup</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Display"><a class="viewcode-back" href="../spygame.html#spygame.Display">[docs]</a><span class="k">class</span> <span class="nc">Display</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a simple wrapper class for a pygame.display/pygame.Surface object representing the pygame display</span>
<span class="sd">    - also stores offset information for Viewport focusing (if Viewport is smaller that the Level, which is usually the case)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">instantiated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Spygame Rocks!&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int width: the width of the Display</span>
<span class="sd">        :param int height: the height of the Display</span>
<span class="sd">        :param str title: the caption to use on the pygame display</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">Display</span><span class="o">.</span><span class="n">instantiated</span><span class="p">,</span> <span class="s2">&quot;ERROR: can only create one </span><span class="si">{}</span><span class="s2"> object!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">Display</span><span class="o">.</span><span class="n">instantiated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_caption</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Display.change_dims"><a class="viewcode-back" href="../spygame.html#spygame.Display.change_dims">[docs]</a>    <span class="k">def</span> <span class="nf">change_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        changes the Display&#39;s size dynamically (during the game)</span>
<span class="sd">        :param int width: the new width to use</span>
<span class="sd">        :param int height: the new height to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">get_surface</span><span class="p">(),</span> <span class="s2">&quot;ERROR: self.display is not same object as pygame.display.get_surface() anymore!&quot;</span></div>

<div class="viewcode-block" id="Display.debug_refresh"><a class="viewcode-back" href="../spygame.html#spygame.Display.debug_refresh">[docs]</a>    <span class="k">def</span> <span class="nf">debug_refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        force-refreshes the display (used only for debug purposes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">([])</span>  <span class="c1"># we seem to have to do this</span></div></div>


<div class="viewcode-block" id="GameLoop"><a class="viewcode-back" href="../spygame.html#spygame.GameLoop">[docs]</a><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class that represents the GameLoop</span>
<span class="sd">    - has play and pause functions: play starts the tick/callback loop</span>
<span class="sd">    - has clock for ticking (keeps track of self.dt each tick), handles and abides to max-fps rate setting</span>
<span class="sd">    - handles keyboard input registrations via its KeyboardInputs object</span>
<span class="sd">    - needs a callback to know what to do each tick. Does the keyboard_inputs.tick, then calls callback with self as only argument</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># static loop object (the currently active GameLoop gets stored here)</span>
    <span class="n">active_loop</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="GameLoop.play_a_loop"><a class="viewcode-back" href="../spygame.html#spygame.GameLoop.play_a_loop">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">play_a_loop</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        factory: plays a given GameLoop object or creates a new one using the given \*\*kwargs options</span>

<span class="sd">        :param any kwargs:</span>
<span class="sd">                force_loop (bool): whether to play regardless of whether we still have some active loop running</span>
<span class="sd">                callback (callable): the GameLoop&#39;s callback loop function</span>
<span class="sd">                keyboard_inputs (KeyboardInputs): the GameLoop&#39;s KeyboardInputs object</span>
<span class="sd">                display (Display): the Display object to render everything on</span>
<span class="sd">                max_fps (int): the max frames per second to loop through</span>
<span class="sd">                screen_obj (Screen): alternatively, a Screen can be given, from which we will extract `display`, `max_fps` and `keyboard_inputs`</span>
<span class="sd">                game_loop (Union[str,GameLoop]): the GameLoop to use (instead of creating a new one); &quot;new&quot; or [empty] for new one</span>
<span class="sd">                dont_play (bool): whether - after creating the GameLoop - it should be `play`ed. Can be used for openAI gym purposes, where we just `step`, not `tick`</span>
<span class="sd">        :return: the created/played GameLoop object or None</span>
<span class="sd">        :rtype: Union[GameLoop,None]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">defaults</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;force_loop&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;screen_obj&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;display&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;max_fps&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="s2">&quot;game_loop&quot;</span> <span class="p">:</span> <span class="s2">&quot;new&quot;</span><span class="p">,</span> <span class="s2">&quot;dont_play&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>

        <span class="c1"># - if there&#39;s no other loop active, run the default stageGameLoop</span>
        <span class="c1"># - or: there is an active loop, but we force overwrite it</span>
        <span class="k">if</span> <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;force_loop&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;force_loop&quot;</span><span class="p">]):</span>
            <span class="c1"># generate a new loop (and play)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;game_loop&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;new&quot;</span><span class="p">:</span>
                <span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># set keyboard inputs directly</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">]:</span>
                    <span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">]</span>
                <span class="c1"># or through the screen_obj</span>
                <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]:</span>
                    <span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keyboard_inputs</span>

                <span class="n">display</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># set display directly</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;display&quot;</span><span class="p">]:</span>
                    <span class="n">display</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;display&quot;</span><span class="p">]</span>
                <span class="c1"># or through the screen_obj</span>
                <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]:</span>
                    <span class="n">display</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">display</span>

                <span class="n">max_fps</span> <span class="o">=</span> <span class="mi">60</span>
                <span class="c1"># set display directly</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_fps&quot;</span><span class="p">]:</span>
                    <span class="n">max_fps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_fps&quot;</span><span class="p">]</span>
                <span class="c1"># or through the screen_obj</span>
                <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]:</span>
                    <span class="n">max_fps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_fps</span>

                <span class="n">loop</span> <span class="o">=</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">Stage</span><span class="o">.</span><span class="n">stage_default_game_loop_callback</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">,</span>
                                <span class="n">keyboard_inputs</span><span class="o">=</span><span class="n">keyboard_inputs</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="n">max_fps</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;dont_play&quot;</span><span class="p">]:</span>
                    <span class="n">loop</span><span class="o">.</span><span class="n">play</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">loop</span>

            <span class="c1"># just play an already existing loop</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;game_loop&quot;</span><span class="p">],</span> <span class="n">GameLoop</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;game_loop&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">play</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;game_loop&quot;</span><span class="p">]</span>

            <span class="c1"># do nothing</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="n">display</span><span class="p">:</span> <span class="n">Display</span><span class="p">,</span> <span class="n">keyboard_inputs</span><span class="p">:</span> <span class="n">KeyboardInputs</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param callable callback: the callback function to call each time we `tick` (after collecting keyboard events)</span>
<span class="sd">        :param Display display: the Display object associated with the loop</span>
<span class="sd">        :param KeyboardInputs keyboard_inputs: the KeyboardInputs object to use for collecting keyboard information each tick (we simply call the</span>
<span class="sd">        KeyboardInputs&#39; `tick` method during our own `tick` method)</span>
<span class="sd">        :param int max_fps: the maximum frame rate per second to allow when ticking. fps can be slower, but never faster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True -&gt; Game loop will be paused (no frames, no ticks)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>  <span class="c1"># gets called each tick with this GameLoop instance as the first parameter (can then extract dt as `game_loop.dt`)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>  <span class="c1"># our tick object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># global frame counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># time since last tick was executed</span>
        <span class="c1"># registers those keyboard inputs to capture each tick (up/right/down/left as default if none given)</span>
        <span class="c1"># - keyboard inputs can be changed during the loop via self.keyboard_input.update_keys([new key list])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">keyboard_inputs</span> <span class="ow">or</span> <span class="n">KeyboardInputs</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span> <span class="o">=</span> <span class="n">max_fps</span>

<div class="viewcode-block" id="GameLoop.pause"><a class="viewcode-back" href="../spygame.html#spygame.GameLoop.pause">[docs]</a>    <span class="k">def</span> <span class="nf">pause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pauses this GameLoop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="GameLoop.play"><a class="viewcode-back" href="../spygame.html#spygame.GameLoop.play">[docs]</a>    <span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plays this GameLoop (after pausing the currently running GameLoop, if any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pause the current loop</span>
        <span class="k">if</span> <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span><span class="p">:</span>
            <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span><span class="o">.</span><span class="n">pause</span><span class="p">()</span>
        <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># tick as long as we are not paused</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">max_fps</span><span class="p">)</span></div>

<div class="viewcode-block" id="GameLoop.tick"><a class="viewcode-back" href="../spygame.html#spygame.GameLoop.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        called each frame of the GameLoop</span>
<span class="sd">        - collects keyboard events</span>
<span class="sd">        - calls the GameLoop&#39;s `callback`</span>
<span class="sd">        - keeps a frame counter</span>

<span class="sd">        :param int max_fps: the maximum allowed number of frames per second (usually 60)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">max_fps</span><span class="p">:</span>
            <span class="n">max_fps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span>

        <span class="c1"># move the clock and store the dt (since last frame) in sec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">max_fps</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>

        <span class="c1"># default global events?</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">)</span>  <span class="c1"># TODO: add more here?</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="p">(</span><span class="ne">SystemExit</span><span class="p">,</span> <span class="s2">&quot;QUIT&quot;</span><span class="p">)</span>

        <span class="c1"># collect keyboard events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>

        <span class="c1"># call the callback with self (for references to important game parameters)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># increase global frame counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="GameLoop.step"><a class="viewcode-back" href="../spygame.html#spygame.GameLoop.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (!)for reinforcement learning only(!) WIP:</span>
<span class="sd">        executes one action on the game</span>
<span class="sd">        - the action gets translated into a keyboard sequence first, then is played</span>

<span class="sd">        :param str action: the action to execute on the MDP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># default global events?</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">)</span>  <span class="c1"># TODO: add more here?</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="p">(</span><span class="ne">SystemExit</span><span class="p">,</span> <span class="s2">&quot;QUIT&quot;</span><span class="p">)</span>

        <span class="c1"># collect keyboard events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>

        <span class="c1"># call the callback with self (for references to important game parameters)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># increase global frame counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span></div></div>


<div class="viewcode-block" id="Stage"><a class="viewcode-back" href="../spygame.html#spygame.Stage">[docs]</a><span class="k">class</span> <span class="nc">Stage</span><span class="p">(</span><span class="n">GameObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Stage is a container class for Sprites sorted by pygame.sprite.Groups and TiledTileLayers</span>
<span class="sd">    - Sprites within a Stage can collide with each other or with the TiledTileLayers in the Stage</span>
<span class="sd">    - Sprites and TiledTileLayers that are to be rendered are stored sorted by their render_order property (lowest renders first)</span>
<span class="sd">    -</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># list of all Stages</span>
    <span class="n">max_stages</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">stages</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_stages</span><span class="p">)]</span>
    <span class="n">active_stage</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the currently ticked/rendered Stage</span>

    <span class="c1"># the default game loop callback to use if none given when staging a Scene</span>
    <span class="c1"># - clamps dt</span>
    <span class="c1"># - ticks all stages</span>
    <span class="c1"># - renders all stages</span>
    <span class="c1"># - updates the pygame.display</span>
<div class="viewcode-block" id="Stage.stage_default_game_loop_callback"><a class="viewcode-back" href="../spygame.html#spygame.Stage.stage_default_game_loop_callback">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stage_default_game_loop_callback</span><span class="p">(</span><span class="n">game_loop</span><span class="p">:</span> <span class="n">GameLoop</span><span class="p">):</span>
        <span class="c1"># clamp dt</span>
        <span class="k">if</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">60</span>
        <span class="k">elif</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">15</span><span class="p">:</span>
            <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">15</span>

        <span class="c1"># tick all Stages</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stage</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">):</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">stage</span><span class="p">:</span>
                <span class="n">stage</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">game_loop</span><span class="p">)</span>

        <span class="c1"># render all Stages and refresh the pygame.display</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">render_stages</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">,</span> <span class="n">refresh_after_render</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Stage.render_stages"><a class="viewcode-back" href="../spygame.html#spygame.Stage.render_stages">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">render_stages</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">refresh_after_render</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        loops through all Stages and renders all of them</span>

<span class="sd">        :param Display display: Display object on which to render</span>
<span class="sd">        :param bool refresh_after_render: do we refresh the pygame.display after all Stages have been called with `render`?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># black out display (really necessary? I think so)</span>
        <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;#000000&quot;</span><span class="p">))</span>
        <span class="c1"># call render on all Stages</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stage</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">):</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">stage</span><span class="p">:</span>
                <span class="n">stage</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">display</span><span class="p">)</span>
        <span class="c1"># for debugging purposes</span>
        <span class="k">if</span> <span class="n">refresh_after_render</span><span class="p">:</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stage.clear_stage"><a class="viewcode-back" href="../spygame.html#spygame.Stage.clear_stage">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">clear_stage</span><span class="p">(</span><span class="n">idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Stage.clear_stages"><a class="viewcode-back" href="../spygame.html#spygame.Stage.clear_stages">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">clear_stages</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">)):</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">clear_stage</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.get_stage"><a class="viewcode-back" href="../spygame.html#spygame.Stage.get_stage">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_stage</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the Stage at the given index (returns None if none found)</span>

<span class="sd">        :param Union[int,None] idx: the index of the Stage to return (0=default Stage)</span>
<span class="sd">        :return: the Stage object at the given index or None if there is no Stage at that index</span>
<span class="sd">        :rtype: Union[Stage,None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span>
        <span class="k">return</span> <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="Stage.stage_screen"><a class="viewcode-back" href="../spygame.html#spygame.Stage.stage_screen">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stage_screen</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="n">screen_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stage_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        supported options are (if not given, we take some of them from given Screen object, instead):</span>
<span class="sd">        - stage_idx (int): sets the stage index to use (0-9)</span>
<span class="sd">        - stage_class (class): sets the class (must be a Stage class) to be used when creating the new Stage</span>
<span class="sd">        - force_loop (bool): if set to True and we currently have a GameLoop running, stop the current GameLoop and replace it with a new one, which has</span>
<span class="sd">        to be given via the &quot;game_loop&quot; option (as GameLoop object, or as string &quot;new&quot; for a default GameLoop)</span>
<span class="sd">        - keyboard_inputs (KeyboardInputs): the KeyboardInputs object to use for the new GameLoop</span>
<span class="sd">        - display (Display): the Display to use for the new GameLoop</span>
<span class="sd">        - components (List[Component]): a list of Component objects to add to the new Stage (e.g. a Viewport)</span>

<span class="sd">        :param Screen screen: the Screen object to set up on a certain stage</span>
<span class="sd">        :param callable screen_func: the function to use to set up the Stage (before playing it)</span>
<span class="sd">        :param int stage_idx: the Stage index to use (0=default Stage)</span>
<span class="sd">        :param dict options: options to be used when instantiating the Stage</span>
<span class="sd">        :return: the new Stage object</span>
<span class="sd">        :rtype: Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">defaults</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;stage_class&quot;</span><span class="p">:</span> <span class="n">Stage</span><span class="p">})</span>

        <span class="c1"># figure out which stage to use</span>
        <span class="n">stage_idx</span> <span class="o">=</span> <span class="n">stage_idx</span> <span class="k">if</span> <span class="n">stage_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stage_idx&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;stage_idx&quot;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># clean up an existing stage if necessary</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">clear_stage</span><span class="p">(</span><span class="n">stage_idx</span><span class="p">)</span>

        <span class="c1"># create a new Stage and make this this the active stage</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">stage_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;stage_class&quot;</span><span class="p">](</span><span class="n">screen</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="n">stage_idx</span>

        <span class="c1"># setup the Stage via the screen_fun (passing it the newly created Stage)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">screen_func</span><span class="p">:</span>
            <span class="n">screen_func</span> <span class="o">=</span> <span class="n">screen</span><span class="o">.</span><span class="n">screen_func</span>

        <span class="n">screen_func</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># finally return the stage to the user for use if needed</span>
        <span class="k">return</span> <span class="n">stage</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">screen</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="o">=</span> <span class="n">screen</span>  <span class="c1"># the screen object associated with this Stage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_layers</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># pytmx.pytmx.TiledLayer (TiledTileLayer or TiledObjectGroup) by name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of all layers by name (TiledTileLayers AND TiledObjectGroups) in the order in which they have to be rendered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_layers_to_collide</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of all layers that collide (mask is not 0) by name (TiledTileLayers)</span>

        <span class="c1"># dict of pygame.sprite.Group objects (by name) that contain Sprites (each TiledObjectGroup results in one Group)</span>
        <span class="c1"># - the name of the group is always the name of the TiledObjectGroup in the tmx file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># a plain list of all Sprites in this Stage</span>

        <span class="c1"># self.index = {}  # used for search methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># sprites to be removed from the Stage (only remove when Stage gets ticked)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span> <span class="ow">or</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># register events that we will trigger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;destroyed&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;added_to_stage&quot;</span><span class="p">,</span> <span class="s2">&quot;removed_from_stage&quot;</span><span class="p">,</span>  <span class="c1"># Sprites added/removed to/from us</span>
                            <span class="s2">&quot;pre_ticks&quot;</span><span class="p">,</span> <span class="s2">&quot;pre_collisions&quot;</span><span class="p">,</span>  <span class="c1"># before we tick all Sprites, before we analyse all Sprites for collisions</span>
                            <span class="s2">&quot;post_tick&quot;</span><span class="p">,</span>  <span class="c1"># after we ticked all Sprites</span>
                            <span class="s2">&quot;pre_render&quot;</span><span class="p">,</span> <span class="s2">&quot;post_render&quot;</span>  <span class="c1"># before/after we render all our layers</span>
                            <span class="p">)</span>

        <span class="c1"># add Components to this Stage (given in options)</span>
        <span class="k">if</span> <span class="s2">&quot;components&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">Component</span><span class="p">),</span> <span class="s2">&quot;ERROR: one of the given components in Stage&#39;s c&#39;tor (options[&#39;components&#39;]) is not of type Component!&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>

        <span class="c1"># make sure our destroyed method is called when the stage is destroyed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;destroyed&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Stage.destroyed"><a class="viewcode-back" href="../spygame.html#spygame.Stage.destroyed">[docs]</a>    <span class="k">def</span> <span class="nf">destroyed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="s2">&quot;debind_events&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;destroyed&quot;</span><span class="p">)</span></div>

    <span class="c1">#OBSOLETE:</span>
    <span class="c1"># executes our Scene by calling the Scene&#39;s function with self as only parameter</span>
    <span class="c1">#def load_scene(self):</span>
    <span class="c1">#    if self.scene:</span>
    <span class="c1">#        self.scene.scene_func(self)</span>

    <span class="c1"># TODO: loadAssets?</span>

    <span class="c1"># calls the callback function for each sprite, each time passing it the sprite and params</span>
<div class="viewcode-block" id="Stage.for_each"><a class="viewcode-back" href="../spygame.html#spygame.Stage.for_each">[docs]</a>    <span class="k">def</span> <span class="nf">for_each</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>  <span class="c1"># quintus: `each`</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span></div>

    <span class="c1"># calls a function on all of the GameObjects on this Stage</span>
<div class="viewcode-block" id="Stage.invoke"><a class="viewcode-back" href="../spygame.html#spygame.Stage.invoke">[docs]</a>    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">func_name</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">func_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                    <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span></div>

    <span class="c1"># returns the first GameObject in this Stage that - when passed to the detector function with params - returns True</span>
<div class="viewcode-block" id="Stage.detect"><a class="viewcode-back" href="../spygame.html#spygame.Stage.detect">[docs]</a>    <span class="k">def</span> <span class="nf">detect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detector</span><span class="p">:</span> <span class="n">callable</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">detector</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sprite</span></div>

<div class="viewcode-block" id="Stage.add_tiled_layer"><a class="viewcode-back" href="../spygame.html#spygame.Stage.add_tiled_layer">[docs]</a>    <span class="k">def</span> <span class="nf">add_tiled_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adds a pytmx.TiledElement to the Stage with all its tiles or objects</span>
<span class="sd">        - the TiledElement could either be converted into a TiledTileLayer or a TiledObjectGroup (these objects are generated in this function based on the</span>
<span class="sd">        pytmx equivalent being passed in)</span>

<span class="sd">        :param pytmx.pytmx.TiledElement pytmx_layer: the original pytmx object to derive our TiledTileLayer or TileObjectGroup from</span>
<span class="sd">        :param pytmx.pytmx.TiledMap pytmx_tiled_map: the original pytmx TiledMap object (the tmx file) to which this layer belongs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">pytmx_layer</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiled_layers</span><span class="p">,</span> <span class="s2">&quot;ERROR: pytmx_layer with name </span><span class="si">{}</span><span class="s2"> already exists!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># a TiledObjectGroup (&quot;Object Layer&quot; in the tmx file)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledObjectGroup</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">TiledObjectGroup</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_tiled_object_group</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="c1"># a TiledTileLayer (&quot;Tile Layer&quot; in the tmx file)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledTileLayer</span><span class="p">):</span>
            <span class="c1"># use default collision objects if not given</span>
            <span class="k">if</span> <span class="s2">&quot;tile_layer_physics_collisions&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tile_layer_physics_collisions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Collision</span><span class="p">(),</span> <span class="n">Collision</span><span class="p">())</span>
            <span class="k">assert</span> <span class="s2">&quot;tile_layer_physics_collision_detector&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> \
                <span class="s2">&quot;ERROR: a TiledTileLayer needs a physics collision detector given in the Stage&#39;s option: `tile_layer_physics_collision_detector`!&quot;</span>
            <span class="k">assert</span> <span class="s2">&quot;tile_layer_physics_collision_postprocessor&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> \
                <span class="s2">&quot;ERROR: a TiledTileLayer needs a physics collision handler given in the Stage&#39;s option: `tile_layer_physics_collision_postprocessor`!&quot;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">TiledTileLayer</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tile_layer_physics_collisions&quot;</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tile_layer_physics_collision_detector&quot;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tile_layer_physics_collision_postprocessor&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_tiled_tile_layer</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: pytmx_layer of type </span><span class="si">{}</span><span class="s2"> cannot be added to Stage. Needs to be pytmx.pytmx.TiledTileLayer or pytmx.pytmx.TiledObjectGroup!&quot;</span><span class="o">.</span>
                            <span class="nb">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stage.add_tiled_object_group"><a class="viewcode-back" href="../spygame.html#spygame.Stage.add_tiled_object_group">[docs]</a>    <span class="k">def</span> <span class="nf">add_tiled_object_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tiled_object_group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adds a TiledObjectGroup (all it&#39;s objects as single Sprites) to this Stage</span>
<span class="sd">        :param TiledObjectGroup tiled_object_group:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add the layer to our tiled_layers list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_layers</span><span class="p">[</span><span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tiled_object_group</span>

        <span class="c1"># add the (already created) sprite-group to this stage under the name of the layer</span>
        <span class="k">assert</span> <span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">,</span> \
            <span class="s2">&quot;ERROR: trying to add a TiledObjectGroup to a Stage, but the Stage already has a spritegroup with the name of that layer (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span> \
                <span class="nb">format</span><span class="p">(</span><span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">[</span><span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tiled_object_group</span><span class="o">.</span><span class="n">sprite_group</span>

        <span class="c1"># add each single Sprite to the sorted (by render_order) to_render list and to the &quot;all&quot;-sprites list</span>
        <span class="c1"># - note: the to_render list also contains entire TiledTileLayer objects</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="n">tiled_object_group</span><span class="o">.</span><span class="n">sprite_group</span><span class="o">.</span><span class="n">sprites</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">render_order</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.add_tiled_tile_layer"><a class="viewcode-back" href="../spygame.html#spygame.Stage.add_tiled_tile_layer">[docs]</a>    <span class="k">def</span> <span class="nf">add_tiled_tile_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tiled_tile_layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adds a TiledTileLayer to this Stage</span>
<span class="sd">        - puts it in the ordered to_render list, in the tiled_layers list, as well as in the tiled_layers_to_collide list (iff type != none)</span>

<span class="sd">        :param TiledTileLayer tiled_tile_layer: the TiledTileLayer to add to this Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># put the pytmx_layer into one of the collision groups (if not type==none)?</span>
        <span class="c1"># - this is useful for our solve_collisions method</span>
        <span class="k">if</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;none&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tiled_layers_to_collide</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tiled_tile_layer</span><span class="p">)</span>

        <span class="c1"># put only TiledTileLayers in to_render (iff do_render=true) and single Sprites (from the TiledObjectGroup) all ordered by render_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_layers</span><span class="p">[</span><span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tiled_tile_layer</span>

        <span class="c1"># add it to the to_render list and re-sort the list by render_order values (note: this list also contains single Sprites)</span>
        <span class="k">if</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tiled_tile_layer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">render_order</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.add_sprite"><a class="viewcode-back" href="../spygame.html#spygame.Stage.add_sprite">[docs]</a>    <span class="k">def</span> <span class="nf">add_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">group_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adds a new single Sprite to an existing or a new pygame.sprite.Group</span>

<span class="sd">        :param Sprite sprite: the Sprite to be added to this Stage (the Sprite&#39;s position is defined in its rect.x/y properties)</span>
<span class="sd">        :param str group_name: the name of the group to which the GameObject should be added (group will not be created if it doesn&#39;t exist yet)</span>
<span class="sd">        :return: the Sprite that was added</span>
<span class="sd">        :rtype: Sprite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if the group doesn&#39;t exist yet, create it</span>
        <span class="k">if</span> <span class="n">group_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Group</span><span class="p">()</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">stage</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1"># set the Stage of this GameObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">sprite_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">])</span>

        <span class="c1"># trigger two events, one on the Stage with the object as target and one on the object with the Stage as target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;added_to_stage&quot;</span><span class="p">,</span> <span class="n">sprite</span><span class="p">)</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;added_to_stage&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sprite</span></div>

<div class="viewcode-block" id="Stage.remove_sprite"><a class="viewcode-back" href="../spygame.html#spygame.Stage.remove_sprite">[docs]</a>    <span class="k">def</span> <span class="nf">remove_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">:</span> <span class="n">Sprite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        removes a Sprite from this Stage by putting it in the remove_list for later removal</span>

<span class="sd">        :param Sprite sprite: the Sprite to be removed from the Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.force_remove_sprite"><a class="viewcode-back" href="../spygame.html#spygame.Stage.force_remove_sprite">[docs]</a>    <span class="k">def</span> <span class="nf">force_remove_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">:</span> <span class="n">Sprite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        force-removes the given Sprite immediately (without putting it in the remove_list first)</span>

<span class="sd">        :param Sprite sprite: the Sprite to be removed from the Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># destroy the object</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;removed_from_stage&quot;</span><span class="p">,</span> <span class="n">sprite</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.pause"><a class="viewcode-back" href="../spygame.html#spygame.Stage.pause">[docs]</a>    <span class="k">def</span> <span class="nf">pause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        pauses playing the Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Stage.unpause"><a class="viewcode-back" href="../spygame.html#spygame.Stage.unpause">[docs]</a>    <span class="k">def</span> <span class="nf">unpause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        unpauses playing the Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Stage.solve_collisions"><a class="viewcode-back" href="../spygame.html#spygame.Stage.solve_collisions">[docs]</a>    <span class="k">def</span> <span class="nf">solve_collisions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        look for the objects layer and do each object against the main collision layer</span>
<span class="sd">        - some objects in the objects layer do their own collision -&gt; skip those here (e.g. ladder climbing objects)</span>
<span class="sd">        - after the main collision layer, do each object against each other</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># collide each object with all collidable layers (matching collision mask of object)</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="c1"># if this game_object completely handles its own collisions within its tick -&gt; ignore it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sprite</span><span class="o">.</span><span class="n">handles_own_collisions</span> <span class="ow">and</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># collide with all matching tile layers</span>
                <span class="k">for</span> <span class="n">tile_layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiled_layers_to_collide</span><span class="p">:</span>
                    <span class="c1"># only collide, if the type of the layer matches one of the object&#39;s bits in the mask</span>
                    <span class="c1"># TODO: do we have to match the layer&#39;s collision mask as well? (layers currently don&#39;t have a collision mask)</span>
                    <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">tile_layer</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="n">tile_layer</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                            <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># collide all objects with all other game-objects</span>
        <span class="n">exhaustive</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">exhaustive</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
            <span class="c1"># if this game_object completely handles its own collisions within its tick -&gt; ignore it</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sprite</span><span class="o">.</span><span class="n">handles_own_collisions</span> <span class="ow">and</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sprite2</span> <span class="ow">in</span> <span class="n">exhaustive</span><span class="p">:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                        <span class="c1"># TODO: do we have to trigger the reversed collision as well?</span>
                        <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.tick"><a class="viewcode-back" href="../spygame.html#spygame.Stage.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        gets called each frame by the GameLoop</span>
<span class="sd">        - calls update on all its Sprites (through &#39;updateSprites&#39;)</span>

<span class="sd">        :param GameLoop game_loop: the GameLoop object that&#39;s currently running (and ticking all Stages)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># do the ticking of all objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;pre_ticks&quot;</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_EACH_TICK</span><span class="p">:</span>
                <span class="n">sprite</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">game_loop</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_AFTER_EACH_TICK</span><span class="p">:</span>
                <span class="n">sprite</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>

        <span class="c1"># do the collision resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;pre_collisions&quot;</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_collisions</span><span class="p">()</span>

        <span class="c1"># garbage collect destroyed GameObjects</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_remove_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_list</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.hide"><a class="viewcode-back" href="../spygame.html#spygame.Stage.hide">[docs]</a>    <span class="k">def</span> <span class="nf">hide</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        hides the Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Stage.show"><a class="viewcode-back" href="../spygame.html#spygame.Stage.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        unhides the Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Stage.stop"><a class="viewcode-back" href="../spygame.html#spygame.Stage.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        stops playing the Stage (stops calling `tick` on all GameObjects)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hide</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pause</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stage.start"><a class="viewcode-back" href="../spygame.html#spygame.Stage.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        starts running the Stage (and calling all GameObject&#39;s `tick` method)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unpause</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stage.render"><a class="viewcode-back" href="../spygame.html#spygame.Stage.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">:</span> <span class="n">Display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        gets called each frame by the GameLoop (after &#39;tick&#39; is called on all Stages)</span>
<span class="sd">        - renders all its layers (ordered by &#39;render_order&#39; property of the TiledTileLayer in the tmx file)</span>
<span class="sd">        TODO: - renders Sprites that are not part of any layer</span>

<span class="sd">        :param Display display: the Display object to render on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;pre_render&quot;</span><span class="p">,</span> <span class="n">display</span><span class="p">)</span>
        <span class="c1"># loop through the sorted to_render list and render all TiledTileLayer and Sprite objects in this list</span>
        <span class="k">for</span> <span class="n">layer_or_sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="p">:</span>
            <span class="n">layer_or_sprite</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">display</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;post_render&quot;</span><span class="p">,</span> <span class="n">display</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TmxLayer"><a class="viewcode-back" href="../spygame.html#spygame.TmxLayer">[docs]</a><span class="k">class</span> <span class="nc">TmxLayer</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a wrapper class for the pytmx TiledObject class that can either represent a TiledTileLayer or a TiledObjectGroup</span>
<span class="sd">    - needs to implement render and stores some spygame specific properties such as collision, render, etc.</span>

<span class="sd">    :param pytmx.pytmx.TiledElement tmx_layer_obj: the underlying pytmx TiledTileLayer</span>
<span class="sd">    :param pytmx.pytmx.TiledMap tmx_tiled_map: the underlying pytmx TiledMap object (representing the tmx file)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmx_layer_obj</span><span class="p">,</span> <span class="n">tmx_tiled_map</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span> <span class="o">=</span> <span class="n">tmx_layer_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span> <span class="o">=</span> <span class="n">tmx_tiled_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tmx_layer_obj</span><span class="o">.</span><span class="n">name</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">tmx_layer_obj</span><span class="o">.</span><span class="n">properties</span>
        <span class="n">defaults</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;do_render&quot;</span><span class="p">:</span> <span class="s2">&quot;true&quot;</span><span class="p">,</span> <span class="s2">&quot;render_order&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="n">properties</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;do_render&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">render_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;render_order&quot;</span><span class="p">])</span>

<div class="viewcode-block" id="TmxLayer.render"><a class="viewcode-back" href="../spygame.html#spygame.TmxLayer.render">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">:</span> <span class="n">Display</span><span class="p">):</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="TiledTileLayer"><a class="viewcode-back" href="../spygame.html#spygame.TiledTileLayer">[docs]</a><span class="k">class</span> <span class="nc">TiledTileLayer</span><span class="p">(</span><span class="n">TmxLayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a wrapper class for pytmx.pytmx.TiledTileLayer, which represents a &#39;normal&#39; tile layer in a tmx file</span>
<span class="sd">    - reads in all tiles&#39; images into one Surface object so we can render the entire layer at once</span>
<span class="sd">    - implements `render`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="n">collision_objects</span><span class="p">,</span> <span class="n">collision_detector</span><span class="p">,</span> <span class="n">collision_postprocessor</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param pytmx.pytmx.TiledTileLayer pytmx_layer: the underlying pytmx TiledTileLayer</span>
<span class="sd">        :param pytmx.pytmx.TiledMap pytmx_tiled_map: the underlying pytmx TiledMap object (representing the tmx file)</span>
<span class="sd">        :param callable collision_detector: the function to use for detecting collisions (e.g. spyg.SATCollision/spyg.AABBCollision/etc..)</span>
<span class="sd">        :param callable collision_postprocessor: the function to use to handle collisions (once detected by the collision_detector)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">props_by_pos</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># stores the properties of each tile by position tuple (x, y)</span>
        <span class="c1"># an object representing a single tile from this layer to pass to a collision function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprite</span> <span class="o">=</span> <span class="n">TileSprite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">)))</span>
        <span class="c1"># store our tuple of two Collision objects for passing into the collision handler</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collision_objects</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">collision_objects</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> \
               <span class="nb">isinstance</span><span class="p">(</span><span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Collision</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">collision_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Collision</span><span class="p">),</span> \
            <span class="s2">&quot;ERROR: parameter collision_objects needs to be a tuple of two Collision objects!&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_objects</span> <span class="o">=</span> <span class="n">collision_objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_detector</span> <span class="o">=</span> <span class="n">collision_detector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_postprocessor</span> <span class="o">=</span> <span class="n">collision_postprocessor</span>

        <span class="c1"># get collision mask of this layer from self.collision property</span>
        <span class="n">types_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types_</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># update do_render indicator depending on some debug settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_DONT_RENDER_TILED_TILE_LAYERS</span><span class="p">))</span> <span class="ow">or</span> \
                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_COLLISION_TILES</span><span class="p">))</span>
        <span class="c1"># put this layer in one single Sprite that we can then blit on the display (with &#39;area=&#39; to avoid drawing the entire layer each time)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># we are rendering this layer, need to get entire image into this structure</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
            <span class="n">surf</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">),</span>
                                  <span class="n">flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">SRCALPHA</span><span class="p">)</span>
            <span class="c1"># rendered collision layer</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_COLLISION_TILES</span><span class="p">):</span>
                <span class="c1"># red for normal collisions, light-blue for touch collisions</span>
                <span class="n">color</span> <span class="o">=</span> <span class="n">DEBUG_RENDER_COLLISION_TILES_COLOR_DEFAULT</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">DEBUG_RENDER_COLLISION_TILES_COLOR_OTHER</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gid</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">tiles</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">iter_data</span><span class="p">()):</span>
                    <span class="n">surf</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">(),</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">))</span>
                    <span class="n">tile_props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">get_tile_properties_by_gid</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{}</span>
                    <span class="c1"># normal collision tiles</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;no_collision&quot;</span><span class="p">):</span>
                        <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">),</span>
                                                                  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="c1"># &quot;normal&quot; layer (and no debug rendering)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">tiles</span><span class="p">():</span>
                    <span class="n">surf</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">(),</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">))</span>

            <span class="n">pygame_sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">()</span>
            <span class="n">pygame_sprite</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">surf</span>
            <span class="n">pygame_sprite</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">get_rect</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span> <span class="o">=</span> <span class="n">pygame_sprite</span>

        <span class="c1"># this is a collision layer, need to store each non-empty tile&#39;s (gid &gt; 0) properties</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;none&quot;</span><span class="p">):</span>
            <span class="c1"># loop through each tile and store tile props by x/y tuple in our dict</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">gid</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">iter_data</span><span class="p">():</span>
                <span class="c1"># skip empty tiles (gid==0)</span>
                <span class="k">if</span> <span class="n">gid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">tile_props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">get_tile_properties_by_gid</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{}</span>
                <span class="c1"># go through dict and translate data types into proper python types (&quot;true&quot; -&gt; bool, 0.0 -&gt; float, etc..)</span>
                <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="c1"># bool</span>
                    <span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;false&quot;</span><span class="p">:</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">)</span>
                    <span class="c1"># int</span>
                    <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;\d+&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)):</span>
                        <span class="n">value</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="c1"># float (or string)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">try</span><span class="p">:</span>
                            <span class="n">value</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                        <span class="k">except</span> <span class="p">(</span><span class="ne">ValueError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>  <span class="c1"># string/list/etc..</span>
                            <span class="k">pass</span>
                    <span class="c1"># assign correct typed value</span>
                    <span class="n">tile_props</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

                <span class="c1"># directly translate possible tile types (for collision) into the correct bitmask</span>
                <span class="n">types_</span> <span class="o">=</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
                <span class="c1"># type of this tile has not been translated into bitmap yet</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">types_</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">tile_props</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types_</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
                        <span class="n">tile_props</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="o">|=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">props_by_pos</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span> <span class="o">=</span> <span class="n">tile_props</span>

<div class="viewcode-block" id="TiledTileLayer.render"><a class="viewcode-back" href="../spygame.html#spygame.TiledTileLayer.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">:</span> <span class="n">Display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        blits a part of our Sprite&#39;s image onto the Display&#39;s Surface using the Display&#39;s offset attributes</span>

<span class="sd">        :param Display display: the Display object to render on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span><span class="p">,</span> <span class="s2">&quot;ERROR: TiledTileLayer.render() called but self.do_render is False!&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span><span class="p">,</span> <span class="n">Sprite</span><span class="p">),</span> <span class="s2">&quot;ERROR: TiledTileLayer.render() called but self.pygame_sprite is not a Sprite!&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span><span class="o">.</span><span class="n">rect</span><span class="p">)</span>  <span class="c1"># make a clone so we don&#39;t change the original Rect</span>
        <span class="c1"># apply the display offsets (camera)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">r</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># TODO: we shouldn&#39;t have to do this each render, just once (display size does not change)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span>
        <span class="n">r</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
        <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">area</span><span class="o">=</span><span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="TiledTileLayer.collide"><a class="viewcode-back" href="../spygame.html#spygame.TiledTileLayer.collide">[docs]</a>    <span class="k">def</span> <span class="nf">collide</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">:</span> <span class="n">Sprite</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        solves collisions between this tile layer and any Sprite (depends on the velocity of the Sprite)</span>

<span class="sd">        :param Sprite sprite: the Sprite to test</span>
<span class="sd">        :param str direction: the direction in which to check for collision (&#39;x&#39; or &#39;y&#39;)</span>
<span class="sd">        :param float direction_veloc: the velocity of the Sprite in the given direction (can be negative)</span>
<span class="sd">        :return: a Collision object with all details of the collision between the Sprite and this layer (None if there is no collision)</span>
<span class="sd">        :rtype: Union[None,Collision]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine the tile steps (left/right up/down)</span>
        <span class="n">direction_x</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">direction_y</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">direction_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">direction_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">))</span>

        <span class="n">tile_start_x</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span>
        <span class="n">tile_end_x</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span>
        <span class="n">tile_start_y</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span>
        <span class="n">tile_end_y</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span>

        <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_ACTIVE_COLLISION_TILES</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tile_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tile_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="p">,</span> <span class="n">DEBUG_RENDER_ACTIVE_COLLISION_TILES_COLOR</span><span class="p">,</span>
                                     <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">((</span><span class="n">tile_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">tile_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">),</span>
                                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">direction_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tile_end_x</span>
            <span class="n">tile_end_x</span> <span class="o">=</span> <span class="n">tile_start_x</span>
            <span class="n">tile_start_x</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="k">if</span> <span class="n">direction_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">tile_end_y</span>
            <span class="n">tile_end_y</span> <span class="o">=</span> <span class="n">tile_start_y</span>
            <span class="n">tile_start_y</span> <span class="o">=</span> <span class="n">tmp</span>

        <span class="c1"># - slope handling takes place here</span>
        <span class="c1">#   - slope-handling: pick that tile for the collision that has to deal with shifting the y-pos of the character up</span>
        <span class="c1">#     (which means, if we find a collision with a slope-2-offset-1-tile and the character is already touching the next tile with its right-x-corner, we pick the next tile (if it&#39;s also a slope 2, etc...)</span>
        <span class="c1"># - pick the first collision and return it</span>
        <span class="c1"># - make sure each tile is only checked once for collisions (use tileFlags hash to tag tiles as &quot;already processed&quot;)</span>
        <span class="c1"># - the order of the tiles we loop through is bottom-up and in direction of characters running direction (objp.vx)</span>
        <span class="k">for</span> <span class="n">tile_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">+</span> <span class="n">direction_y</span><span class="p">,</span> <span class="n">direction_y</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tile_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span> <span class="o">+</span> <span class="n">direction_x</span><span class="p">,</span> <span class="n">direction_x</span><span class="p">):</span>
                <span class="n">tile_xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">)</span>

                <span class="n">tile_props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">props_by_pos</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">tile_xy</span><span class="p">)</span>

                <span class="c1"># empty tile OR no_collision property of this tile is set to &#39;true&#39; -&gt; skip</span>
                <span class="k">if</span> <span class="n">tile_props</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;no_collision&quot;</span><span class="p">):</span>
                    <span class="k">continue</span>

                <span class="c1"># set up our TileSprite (a Sprite that represents a single tile) for the collision detector</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprite</span><span class="o">.</span><span class="n">tile_x</span> <span class="o">=</span> <span class="n">tile_x</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprite</span><span class="o">.</span><span class="n">tile_y</span> <span class="o">=</span> <span class="n">tile_y</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">tile_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">tile_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprite</span><span class="o">.</span><span class="n">tile_props</span> <span class="o">=</span> <span class="n">tile_props</span>

                <span class="c1"># check the actual collision with our collision detector</span>
                <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collision_detector</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprite</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">collision_objects</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="o">=</span><span class="n">direction_veloc</span><span class="p">)</span>

                <span class="c1"># we got a new collision with this tile -&gt; post-process collision and - if still ok - return</span>
                <span class="k">if</span> <span class="n">col</span> <span class="ow">and</span> <span class="n">col</span><span class="o">.</span><span class="n">is_collided</span> <span class="ow">and</span> <span class="n">col</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># post-process the collision depending on the given Physics engine&#39;s post-processor (e.g. to deal with slopes)</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">collision_postprocessor</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
                    <span class="c1"># collision is still ok (after post-processing) -&gt; trigger collision event on Sprite</span>
                    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">is_collided</span><span class="p">:</span>
                        <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                        <span class="c1"># return after the first tile collided with Sprite</span>
                        <span class="k">return</span> <span class="n">col</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># keep looking for other tiles that might collide</span>
                        <span class="k">continue</span>

        <span class="k">return</span> <span class="kc">None</span>  <span class="c1"># no collision</span></div></div>


<div class="viewcode-block" id="TileSprite"><a class="viewcode-back" href="../spygame.html#spygame.TileSprite">[docs]</a><span class="k">class</span> <span class="nc">TileSprite</span><span class="p">(</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    class used by TiledTileLayer objects to have a means of representing single tiles in terms of Sprite objects</span>
<span class="sd">    (used for collision detector function)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">:</span> <span class="n">TiledTileLayer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">:</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledMap</span><span class="p">,</span> <span class="n">rect</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param TiledTileLayer layer: the TiledTileLayer object to which this tile belongs</span>
<span class="sd">        :param pytmx.pytmx.TiledMap pytmx_tiled_map: the tmx tiled-map object to which this tile belongs</span>
<span class="sd">                                                     (useful to have to look up certain map-side properties, e.g. tilewidth/height)</span>
<span class="sd">        :param Union[pygame.Rect,None] rect: the pygame.Rect representing the position and size of the tile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_tile_layer</span> <span class="o">=</span> <span class="n">layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span> <span class="o">=</span> <span class="n">pytmx_tiled_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span>  <span class="c1"># the width of the tile that was hit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span>  <span class="c1"># the height of the tile that was hit</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_x</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the x position in the layer of the tile that was hit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_y</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the y position in the layer of the tile that was hit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the ID of the tile in the layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_props</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># the properties dict of the tile that was hit</span></div>


<div class="viewcode-block" id="TiledObjectGroup"><a class="viewcode-back" href="../spygame.html#spygame.TiledObjectGroup">[docs]</a><span class="k">class</span> <span class="nc">TiledObjectGroup</span><span class="p">(</span><span class="n">TmxLayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a wrapper class for the pytmx.TiledObjectGroup class, which represents an object layer in a tmx file</span>
<span class="sd">    - generates all GameObjects specified in the layer (a.g. the agent, enemies, etc..)</span>
<span class="sd">    - implements `render` by looping through all GameObjects and rendering their Sprites one by one</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pytmx_layer</span><span class="p">:</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledObjectGroup</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">:</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledMap</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">)</span>

        <span class="c1"># create the sprite group for this layer (all GameObjects will be added to this group)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_group</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Group</span><span class="p">()</span>

        <span class="c1"># add each object from the layer converted into a GameObject to this Stage under group: group.name</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="p">:</span>
            <span class="n">obj_props</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">properties</span>

            <span class="c1"># if the (Sprite) class of the object is given, construct it here using its c&#39;tor</span>
            <span class="c1"># - classes are given as strings: e.g. sypg.Sprite, vikings.Viking, Agent (Agent class would be in __main__ module)</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="c1">#print(&quot;found a sprite in the tiled-object-group: class={}&quot;.format(obj.type))</span>
                <span class="n">match_obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;^((.+)\.)?(\w+)$&#39;</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">match_obj</span><span class="p">,</span> <span class="s2">&quot;ERROR: type field (</span><span class="si">{}</span><span class="s2">) of object in pytmx.pytmx.TiledObjectGroup does not match pattern!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="p">)</span>
                <span class="n">_</span><span class="p">,</span> <span class="n">module_</span><span class="p">,</span> <span class="n">class_</span> <span class="o">=</span> <span class="n">match_obj</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s2">&quot;__main__&quot;</span><span class="p">)</span>  <span class="c1"># if no module given, assume a class defined in __main__</span>

                <span class="n">sheet_or_image</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">if</span> <span class="s2">&quot;tsx&quot;</span> <span class="ow">in</span> <span class="n">obj_props</span><span class="p">:</span>
                    <span class="n">sheet_or_image</span> <span class="o">=</span> <span class="n">SpriteSheet</span><span class="p">(</span><span class="s2">&quot;data/&quot;</span> <span class="o">+</span> <span class="n">obj_props</span><span class="p">[</span><span class="s2">&quot;tsx&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.tsx&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="s2">&quot;img&quot;</span> <span class="ow">in</span> <span class="n">obj_props</span><span class="p">:</span>
                    <span class="n">sheet_or_image</span> <span class="o">=</span> <span class="s2">&quot;images/&quot;</span> <span class="o">+</span> <span class="n">obj_props</span><span class="p">[</span><span class="s2">&quot;img&quot;</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span>

                <span class="c1"># get other kwargs for the Sprite&#39;s c&#39;tor</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="s2">&quot;kwargs&quot;</span> <span class="ow">in</span> <span class="n">obj_props</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">kwarg</span> <span class="ow">in</span> <span class="n">obj_props</span><span class="p">[</span><span class="s2">&quot;kwargs&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">):</span>
                        <span class="n">match_obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;^(\w+)=(.+)$&#39;</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">)</span>
                        <span class="k">assert</span> <span class="n">match_obj</span><span class="p">,</span> <span class="s2">&quot;ERROR: kwarg </span><span class="si">{}</span><span class="s2"> of object </span><span class="si">{}</span><span class="s2"> in pytmx.pytmx.TiledObjectGroup does not match pattern!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_</span><span class="p">,</span> <span class="n">kwarg</span><span class="p">)</span>
                        <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="o">=</span> <span class="n">match_obj</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
                        <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

                <span class="c1"># generate the Sprite</span>
                <span class="n">sprite</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_</span><span class="p">],</span> <span class="n">class_</span><span class="p">)(</span><span class="n">obj</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">sheet_or_image</span><span class="p">)</span>
                <span class="c1"># add the do_render and render_order to the new instance</span>
                <span class="n">sprite</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;do_render&quot;</span><span class="p">,</span> <span class="s2">&quot;false&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
                    <span class="n">sprite</span><span class="o">.</span><span class="n">render_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">obj_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;render_order&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sprite_group</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>

<div class="viewcode-block" id="TiledObjectGroup.render"><a class="viewcode-back" href="../spygame.html#spygame.TiledObjectGroup.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="c1"># loop through each Sprite in the group and blit it to the Display&#39;s Surface</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite_group</span><span class="o">.</span><span class="n">sprites</span><span class="p">():</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">display</span><span class="p">)</span></div></div>
            <span class="c1"># display.surface.blit(sprite.image, dest=(sprite.rect.x + display.offsets[0], sprite.rect.y + display.offsets[1]))</span>


<div class="viewcode-block" id="Collision"><a class="viewcode-back" href="../spygame.html#spygame.Collision">[docs]</a><span class="k">class</span> <span class="nc">Collision</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a simple feature object that stores collision properties for collisions between two objects</span>
<span class="sd">    or between an object and a TiledTileLayer</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite1</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># hook into the first Sprite participating in this collision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite2</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># hook into the second Sprite participating in this collision (this could be a TileSprite)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if a collision happened (usually True)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># how much do we have to move sprite1 to separate the two Sprites? (always negative)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># abs(distance)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># x-component of the collision normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># y-component of the collision normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># (distance * normal_x, distance * normal_y)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># None, &#39;x&#39; or &#39;y&#39; (direction in which we measure the collision; the other direction is ignored)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># velocity direction component (e.g. direction==&#39;x&#39; veloc==5 -&gt; moving right, veloc==-10.4 -&gt; moving left)</span></div>


<div class="viewcode-block" id="PlatformerCollision"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerCollision">[docs]</a><span class="k">class</span> <span class="nc">PlatformerCollision</span><span class="p">(</span><span class="n">Collision</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a collision object that can be used by PlatformerPhysics to handle Collisions</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># the impulse of the collision on some mass (used for pushing heavy objects)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># whether this is a collision with a sloped TileSprite of a TiledTileLayer</span>
                            <span class="c1"># (will also be False if obj1 collides with the Tile&#39;s rect, but obj1 is still in air (slope))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope_y_pull</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># amount of y that Sprite has to move up (negative) or down (positive) because of the slope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 0=no slope, -1=down slope, 1 = up slope</span></div>


<div class="viewcode-block" id="Component"><a class="viewcode-back" href="../spygame.html#spygame.Component">[docs]</a><span class="k">class</span> <span class="nc">Component</span><span class="p">(</span><span class="n">GameObject</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a Component can be added to and removed from other GameObjects</span>
<span class="sd">    - use `extend` to make a Component&#39;s method be callable directly from the owning GameObject</span>

<span class="sd">    :param str name: the name of the component (the name can be used to retrieve any GameObject&#39;s components via the [GameObject].components dict)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to be set by Entity when this component gets added</span>

<div class="viewcode-block" id="Component.added"><a class="viewcode-back" href="../spygame.html#spygame.Component.added">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        gets called when the component is added to a GameObject</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Component.removed"><a class="viewcode-back" href="../spygame.html#spygame.Component.removed">[docs]</a>    <span class="k">def</span> <span class="nf">removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        gets called when the component is removed from a GameObject</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Component.extend"><a class="viewcode-back" href="../spygame.html#spygame.Component.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        extends the given method (has to take self as 1st param) onto the GameObject, so that this method can be called</span>
<span class="sd">        directly from the GameObject</span>

<span class="sd">        :param callable method: method, which to make callable from within the owning GameObject</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="s2">&quot;ERROR: need self.game_object in order to extend the method to that GameObject!&quot;</span>
        <span class="c1"># use the MethodType function to bind the play_animation function to only this object (not any other instances of the GameObject&#39;s class)</span>
        <span class="c1"># - the extended method will take two self&#39;s (0=Component, 1=GameObject), thus selfs should be called &#39;comp&#39; and &#39;game_object&#39; OR &#39;self&#39; and &#39;game_object&#39;</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="Brain"><a class="viewcode-back" href="../spygame.html#spygame.Brain">[docs]</a><span class="k">class</span> <span class="nc">HumanPlayerBrain</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a brain class that handles agent control (via the GameLoops keyboard registry)</span>
<span class="sd">    - sets self.commands each tick depending on keyboard input</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">commands</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">list</span><span class="p">,</span> <span class="kc">None</span><span class="p">]):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">commands</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">commands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commands</span> <span class="o">=</span> <span class="p">{</span><span class="n">command</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># our GameObject&#39;s Animation Component (if any); needed for animation flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animation_flags</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># a copy of the GameObject&#39;s current Animation flags (store copy here for performance reasons)</span>

<div class="viewcode-block" id="Brain.reset"><a class="viewcode-back" href="../spygame.html#spygame.Brain.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sets all commands to False (makes this HumanPlayerBrain inactive)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Brain.added"><a class="viewcode-back" href="../spygame.html#spygame.Brain.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># call our own tick method when event &quot;pre_tick&quot; is triggered on our GameObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;pre_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;tick&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># search for an Animation component</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;animation&quot;</span><span class="p">)</span></div>

    <span class="c1"># for now, just translate keyboard_inputs from GameLoop object into our commands</span>
<div class="viewcode-block" id="Brain.tick"><a class="viewcode-back" href="../spygame.html#spygame.Brain.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">:</span> <span class="n">GameLoop</span><span class="p">):</span>
        <span class="c1"># update current animation flags</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">animation_flags</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="o">.</span><span class="n">flags</span>
        <span class="c1"># current animation does not block: normal commands possible</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">animation_flags</span> <span class="o">&amp;</span> <span class="n">Animation</span><span class="o">.</span><span class="n">ANIM_DISABLES_CONTROL</span><span class="p">):</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">),</span> <span class="n">desc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">descriptions</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">desc</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1"># all commands are blocked right now -&gt; set everything to False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="Animation"><a class="viewcode-back" href="../spygame.html#spygame.Animation">[docs]</a><span class="k">class</span> <span class="nc">Animation</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="c1"># static animation-properties registry</span>
    <span class="c1"># - stores single animation records (these are NOT Animation objects, but simple dicts representing settings for single animation sequences)</span>
    <span class="n">animation_settings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># some flags</span>
    <span class="c1"># TODO: make these less Viking-dependent (implement similar &#39;type&#39;-registry as for Sprites&#39; collisions)</span>
    <span class="n">ANIM_NONE</span> <span class="o">=</span> <span class="mh">0x0</span>
    <span class="n">ANIM_SWING_SWORD</span> <span class="o">=</span> <span class="mh">0x1</span>
    <span class="n">ANIM_DISABLES_CONTROL</span> <span class="o">=</span> <span class="mh">0x2</span>
    <span class="n">ANIM_PROHIBITS_STAND</span> <span class="o">=</span> <span class="mh">0x4</span>  <span class="c1"># anims that should never be overwritten by &#39;stand&#39;(even though player might not x - move)</span>
    <span class="n">ANIM_BOW</span> <span class="o">=</span> <span class="mh">0x8</span>

<div class="viewcode-block" id="Animation.register_settings"><a class="viewcode-back" href="../spygame.html#spygame.Animation.register_settings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">register_settings</span><span class="p">(</span><span class="n">settings_name</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">register_events_on</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># we do not have this name registered yet</span>
        <span class="k">if</span> <span class="n">settings_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s2">&quot;default&quot;</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">,</span> <span class="s2">&quot;ERROR: no entry `default` in animation-settings. Each settings block needs a default animation name.&quot;</span>
            <span class="k">for</span> <span class="n">anim</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">anim</span> <span class="o">!=</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
                    <span class="n">defaults</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="n">anim</span><span class="p">],</span> <span class="p">{</span>
                        <span class="s2">&quot;rate&quot;</span>         <span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1"># the rate with which to play this animation in 1/s</span>
                        <span class="s2">&quot;frames&quot;</span>       <span class="p">:</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># the frames to play from our spritesheet (starts with 0)</span>
                        <span class="s2">&quot;priority&quot;</span>     <span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># which priority to use for next if next is given</span>
                        <span class="s2">&quot;flags&quot;</span>        <span class="p">:</span> <span class="n">Animation</span><span class="o">.</span><span class="n">ANIM_NONE</span><span class="p">,</span>
                        <span class="c1"># flags bitmap that determines the behavior of the animation (e.g. block controls during animation play, etc..)</span>
                        <span class="s2">&quot;loop&quot;</span>         <span class="p">:</span> <span class="kc">True</span><span class="p">,</span>  <span class="c1"># whether to loop the animation when done</span>
                        <span class="s2">&quot;next&quot;</span>         <span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># which animation to play next</span>
                        <span class="s2">&quot;next_priority&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>  <span class="c1"># which priority to use for next if next is given</span>
                        <span class="s2">&quot;trigger&quot;</span>      <span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># which events to trigger on the game_object that plays this animation</span>
                        <span class="s2">&quot;trigger_data&quot;</span> <span class="p">:</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># data to pass to the event handler if trigger is given</span>
                        <span class="s2">&quot;keys_status&quot;</span>  <span class="p">:</span> <span class="p">{},</span>  <span class="c1"># ??? can override DISABLE_MOVEMENT setting only for certain keys</span>
                    <span class="p">})</span>
            <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span><span class="p">[</span><span class="n">settings_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">register_events_on</span><span class="p">,</span> <span class="n">EventObject</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">((</span><span class="s2">&quot;anim.&quot;</span> <span class="o">+</span> <span class="n">anim</span><span class="p">,</span> <span class="s2">&quot;anim_loop.&quot;</span> <span class="o">+</span> <span class="n">anim</span><span class="p">,</span> <span class="s2">&quot;anim_end.&quot;</span> <span class="o">+</span> <span class="n">anim</span><span class="p">)</span> <span class="k">for</span> <span class="n">anim</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">))</span>
            <span class="n">register_events_on</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">)</span></div>

<div class="viewcode-block" id="Animation.get_settings"><a class="viewcode-back" href="../spygame.html#spygame.Animation.get_settings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_settings</span><span class="p">(</span><span class="n">spritesheet_name</span><span class="p">,</span> <span class="n">anim_setting</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">spritesheet_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span> <span class="ow">or</span> <span class="n">anim_setting</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span><span class="p">[</span><span class="n">spritesheet_name</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span><span class="p">[</span><span class="n">spritesheet_name</span><span class="p">][</span><span class="n">anim_setting</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animation</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># str: if set to something, we are playing this animation</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span>  <span class="c1"># default rate in s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># animation priority (takes the value of the highest priority animation that wants to be played simultaneously)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the current frame in the animation &#39;frames&#39; list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the current time after starting the animation in s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keys_status</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_rate</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># True: half the time we are blinking</span>

<div class="viewcode-block" id="Animation.added"><a class="viewcode-back" href="../spygame.html#spygame.Animation.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># make sure our GameObject is actually a Sprite</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">Sprite</span><span class="p">),</span> <span class="s2">&quot;ERROR: Component Animation can only be added to a Sprite object!&quot;</span>

        <span class="c1"># call our own tick method when event &quot;post_tick&quot; is triggered on our GameObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tick</span><span class="p">)</span>
        <span class="c1"># tell our GameObject that we might trigger some &quot;anim...&quot; events on it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;anim&quot;</span><span class="p">,</span> <span class="s2">&quot;anim_frame&quot;</span><span class="p">,</span> <span class="s2">&quot;anim_loop&quot;</span><span class="p">,</span> <span class="s2">&quot;anim_end&quot;</span><span class="p">)</span>

        <span class="c1"># extend some methods directly onto the GameObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">play_animation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blink_animation</span><span class="p">)</span></div>

<div class="viewcode-block" id="Animation.tick"><a class="viewcode-back" href="../spygame.html#spygame.Animation.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        gets called when the GameObject triggers a &quot;pre_tick&quot; event</span>

<span class="sd">        :param GameLoop game_loop: the GameLoop that&#39;s currently playing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>

        <span class="c1"># blink stuff?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">+=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
            <span class="c1"># blinking stops</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">blink_rate</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">frame</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># animation stuff?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">animation</span><span class="p">:</span>
            <span class="n">anim_settings</span> <span class="o">=</span> <span class="n">Animation</span><span class="o">.</span><span class="n">get_settings</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">animation</span><span class="p">)</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span>
            <span class="n">stepped</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_changed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">rate</span><span class="p">:</span>
                    <span class="n">stepped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">//</span> <span class="n">rate</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">-=</span> <span class="n">stepped</span> <span class="o">*</span> <span class="n">rate</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">+=</span> <span class="n">stepped</span>
            <span class="c1"># we are changing frames</span>
            <span class="k">if</span> <span class="n">stepped</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># there are no more frames</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">]):</span>
                    <span class="c1"># this animation ends</span>
                    <span class="k">if</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;loop&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim_end&quot;</span><span class="p">)</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim_end.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">animation</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;trigger&quot;</span><span class="p">]:</span>
                            <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;trigger&quot;</span><span class="p">],</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;trigger_data&quot;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">]:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">play_animation</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">],</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next_priority&quot;</span><span class="p">])</span>
                        <span class="k">return</span>
                    <span class="c1"># this animation loops</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim_loop&quot;</span><span class="p">)</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim_loop.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">animation</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">])</span>

                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim_frame&quot;</span><span class="p">)</span>

            <span class="c1"># assign the correct image to the `image` field of the GameObject (already correctly x/y-flipped)</span>
            <span class="c1"># hidden: no image</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="c1"># visible: some image</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">tiles_dict</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tiles</span>  <span class="c1"># no flipping</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>
                        <span class="n">tiles_dict</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tiles_flipped_xy</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">tiles_dict</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tiles_flipped_x</span>
                <span class="k">elif</span> <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>
                    <span class="n">tiles_dict</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tiles_flipped_y</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">tiles_dict</span><span class="p">[</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">][</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">)]]</span></div>

<div class="viewcode-block" id="Animation.play_animation"><a class="viewcode-back" href="../spygame.html#spygame.Animation.play_animation">[docs]</a>    <span class="k">def</span> <span class="nf">play_animation</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">game_object</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plays an animation on our GameObject</span>

<span class="sd">        :param GameObject game_object: the GameObject on which to play the animation; the animation has to be setup via register_settings with the name</span>
<span class="sd">          of the SpriteSheet of the GameObject</span>
<span class="sd">        :param str name: the name of the animation to play</span>
<span class="sd">        :param int priority: the priority with which to play this animation (if this method is called multiple times, it will pick the higher one)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">comp</span><span class="o">.</span><span class="n">animation</span> <span class="ow">and</span> <span class="n">priority</span> <span class="o">&gt;=</span> <span class="n">comp</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">animation</span> <span class="o">=</span> <span class="n">name</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">has_changed</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># start each animation from 0</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>

            <span class="c1"># look up animation in list</span>
            <span class="n">anim_settings</span> <span class="o">=</span> <span class="n">Animation</span><span class="o">.</span><span class="n">get_settings</span><span class="p">(</span><span class="n">game_object</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">comp</span><span class="o">.</span><span class="n">animation</span><span class="p">)</span>
            <span class="c1"># set flags to sprite&#39;s properties</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">]</span>
            <span class="n">comp</span><span class="o">.</span><span class="n">keys_status</span> <span class="o">=</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;keys_status&quot;</span><span class="p">]</span>

            <span class="n">game_object</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim&quot;</span><span class="p">)</span>
            <span class="n">game_object</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim.&quot;</span> <span class="o">+</span> <span class="n">comp</span><span class="o">.</span><span class="n">animation</span><span class="p">)</span></div>

<div class="viewcode-block" id="Animation.blink_animation"><a class="viewcode-back" href="../spygame.html#spygame.Animation.blink_animation">[docs]</a>    <span class="k">def</span> <span class="nf">blink_animation</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">game_object</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        blinks the GameObject with the given parameters</span>

<span class="sd">        :param GameObject game_object: our GameObject to which blinking is applied</span>
<span class="sd">        :param float rate: the rate with which to blink (in 1/s)</span>
<span class="sd">        :param float duration: the duration of the blinking (in s); after the duration, the blinking stops</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">comp</span><span class="o">.</span><span class="n">blink_rate</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="n">comp</span><span class="o">.</span><span class="n">blink_duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="n">comp</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">=</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="Dockable"><a class="viewcode-back" href="../spygame.html#spygame.Dockable">[docs]</a><span class="k">class</span> <span class="nc">Dockable</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a dockable component allows for other Sprites to dock to this Component&#39;s GameObject</span>
<span class="sd">    - other Sprites that are docked to us will be moved along with us</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DEFINITELY_DOCKED</span> <span class="o">=</span> <span class="mh">0x1</span>  <span class="c1"># this object is definitely docked to something right now</span>
    <span class="n">DEFINITELY_NOT_DOCKED</span> <span class="o">=</span> <span class="mh">0x2</span>  <span class="c1"># this object is definitely not docked to something right now</span>
    <span class="n">TO_BE_DETERMINED</span> <span class="o">=</span> <span class="mh">0x4</span>  <span class="c1"># the docking state of this object is currently being determined</span>
    <span class="n">PREVIOUSLY_DOCKED</span> <span class="o">=</span> <span class="mh">0x8</span>  <span class="c1"># if set, the object was docked to something in the previous frame</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str name: the name of the Component</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docked_sprites</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dictionary that holds all Sprites (key=GameObject&#39;s id) currently docked to this one</span>
        <span class="c1"># holds the objects that we stand on and stood on previously:</span>
        <span class="c1"># slot 0=current state; slot 1=previous state (sometimes we need the previous state since the current state gets reset to 0 every step)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the reference to the object that we are currently docked to</span>

<div class="viewcode-block" id="Dockable.added"><a class="viewcode-back" href="../spygame.html#spygame.Dockable.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># make sure our GameObject is a Sprite</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">Sprite</span><span class="p">),</span> <span class="s2">&quot;ERROR: game_object of Component Dockable must be of type Sprite (not </span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span> \
            <span class="nb">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="c1"># extend our GameObject with move</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dockable.move"><a class="viewcode-back" href="../spygame.html#spygame.Dockable.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">precheck</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this will &#39;overwrite&#39; the normal Sprite&#39;s `move` method by Component&#39;s extend</span>
<span class="sd">        - if precheck is set to True: pre-checks the planned move via call to stage.locate and only moves entity as far as possible</span>

<span class="sd">        :param Sprite sprite: the GameObject that this Component belongs to (the Sprite to move around)</span>
<span class="sd">        :param int x: the amount in pixels to move in x-direction</span>
<span class="sd">        :param int y: the amount in pixels to move in y-direction</span>
<span class="sd">        :param bool precheck: ???</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#if precheck:</span>
        <span class="c1">#    testcol = self.stage.locate(p.x+x, p.y+y, Q._SPRITE_DEFAULT, p.w, p.h);</span>
        <span class="c1">#    if ((!testcol) || (testcol.tileprops &amp;&amp; testcol.tileprops[&#39;liquid&#39;])) {</span>
        <span class="c1">#        return True</span>
        <span class="c1">#</span>
        <span class="c1">#    return False</span>

        <span class="c1"># do a minimum of 1 pix (if larger 0.0)</span>
        <span class="k">if</span> <span class="n">x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">y</span>

        <span class="c1"># TODO: move the obj_to_follow into collide of stage (stage knows its borders best, then we don&#39;t need to define xmax/xmin, etc.. anymore)</span>
        <span class="c1"># TODO: maybe we could even build a default collision-frame around every stage when inserting the collision layer</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        if sprite.rect.x &lt; self.x_min:</span>
<span class="sd">            sprite.rect.x = self.x_min</span>
<span class="sd">            self.vx = 0</span>
<span class="sd">        elif sprite.rect.x &gt; self.x_max:</span>
<span class="sd">            sprite.rect.x = self.x_max</span>
<span class="sd">            self.vx = 0</span>
<span class="sd">        if sprite.rect.y &lt; self.y_min:</span>
<span class="sd">            sprite.rect.y = self.y_min</span>
<span class="sd">            self.vy = 0</span>
<span class="sd">        elif sprite.rect.y &gt; self.y_max:</span>
<span class="sd">            sprite.rect.y = self.y_max</span>
<span class="sd">            self.vy = 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># move all our docked Sprites along with us</span>
        <span class="k">for</span> <span class="n">docked_sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docked_sprites</span><span class="p">:</span>
            <span class="n">docked_sprite</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dockable.dock_to"><a class="viewcode-back" href="../spygame.html#spygame.Dockable.dock_to">[docs]</a>    <span class="k">def</span> <span class="nf">dock_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mother_ship</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a sprite lands on an elevator -&gt; couple the elevator to the sprite so that when the elevator moves, the sprite moves along with it</span>
<span class="sd">        - only possible to dock to &quot;default&quot; objects</span>

<span class="sd">        :param Sprite mother_ship: the Sprite to dock to (Sprite needs to have a dockable component)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="k">if</span> <span class="n">mother_ship</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">DEFINITELY_DOCKED</span>
            <span class="k">if</span> <span class="n">prev</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">|=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">PREVIOUSLY_DOCKED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span> <span class="o">=</span> <span class="n">mother_ship</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">mother_ship</span><span class="p">,</span> <span class="s2">&quot;docked_objects&quot;</span><span class="p">):</span>
                <span class="n">mother_ship</span><span class="o">.</span><span class="n">docked_objects</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Dockable.undock"><a class="viewcode-back" href="../spygame.html#spygame.Dockable.undock">[docs]</a>    <span class="k">def</span> <span class="nf">undock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        undocks itself from the mothership</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">DEFINITELY_NOT_DOCKED</span>
        <span class="k">if</span> <span class="n">prev</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">|=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">PREVIOUSLY_DOCKED</span>
        <span class="c1"># remove docked obj from mothership docked-obj-list</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span> <span class="ow">and</span> <span class="s2">&quot;dockable&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="k">del</span> <span class="n">prev</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">docked_sprites</span><span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">id</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Dockable.to_determine"><a class="viewcode-back" href="../spygame.html#spygame.Dockable.to_determine">[docs]</a>    <span class="k">def</span> <span class="nf">to_determine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        changes our docking state to be undetermined (saves the current state as PREVIOUS flag)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">TO_BE_DETERMINED</span>
        <span class="k">if</span> <span class="n">prev</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">|=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">PREVIOUSLY_DOCKED</span></div>

<div class="viewcode-block" id="Dockable.is_docked"><a class="viewcode-back" href="../spygame.html#spygame.Dockable.is_docked">[docs]</a>    <span class="k">def</span> <span class="nf">is_docked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns True if the current state is definitely docked OR (to-be-determined AND previous state was docked)</span>

<span class="sd">        :return: most-likely docking state</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">&amp;</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">DEFINITELY_DOCKED</span> <span class="ow">or</span> \
               <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">&amp;</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">TO_BE_DETERMINED</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">&amp;</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">PREVIOUSLY_DOCKED</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PhysicsComponent"><a class="viewcode-back" href="../spygame.html#spygame.PhysicsComponent">[docs]</a><span class="k">class</span> <span class="nc">PhysicsComponent</span><span class="p">(</span><span class="n">Component</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    defines an abstract generic physics component that can be added to agents (or enemies) to behave in the world</span>
<span class="sd">    - GameObject&#39;s that own this Comonent may have a HumanPlayerBrain component as well in order to steer behavior of the agent in `tick`</span>
<span class="sd">    - needs to override `tick` and `collision`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the GameObject&#39;s HumanPlayerBrain component (used by Physics for steering and action control within `tick` method)</span>

    <span class="c1"># probably needs to be extended further by child classes</span>
<div class="viewcode-block" id="PhysicsComponent.added"><a class="viewcode-back" href="../spygame.html#spygame.PhysicsComponent.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;pre_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;tick&quot;</span><span class="p">)</span>  <span class="c1"># run this component&#39;s tick function after GameObject&#39;s one (so we can react to the GameObject&#39;s move)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;collision&quot;</span><span class="p">)</span>  <span class="c1"># handle collisions</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;brain&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># if there is a &#39;brain&#39; component in the GameObject it has to be of type HumanPlayerBrain</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">,</span> <span class="n">HumanPlayerBrain</span><span class="p">),</span> <span class="s2">&quot;ERROR: GameObject&#39;s `brain` Component is not of type HumanPlayerBrain!&quot;</span></div>

    <span class="c1"># may determine x/y-speeds and movements of the GameObject (gravity, etc..)</span>
<div class="viewcode-block" id="PhysicsComponent.tick"><a class="viewcode-back" href="../spygame.html#spygame.PhysicsComponent.tick">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">:</span> <span class="n">GameLoop</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="PhysicsComponent.collision"><a class="viewcode-back" href="../spygame.html#spygame.PhysicsComponent.collision">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this is the resolver for a Collision that happened between two Sprites under this PhysicsComponent</span>

<span class="sd">        :param Collision col: the Collision object describing the collision that already happened between two sprites</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="PhysicsComponent.tile_layer_physics_collision_postprocessor"><a class="viewcode-back" href="../spygame.html#spygame.PhysicsComponent.tile_layer_physics_collision_postprocessor">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">tile_layer_physics_collision_postprocessor</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        determines what a Layer should do once it detects a collision via its `collide` method</span>

<span class="sd">        :param Collision col: the collision object detected by the Layer</span>
<span class="sd">        :return: the same Collision (maybe processed)</span>
<span class="sd">        :rtype: Collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># by default, just set collided to True and return the collision as is</span>
        <span class="c1"># - specific Physics behavior will have to be implemented by the different physics Components</span>
        <span class="n">col</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">col</span></div></div>


<div class="viewcode-block" id="TopDownPhysics"><a class="viewcode-back" href="../spygame.html#spygame.TopDownPhysics">[docs]</a><span class="k">class</span> <span class="nc">TopDownPhysics</span><span class="p">(</span><span class="n">PhysicsComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    defines &quot;top-down-2D&quot;-step physics (agent can move in any of the 4 directions using any step-size (smooth walking))</span>
<span class="sd">    - to be addable to any character (player or enemy)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># velocities/physics stuff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span> <span class="o">=</span> <span class="mi">300</span>  <span class="c1"># running acceleration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span> <span class="o">=</span> <span class="mi">150</span>  <span class="c1"># max run-speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Vikings stop abruptly when running in one direction, then the other direction is pressed</span>

        <span class="c1"># environment stuff (TODO: where to get Level dimensions from?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the minimum/maximum allowed positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="mi">9000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="mi">9000</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">touching</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># bitmap with those bits set that the entity is currently touching (colliding with)</span>
        <span class="c1"># TODO: what does at_exit mean in terms of an MDP/RL-setting?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the GameObject&#39;s HumanPlayerBrain component (used by Physics for steering and action control)</span>

<div class="viewcode-block" id="TopDownPhysics.added"><a class="viewcode-back" href="../spygame.html#spygame.TopDownPhysics.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">-=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">-=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;pre_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;tick&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># run this component&#39;s tick function after GameObject&#39;s one (so we can react to the GameObject&#39;s move)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># handle collisions</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;bump.top&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.bottom&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.left&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.right&quot;</span><span class="p">)</span>  <span class="c1"># we will trigger these as well -&gt; register them</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;brain&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">,</span> <span class="n">HumanPlayerBrain</span><span class="p">),</span> <span class="s2">&quot;ERROR: GameObject&#39;s `brain` Component is not of type HumanPlayerBrain!&quot;</span></div>

    <span class="c1"># determines x/y-speeds and moves the GameObject</span>
<div class="viewcode-block" id="TopDownPhysics.tick"><a class="viewcode-back" href="../spygame.html#spygame.TopDownPhysics.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">:</span> <span class="n">GameLoop</span><span class="p">):</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">dt_step</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ay</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">stage</span>

        <span class="c1"># entity has a brain component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">:</span>
            <span class="c1"># determine x speed</span>
            <span class="c1"># -----------------</span>
            <span class="c1"># user is trying to move left or right (or both?)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]:</span>
                <span class="c1"># only left is pressed</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span>  <span class="c1"># accelerate left</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># mirror sprite</span>
                <span class="c1"># user presses both keys (left and right) -&gt; just stop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># only right is pressed</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span>  <span class="c1"># accelerate right</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># stop immediately (vx=0; don&#39;t accelerate negatively)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># determine y speed</span>
            <span class="c1"># -----------------</span>
            <span class="c1"># user is trying to move up or down (or both?)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">]:</span>
                <span class="c1"># only up is pressed</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                    <span class="n">ay</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span>  <span class="c1"># accelerate up</span>
                <span class="c1"># user presses both keys (up and down) -&gt; just stop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># only down is pressed</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                <span class="n">ay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span>  <span class="c1"># accelerate down</span>
            <span class="c1"># stop immediately (vy=0; don&#39;t accelerate negatively)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># entity has no steering unit (speed = 0)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># TODO: check the entity&#39;s magnitude of vx and vy,</span>
        <span class="c1"># reduce the max dt_step if necessary to prevent skipping through objects.</span>
        <span class="k">while</span> <span class="n">dt_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">30</span><span class="p">,</span> <span class="n">dt_step</span><span class="p">)</span>

            <span class="c1"># update x/y-velocity based on acceleration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">+=</span> <span class="n">ax</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">v_max</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">+=</span> <span class="n">ay</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">v_max</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span>

            <span class="c1"># reset all touch flags before doing all the collision analysis</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># first move in x-direction and solve x-collisions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                    <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>

                <span class="c1"># then do the normal collision layer(s)</span>
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">tiled_layers_to_collide</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                        <span class="n">layer</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span>

            <span class="c1"># then move in y-direction and solve y-collisions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                    <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>

                <span class="c1"># then do the normal collision layer(s)</span>
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">tiled_layers_to_collide</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                        <span class="n">layer</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span>

            <span class="n">dt_step</span> <span class="o">-=</span> <span class="n">dt</span></div>

<div class="viewcode-block" id="TopDownPhysics.collision"><a class="viewcode-back" href="../spygame.html#spygame.TopDownPhysics.collision">[docs]</a>    <span class="k">def</span> <span class="nf">collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="n">Collision</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="k">assert</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span><span class="p">,</span> <span class="s2">&quot;ERROR: game_object (</span><span class="si">{}</span><span class="s2">) of physics component is not identical with passed in col.sprite1 (</span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;sprite2&quot;</span><span class="p">),</span> <span class="s2">&quot;ERROR: no sprite2 in col-object!&quot;</span>
        <span class="n">other_obj</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite2</span>

        <span class="c1"># collided with a tile (from a layer)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_obj</span><span class="p">,</span> <span class="n">TileSprite</span><span class="p">):</span>
            <span class="n">tile_props</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">tile_props</span>
            <span class="c1"># colliding with an exit</span>
            <span class="c1"># TODO: what does exit mean? in a RL setting? end of episode?</span>
            <span class="k">if</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;exit&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;reached_exit&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>  <span class="c1"># let the level know</span>
                <span class="k">return</span>

        <span class="c1"># move away from the collision (back to where we were before)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># bottom collision</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.bottom&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># top collision</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.top&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># left/right collisions</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">normal_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="c1"># we hit a fixed wall</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if normalX &lt; 0 -&gt; vx is &gt; 0 -&gt; set to 0; if normalX &gt; 0 -&gt; vx is &lt; 0 -&gt; set to 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;left&quot;</span><span class="p">),</span> <span class="n">col</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PlatformerPhysics"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerPhysics">[docs]</a><span class="k">class</span> <span class="nc">PlatformerPhysics</span><span class="p">(</span><span class="n">PhysicsComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    defines &quot;The Lost Vikings&quot;-like game physics</span>
<span class="sd">    - to be addable to any character (player or enemy)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># velocities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># physics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span> <span class="o">=</span> <span class="mi">300</span>  <span class="c1"># running acceleration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx_max</span> <span class="o">=</span> <span class="mi">150</span>  <span class="c1"># max run-speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_fall_speed</span> <span class="o">=</span> <span class="mi">550</span>  <span class="c1"># maximum fall speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># set to False to make this guy not be subject to y-gravity (e.g. while locked into ladder)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gravity_y</span> <span class="o">=</span> <span class="mf">9.8</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump_speed</span> <span class="o">=</span> <span class="mi">330</span>  <span class="c1"># jump-power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disable_jump</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># if True: disable jumping so we don&#39;t keep jumping when action1 key keeps being pressed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">can_jump</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># set to False to make this guy not be able to jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Vikings stop abruptly when running in one direction, then the other direction is pressed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">climb_speed</span> <span class="o">=</span> <span class="mi">70</span>  <span class="c1"># speed at which player can climb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_pushable</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># set to True if a collision with the entity causes the entity to move a little</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_heavy</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># set to True if this object should squeeze other objects that are below it and cannot move away</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">squeeze_speed</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># set to a value &gt; 0 to define the squeezeSpeed at which this object gets squeezed by heavy objects</span>
        <span class="c1"># (objects with is_heavy == True)</span>

        <span class="c1"># environment stuff (TODO: where to get Level dimensions from?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the minimum/maximum allowed positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="mi">9000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="mi">9000</span>

        <span class="c1"># self.touching = 0  # bitmap with those bits set that the entity is currently touching (colliding with)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">at_wall</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 1 if on up-slope, -1 if on down-slope</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># 0 if GameObject is not locked into a ladder; y-pos of obj, if obj is currently locked into a ladder (in climbing position)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># holds the ladder Sprite, if player is currently touching a ladder sprite, otherwise: 0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">climb_frame_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># int([climb_frame_value]) determines the frame to use to display climbing position</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the GameObject&#39;s HumanPlayerBrain component (used by Physics for steering and action control)</span>

<div class="viewcode-block" id="PlatformerPhysics.added"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerPhysics.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">-=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">-=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;pre_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;tick&quot;</span><span class="p">)</span>  <span class="c1"># run this component&#39;s tick function after GameObject&#39;s one (so we can react to the GameObject&#39;s move)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;collision&quot;</span><span class="p">)</span>  <span class="c1"># handle collisions</span>

        <span class="c1"># add the Dockable Component to our GameObject (we need it this for us to work properly)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">Dockable</span><span class="p">(</span><span class="s2">&quot;dockable&quot;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;brain&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">,</span> <span class="n">HumanPlayerBrain</span><span class="p">),</span> <span class="s2">&quot;ERROR: GameObject&#39;s `brain` Component is not of type HumanPlayerBrain!&quot;</span></div>

<div class="viewcode-block" id="PlatformerPhysics.lock_ladder"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerPhysics.lock_ladder">[docs]</a>    <span class="k">def</span> <span class="nf">lock_ladder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        locks the GameObject into a ladder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span>
        <span class="c1"># switch off gravity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># lock obj to center of ladder (which_ladder is always set to the one we are touching right now)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop x-movement</span></div>

<div class="viewcode-block" id="PlatformerPhysics.unlock_ladder"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerPhysics.unlock_ladder">[docs]</a>    <span class="k">def</span> <span class="nf">unlock_ladder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        frees the GameObject from a ladder</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="PlatformerPhysics.tick"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerPhysics.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">:</span> <span class="n">GameLoop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        determines x/y-speeds and moves the GameObject</span>

<span class="sd">        :param GameLoop game_loop: the GameLoop that&#39;s currently playing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">dt_step</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="n">dockable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">stage</span>

        <span class="c1"># entity has a brain component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">:</span>
            <span class="c1"># determine x speed</span>
            <span class="c1"># -----------------</span>
            <span class="c1"># user is trying to move left or right (or both?)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]:</span>
                <span class="c1"># only left is pressed</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span> <span class="ow">or</span> <span class="mi">999000000000</span><span class="p">)</span>  <span class="c1"># accelerate left</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># mirror sprite</span>

                    <span class="c1"># user is pressing left or right -&gt; leave on_ladder state</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
                <span class="c1"># user presses both keys (left and right) -&gt; just stop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># only right is pressed</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span> <span class="ow">or</span> <span class="mi">999000000000</span>  <span class="c1"># accelerate right</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># user is pressing left or right -&gt; leave on_ladder state</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
            <span class="c1"># stop immediately (vx=0; don&#39;t accelerate negatively)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ax = 0; // already initalized to 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># determine y speed</span>
            <span class="c1"># -----------------</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># user is pressing &#39;up&#39; (ladder?)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">]:</span>
                <span class="c1"># obj is currently on ladder</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># reached the top of the ladder -&gt; lock out of ladder</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span><span class="o">.</span><span class="n">ytop</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">climb_speed</span>
                <span class="c1"># player locks into ladder</span>
                <span class="k">elif</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="ow">and</span> \
                                  <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lock_ladder</span><span class="p">()</span>
            <span class="c1"># user is pressing only &#39;down&#39; (ladder?)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># we reached the bottom of the ladder -&gt; lock out of ladder</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
                    <span class="c1"># move down</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">climb_speed</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lock_ladder</span><span class="p">()</span>
            <span class="c1"># jumping?</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_jump</span><span class="p">:</span>
                <span class="n">jump</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;space&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">jump</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">disable_jump</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">disable_jump</span><span class="p">:</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">jump_speed</span>
                        <span class="n">dockable</span><span class="o">.</span><span class="n">undock</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">disable_jump</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># entity has no steering unit (x-speed = 0)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># TODO: check the entity&#39;s magnitude of vx and vy,</span>
        <span class="c1"># reduce the max dt_step if necessary to prevent skipping through objects.</span>
        <span class="k">while</span> <span class="n">dt_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">30</span><span class="p">,</span> <span class="n">dt_step</span><span class="p">)</span>

            <span class="c1"># update x/y-velocity based on acceleration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">+=</span> <span class="n">ax</span> <span class="o">*</span> <span class="n">dt</span>  <span class="c1"># TODO: x-gravity? + self.(p.gravityX == void 0 ? Q.gravityX : p.gravityX) * dt * p.gravity;</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx_max</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">vx_max</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx_max</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gravity_y</span> <span class="o">*</span> <span class="n">dt</span>

            <span class="c1"># if player stands on up-slope and x-speed is negative (or down-slope and x-speed is positive)</span>
            <span class="c1"># -&gt; make y-speed as high as x-speed so we don&#39;t fly off the slope</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">():</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_fall_speed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">max_fall_speed</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_fall_speed</span>

            <span class="c1"># reset all touch flags before doing all the collision analysis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">at_wall</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># store previous state before becoming undetermined</span>
                <span class="n">dockable</span><span class="o">.</span><span class="n">to_determine</span><span class="p">()</span>

            <span class="c1"># first move in x-direction and solve x-collisions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                    <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>

                <span class="c1"># then do the &#39;default&#39; collision layer(s)</span>
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">tiled_layers_to_collide</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                        <span class="n">layer</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span>

            <span class="c1"># then move in y-direction and solve y-collisions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                    <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>

                <span class="c1"># then do the &#39;default&#39; collision layer(s)</span>
                <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">tiled_layers_to_collide</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                        <span class="n">layer</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span>

            <span class="c1"># finally: check for touch collisions first (e.g. ladders)</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">tiled_layers_to_collide</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;touch&quot;</span><span class="p">):</span>
                    <span class="n">layer</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="c1"># TODO: solve collisions with other objects</span>

            <span class="n">dt_step</span> <span class="o">-=</span> <span class="n">dt</span></div>

<div class="viewcode-block" id="PlatformerPhysics.collision"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerPhysics.collision">[docs]</a>    <span class="k">def</span> <span class="nf">collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">:</span> <span class="n">PlatformerCollision</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        gets called (via event trigger &#39;collision&#39; (setup when this component is added to our GameObject)) when a collision is detected (e.g. by a layer)</span>

<span class="sd">        :param PlatformerCollision col: the collision object of the detected collision (the first sprite in that Collision object must be our GameObject)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="k">assert</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span><span class="p">,</span> <span class="s2">&quot;ERROR: game_object (</span><span class="si">{}</span><span class="s2">) of physics component is not identical with passed in col.sprite1 (</span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span><span class="p">)</span>
        <span class="n">dockable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;sprite2&quot;</span><span class="p">),</span> <span class="s2">&quot;ERROR: no sprite2 in col-object!&quot;</span>
        <span class="n">other_obj</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite2</span>
        <span class="n">other_obj_physics</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;physics&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># getting hit by a particle (Arrow, ScorpionShot, Fireball, etc..)</span>
        <span class="k">if</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;particle&quot;</span><span class="p">):</span>
            <span class="c1"># shooter (this) is colliding with own shot -&gt; ignore</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">shooter</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;hit.particle&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                <span class="c1"># for particles, force the reciprocal collisions (otherwise, the character that got shot could be gone (dead) before any collisions on the</span>
                <span class="c1"># particle could get triggered (-&gt; e.g. arrow will fly through a dying enemy without ever actually touching the enemy))</span>
                <span class="n">other_obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;hit&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># colliding with a ladder</span>
        <span class="k">if</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;ladder&quot;</span><span class="p">):</span>
            <span class="c1"># set which_ladder to the ladder</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">which_ladder</span> <span class="o">=</span> <span class="n">other_obj</span>
            <span class="c1"># if we are not locked into ladder AND on very top of the ladder, collide normally (don&#39;t fall through ladder&#39;s top)</span>
            <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">!=</span> <span class="mi">0</span>  <span class="c1"># don&#39;t x-collide with ladder</span>
                    <span class="ow">or</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>  <span class="c1"># don&#39;t collide with bottom of ladder</span>
                <span class="k">return</span>

        <span class="c1"># a collision layer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_obj</span><span class="p">,</span> <span class="n">TileSprite</span><span class="p">):</span>
            <span class="n">tile_props</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">tile_props</span>
            <span class="c1"># quicksand or water</span>
            <span class="k">if</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;liquid&quot;</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;hit.liquid_ground&quot;</span><span class="p">,</span> <span class="n">tile_props</span><span class="p">[</span><span class="s2">&quot;liquid&quot;</span><span class="p">])</span>
                <span class="k">return</span>
            <span class="c1"># colliding with an exit</span>
            <span class="k">elif</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;exit&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;reached_exit&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>  <span class="c1"># let the level know</span>
                <span class="k">return</span>
            <span class="c1"># check for slope collision (adjust y if necessary)</span>
            <span class="k">elif</span> <span class="n">col</span><span class="o">.</span><span class="n">slope</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">slope_y_pull</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>  <span class="c1"># TODO: check top whether we can move there (there could be a block)!!)) {</span>
                <span class="n">dockable</span><span class="o">.</span><span class="n">dock_to</span><span class="p">(</span><span class="n">other_obj</span><span class="p">)</span>  <span class="c1"># dock to collision layer (only if the pull )</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">slope_up_down</span>
                <span class="c1"># set vy to 0.0 (we are docked to the ground -&gt; if this is x-direction: no y-moves/checks necessary anymore)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">return</span>

        <span class="c1"># normal collision</span>
        <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">impact_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span>
        <span class="n">impact_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span>

        <span class="c1"># move away from the collision (back to where we were before)</span>
        <span class="n">x_orig</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y_orig</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">-=</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">-=</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># bottom collision</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">:</span>
            <span class="c1"># a heavy object hit the ground -&gt; rock the stage</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_heavy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span> <span class="ow">and</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">shake</span><span class="p">()</span>

            <span class="n">other_obj_dockable</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dockable&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># squeezing something</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_obj_physics</span><span class="p">,</span> <span class="n">PlatformerPhysics</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_heavy</span> <span class="ow">and</span> <span class="n">other_obj_physics</span><span class="o">.</span><span class="n">squeeze_speed</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
                    <span class="n">other_obj_dockable</span> <span class="ow">and</span> <span class="n">other_obj_dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">():</span>

                <span class="c1"># adjust the collision separation to the new squeezeSpeed</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="n">other_obj_physics</span><span class="o">.</span><span class="n">squeeze_speed</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y_orig</span> <span class="o">+</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">other_obj_physics</span><span class="o">.</span><span class="n">squeeze_speed</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span>
                <span class="c1"># otherwise, just undo the separation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="n">other_obj_physics</span><span class="o">.</span><span class="n">squeeze_speed</span>
                <span class="n">other_obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;squeezed.top&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

            <span class="c1"># normal bottom collision</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="n">impact_y</span>
                <span class="n">dockable</span><span class="o">.</span><span class="n">dock_to</span><span class="p">(</span><span class="n">other_obj</span><span class="p">)</span>  <span class="c1"># dock to bottom object (collision layer or MovableRock, etc..)</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.bottom&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># top collision</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="n">impact_y</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.top&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># left/right collisions</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">normal_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="n">impact_x</span>
            <span class="n">bump_wall</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># we hit a pushable object -&gt; check if it can move</span>
            <span class="k">if</span> <span class="n">other_obj_physics</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other_obj_physics</span><span class="p">,</span> <span class="s2">&quot;is_pushable&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other_obj_physics</span><span class="o">.</span><span class="n">is_pushable</span> <span class="ow">and</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">push_an_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                <span class="n">bump_wall</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># we hit a fixed wall (non-pushable)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if normalX &lt; 0 -&gt; p.vx is &gt; 0 -&gt; set to 0; if normalX &gt; 0 -&gt; p.vx is &lt; 0 -&gt; set to 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bump_wall</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">bump_wall</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">at_wall</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;left&quot;</span><span class="p">),</span> <span class="n">col</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlatformerPhysics.push_an_object"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerPhysics.push_an_object">[docs]</a>    <span class="k">def</span> <span class="nf">push_an_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pusher</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="n">pushee</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite2</span>  <span class="c1"># correct? or does it need to be sprite1?</span>
        <span class="c1"># TODO: what if normal_x is 1/-1 BUT: impact_x is 0 (yes, this can happen!!)</span>
        <span class="c1"># for now: don&#39;t push, then</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">move_x</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pushee</span><span class="o">.</span><span class="n">vx_max</span> <span class="o">/</span> <span class="n">col</span><span class="o">.</span><span class="n">impact</span><span class="p">)</span>
            <span class="c1"># console.log(&quot;pushing Object: move_x=&quot;+move_x);</span>
            <span class="c1"># do a locate on the other side of the - already moved - pushable object</span>
            <span class="c1"># var testcol = pusher.stage.locate(pushee_p.x+move_x+(pushee_p.cx+1)*(p.flip ==   &#39;x&#39; ? -1 : 1), pushee_p.y, (Q._SPRITE_DEFAULT | Q._SPRITE_FRIENDLY | Q._SPRITE_ENEMY));</span>
            <span class="c1"># if (testcol &amp;&amp; (! (testcol.tileprops &amp;&amp; testcol.tileprops.slope))) {</span>
            <span class="c1">#	p.vx = 0; // don&#39;t move player, don&#39;t move pushable object</span>
            <span class="c1"># }</span>
            <span class="c1"># else {</span>
            <span class="c1"># move obj (plus all its docked objects) and move pusher along</span>
            <span class="n">pusher</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">move_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">pushee</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">move_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="n">pushee</span><span class="o">.</span><span class="n">vx_max</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="PlatformerPhysics.tile_layer_physics_collision_postprocessor"><a class="viewcode-back" href="../spygame.html#spygame.PlatformerPhysics.tile_layer_physics_collision_postprocessor">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">tile_layer_physics_collision_postprocessor</span><span class="p">(</span><span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        this postprocessor takes a detected collision and does slope checks on it</span>
<span class="sd">        - it them stores the results in the given PlatformerCollision object for further handling by the physics Component</span>

<span class="sd">        :param PlatformerCollision col: the collision object detected by the Layer</span>
<span class="sd">        :return: a post-processed collision object (adds slope-related calculations to the Collision object)</span>
<span class="sd">        :rtype: PlatformerCollision</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">col</span><span class="o">.</span><span class="n">direction</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="s2">&quot;ERROR: col.direction must be either &#39;x&#39; or &#39;y&#39;!&quot;</span>

        <span class="n">sprite</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span>  <span class="c1"># this must have a dockable</span>
        <span class="k">assert</span> <span class="s2">&quot;dockable&quot;</span> <span class="ow">in</span> <span class="n">sprite</span><span class="o">.</span><span class="n">components</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sprite</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">],</span> <span class="n">Dockable</span><span class="p">),</span> \
            <span class="s2">&quot;ERROR: cannot postprocess collision without the sprite having a Dockable Component!&quot;</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite2</span>  <span class="c1"># this must be a TileSprite</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tile</span><span class="p">,</span> <span class="n">TileSprite</span><span class="p">),</span> <span class="s2">&quot;ERROR: sprite2 in PlatformerCollision passed to handler must be of type TileSprite (is actually of type </span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span>\
            <span class="nb">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">tile</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>

        <span class="c1"># check for slopes</span>
        <span class="c1"># approach similar to: Rodrigo Monteiro (http://higherorderfun.com/blog/2012/05/20/the-guide-to-implementing-2d-platformers/)</span>
        <span class="c1"># reset slope/collision flags</span>
        <span class="n">col</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">col</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">col</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">col</span><span class="o">.</span><span class="n">slope_y_pull</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># amount of y that Sprite has to move up (negative) or down (positive)</span>

        <span class="c1"># calculate y-pull based on pixels we are &quot;in&quot; the slope</span>
        <span class="c1"># TODO: for now: only treat 45-degree</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;slope&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># -3, -2, -1, 1, 2, 3: negative=down, positive=up (1==45 degree slope, 3=15 degree slope)</span>
        <span class="k">if</span> <span class="n">slope</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># calculate x-amount of intrusion by the sprite into the tile (this is always positive and between 0 and tile_w)</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                <span class="c1"># moving up hill</span>
                <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">slope</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x_in</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span>
                <span class="c1"># moving up hill</span>
                <span class="k">elif</span> <span class="n">col</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">&lt;</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="n">slope</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x_in</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span>
                <span class="c1"># moving down hill</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                        <span class="n">x_in</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">x_in</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span>
            <span class="c1"># y-direction (we are not moving left or right) -&gt; calc x_in depending on up or down slope</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">slope</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x_in</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">x_in</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span>

            <span class="c1"># clamp x_in to tile_w</span>
            <span class="n">x_in</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">x_in</span><span class="p">,</span> <span class="n">tile</span><span class="o">.</span><span class="n">tile_w</span><span class="p">)</span>

            <span class="c1"># the wanted y-position for the bottom of the sprite (iff we are docked to the ground)</span>
            <span class="n">y_grounded</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">x_in</span>
            <span class="n">slope_y_pull</span> <span class="o">=</span> <span class="n">y_grounded</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span>

            <span class="c1"># we are in the air -&gt; only apply y-pull if the y-pull is negative (up push)</span>
            <span class="c1"># - otherwise -&gt; keep falling (no collision)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sprite</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span> <span class="ow">and</span> <span class="n">slope_y_pull</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">col</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># this will cause the detected collision (with the tile rect) to be ignored for now</span>
            <span class="c1"># we are on the slope (not falling or having fallen into the slope already) -&gt; pull us up or down</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">col</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="n">slope</span>
                <span class="n">col</span><span class="o">.</span><span class="n">slope_up_down</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">slope</span><span class="p">)</span>
                <span class="n">col</span><span class="o">.</span><span class="n">slope_y_pull</span> <span class="o">=</span> <span class="n">y_grounded</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span>

        <span class="k">return</span> <span class="n">col</span></div></div>


<div class="viewcode-block" id="Viewport"><a class="viewcode-back" href="../spygame.html#spygame.Viewport">[docs]</a><span class="k">class</span> <span class="nc">Viewport</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A viewport is a component that can be added to a Stage to help that Stage render the scene depending on scrolling/obj_to_follow certain GameObjects</span>
<span class="sd">    - any GameObject with offset_x/y fields is supported, the Viewport will set these offsets to the Viewports x/y values</span>
<span class="sd">    before each render call</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">:</span> <span class="n">Display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param Display display: the Display object associated with this Viewport</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;viewport&quot;</span><span class="p">)</span>  <span class="c1"># fix name to &#39;viewport&#39; (only one viewport per Stage)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">display</span>  <span class="c1"># the pygame display (Surface) to draw on; so far we only need it to get the display&#39;s dimensions</span>

        <span class="c1"># top/left corner (world coordinates) of the Viewport window</span>
        <span class="c1"># - will be used as offset_x/y for the Display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># offsets used for shaking the Viewport</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">directions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Viewport.added"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">Stage</span><span class="p">),</span> <span class="s2">&quot;ERROR: can only add a Viewport Component to a Stage object, but GameObject is of type </span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span>\
            <span class="nb">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;pre_render&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;pre_render&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">follow_object_with_viewport</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unfollow_object_with_viewport</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_on_xy_with_viewport</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">move_to_xy_with_viewport</span><span class="p">)</span></div>

    <span class="c1"># EXTENSION methods (take self as well as GameObject as first two params)</span>

<div class="viewcode-block" id="Viewport.follow_object_with_viewport"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.follow_object_with_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">follow_object_with_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_object</span><span class="p">,</span> <span class="n">obj_to_follow</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounding_box</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_speed</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        makes the viewport follow a GameObject (obj_to_follow)</span>

<span class="sd">        :param GameObject game_object: our game_object (the Stage) that has `self` as component</span>
<span class="sd">        :param GameObject obj_to_follow: the GameObject that we should follow</span>
<span class="sd">        :param dict directions: dict with &#39;x&#39; and &#39;y&#39; set to either True or False depending on whether we follow only in x direction or y or both</span>
<span class="sd">        :param dict bounding_box: should contain min_x, max_x, min_y, max_y so we know the boundaries of the camera</span>
<span class="sd">        :param float max_speed: the max speed of the camera</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">game_object</span><span class="o">.</span><span class="n">off_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;follow&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directions</span><span class="p">:</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># this should be the level dimensions to avoid over-scrolling by the camera</span>
        <span class="c1"># - if we don&#39;t have a Level (just a Screen), use the display&#39;s size</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bounding_box</span><span class="p">:</span>  <span class="c1"># get a default bounding box</span>
            <span class="c1"># TODO: this is very specific to us having always a Stage (with options[&#39;screen_obj&#39;]) as our owning game_object</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">width</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span>
            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">height</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;min_x&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;min_y&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;max_x&quot;</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span> <span class="s2">&quot;max_y&quot;</span><span class="p">:</span> <span class="n">h</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">directions</span> <span class="o">=</span> <span class="n">directions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span> <span class="o">=</span> <span class="n">obj_to_follow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span> <span class="o">=</span> <span class="n">max_speed</span>
        <span class="n">game_object</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;follow&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">follow</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span> <span class="k">if</span> <span class="n">max_speed</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="kc">True</span><span class="p">))</span>  <span class="c1"># start following</span></div>

<div class="viewcode-block" id="Viewport.unfollow_object_with_viewport"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.unfollow_object_with_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">unfollow_object_with_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_object</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        stops following</span>

<span class="sd">        :param GameObject game_object: our game_object (the Stage) that has `self` as component</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">game_object</span><span class="o">.</span><span class="n">off_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;follow&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Viewport.center_on_xy_with_viewport"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.center_on_xy_with_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">center_on_xy_with_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_object</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        centers the Viewport on a given x/y position (so that the x/y position is in the center of the screen afterwards)</span>

<span class="sd">        :param GameObject game_object: our game_object (the Stage) that has `self` as component</span>
<span class="sd">        :param int x: the x position to center on</span>
<span class="sd">        :param int y: the y position to center on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_on</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Viewport.move_to_xy_with_viewport"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.move_to_xy_with_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">move_to_xy_with_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_object</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        moves the Viewport to the given x/y position (top-left corner, not center(!))</span>

<span class="sd">        :param GameObject game_object: our game_object (the Stage) that has `self` as component</span>
<span class="sd">        :param int x: the x position to move to</span>
<span class="sd">        :param int y: the y position to move to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

    <span class="c1"># END: EXTENSION METHODS</span>


    <span class="sd">&quot;&quot;&quot;shake: function() {</span>
<span class="sd">        setTimeout(function(vp) {vp.shakeY = 1;}, 30, this.viewport);</span>
<span class="sd">        setTimeout(function(vp) {vp.shakeY = -1;}, 60, this.viewport);</span>
<span class="sd">        setTimeout(function(vp) {vp.shakeY = 1;}, 90, this.viewport);</span>
<span class="sd">        setTimeout(function(vp) {vp.shakeY = -1;}, 120, this.viewport);</span>
<span class="sd">        setTimeout(function(vp) {vp.shakeY = 1;}, 150, this.viewport);</span>
<span class="sd">        setTimeout(function(vp) {vp.shakeY = -1;}, 180, this.viewport);</span>
<span class="sd">        setTimeout(function(vp) {vp.shakeY = 1;}, 210, this.viewport);</span>
<span class="sd">        setTimeout(function(vp) {vp.shakeY = 0;}, 240, this.viewport);</span>
<span class="sd">      },</span>
<span class="sd">    },</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Viewport.follow"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.follow">[docs]</a>    <span class="k">def</span> <span class="nf">follow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        helper method to follow our self.obj_to_follow (should not be called by the API user)</span>
<span class="sd">        - called when the Stage triggers Event &#39;post_tick&#39; (passes GameLoop into it which is not used)</span>

<span class="sd">        :param GameLoop game_loop: the GameLoop that&#39;s currently playing</span>
<span class="sd">        :param bool first: whether this is the very first call to this function (if so, do a hard center on, otherwise a soft-center-on)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">follow_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span> <span class="k">else</span>  <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
        <span class="n">follow_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">])</span> <span class="k">else</span>  <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_on</span> <span class="k">if</span> <span class="n">first</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">soft_center_on</span>
        <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">centerx</span> <span class="k">if</span> <span class="n">follow_x</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">centery</span> <span class="k">if</span> <span class="n">follow_y</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span></div>

    <span class="c1"># OBSOLETE: does not seem to be called</span>
    <span class="c1">#def offset(self, x, y):</span>
    <span class="c1">#    self.x = x</span>
    <span class="c1">#    self.y = y</span>

<div class="viewcode-block" id="Viewport.soft_center_on"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.soft_center_on">[docs]</a>    <span class="k">def</span> <span class="nf">soft_center_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        soft-centers on a given x/y position respecting the Viewport&#39;s max_speed property (unlike center_on)</span>

<span class="sd">        :param Union[int,None] x: the x position to center on (None if we should ignore the x position)</span>
<span class="sd">        :param Union[int,None] y: the y position to center on (None if we should ignore the y position)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>  <span class="c1"># //, this.followMaxSpeed);</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;min_x&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;min_x&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;max_x&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;max_x&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dx</span>

        <span class="k">if</span> <span class="n">y</span><span class="p">:</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span><span class="p">:</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;min_y&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;min_y&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;max_y&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;max_y&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">())</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">dy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">dy</span></div>

<div class="viewcode-block" id="Viewport.center_on"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.center_on">[docs]</a>    <span class="k">def</span> <span class="nf">center_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        centers on a given x/y position without(!) respecting the Viewport&#39;s max_speed property (unlike soft_center_on)</span>

<span class="sd">        :param Union[int,None] x: the x position to center on (None if we should ignore the x position)</span>
<span class="sd">        :param Union[int,None] y: the y position to center on (None if we should ignore the y position)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span></div>

<div class="viewcode-block" id="Viewport.move_to"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.move_to">[docs]</a>    <span class="k">def</span> <span class="nf">move_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        moves the Viewport to a given x/y position (top-left corner, not centering) without(!) respecting the Viewport&#39;s max_speed property</span>

<span class="sd">        :param Union[int,None] x: the x position to move to (None if we should ignore the x position)</span>
<span class="sd">        :param Union[int,None] y: the y position to move to (None if we should ignore the y position)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>  <span class="c1"># ?? why</span></div>

<div class="viewcode-block" id="Viewport.pre_render"><a class="viewcode-back" href="../spygame.html#spygame.Viewport.pre_render">[docs]</a>    <span class="k">def</span> <span class="nf">pre_render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">:</span> <span class="n">Display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sets the offset property of the given Display so that it matches our (previously) calculated x/y values</span>

<span class="sd">        :param Display display: the Display, whose offset we will change here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span></div></div>


<div class="viewcode-block" id="Screen"><a class="viewcode-back" href="../spygame.html#spygame.Screen">[docs]</a><span class="k">class</span> <span class="nc">Screen</span><span class="p">(</span><span class="n">EventObject</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a screen object has a play and a done method that need to be implemented</span>
<span class="sd">    - the play method stages a scene</span>
<span class="sd">    - the done method can do some cleanup</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># handle keyboard inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">,</span> <span class="n">KeyboardInputs</span><span class="p">([]))</span>
        <span class="c1"># our Display object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;display&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_fps&quot;</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>

<div class="viewcode-block" id="Screen.play"><a class="viewcode-back" href="../spygame.html#spygame.Screen.play">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Screen.done"><a class="viewcode-back" href="../spygame.html#spygame.Screen.done">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="SimpleScreen"><a class="viewcode-back" href="../spygame.html#spygame.SimpleScreen">[docs]</a><span class="k">class</span> <span class="nc">SimpleScreen</span><span class="p">(</span><span class="n">Screen</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a simple Screen that has support for labels and sprites (still images) shown on the screen</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sprites&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;sprites&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="p">[])</span>
        <span class="c1"># labels example: {x: Q.width / 2, y: 220, w: 150, label: &quot;NEW GAME&quot;, color: &quot;white&quot;, align: &quot;left&quot;, weight: &quot;900&quot;, size: 22, family: &quot;Fixedsys&quot;},</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="p">[])</span>
        <span class="c1">## TODO: audio? self.audio = kwargs[&quot;audio&quot;] if &quot;audio&quot; in kwargs else []</span>

<div class="viewcode-block" id="SimpleScreen.screen_func"><a class="viewcode-back" href="../spygame.html#spygame.SimpleScreen.screen_func">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">screen_func</span><span class="p">(</span><span class="n">stage</span><span class="p">:</span> <span class="n">Stage</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        defines this screen&#39;s Stage setup</span>
<span class="sd">        - stage functions are used to setup a Stage (before playing it)</span>

<span class="sd">        :param Stage stage: the Stage to be setup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the Screen object (instance) from the options</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="n">stage</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span>

        <span class="c1"># insert labels to screen</span>
        <span class="k">for</span> <span class="n">label_def</span> <span class="ow">in</span> <span class="n">screen</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="c1"># generate new Font object</span>
            <span class="n">font</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">Font</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>
            <span class="n">surf</span> <span class="o">=</span> <span class="n">font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]))</span>
            <span class="n">sprite</span> <span class="o">=</span> <span class="n">Sprite</span><span class="p">(</span><span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">surf</span><span class="p">)</span>
            <span class="n">stage</span><span class="o">.</span><span class="n">add_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="s2">&quot;labels&quot;</span><span class="p">)</span>

        <span class="c1"># insert objects to screen</span>
        <span class="k">for</span> <span class="n">game_obj</span> <span class="ow">in</span> <span class="n">screen</span><span class="o">.</span><span class="n">game_objects</span><span class="p">:</span>
            <span class="n">stage</span><span class="o">.</span><span class="n">add_sprite</span><span class="p">(</span><span class="n">game_obj</span><span class="p">,</span> <span class="s2">&quot;sprites&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleScreen.play"><a class="viewcode-back" href="../spygame.html#spygame.SimpleScreen.play">[docs]</a>    <span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        plays the screen</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># start screen (will overwrite the old 0-stage (=main-stage))</span>
        <span class="c1"># - also, will give our keyboard-input setup to the new GameLoop object</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">stage_screen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpleScreen</span><span class="o">.</span><span class="n">screen_func</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleScreen.done"><a class="viewcode-back" href="../spygame.html#spygame.SimpleScreen.done">[docs]</a>    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;we&#39;re done!&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Level"><a class="viewcode-back" href="../spygame.html#spygame.Level">[docs]</a><span class="k">class</span> <span class="nc">Level</span><span class="p">(</span><span class="n">Screen</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a level class</span>
<span class="sd">    - adds tmx file support to the Screen</span>
<span class="sd">    - we can get lots of information from the tmx file to build the level in the play method</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># TODO: warn here if keyboard_inputs is given (should be given in tmx file exclusively)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tmx_file</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tmx_file&quot;</span><span class="p">,</span> <span class="s2">&quot;data/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;.tmx&quot;</span><span class="p">)</span>
        <span class="c1"># load in the world&#39;s tmx file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span> <span class="o">=</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">load_pygame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmx_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">tilewidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">tileheight</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;mastered&quot;</span><span class="p">,</span> <span class="s2">&quot;aborted&quot;</span><span class="p">,</span> <span class="s2">&quot;lost&quot;</span><span class="p">)</span>

        <span class="c1"># get keyboard_inputs directly from the pytmx object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">:</span>
            <span class="n">descriptions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="c1">#codes_and_descriptions = []</span>
            <span class="c1">#for d in descriptions.split(&quot;,&quot;):</span>
            <span class="c1">#    pygame_code = getattr(pygame, &quot;K_&quot; + d.upper(), None)</span>
            <span class="c1">#    assert pygame_code, &quot;ERROR: in tmx file ({}) no pygame code associated with K_{}&quot;.format(self.tmx_file, d.upper())</span>
            <span class="c1">#    codes_and_descriptions.append([pygame_code, d])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">update_keys</span><span class="p">(</span><span class="n">descriptions</span><span class="p">)</span>

    <span class="c1"># populates a Stage with this Level by going through the tmx file layer by layer and adding it</span>
    <span class="c1"># - unlike SimpleScreen, uses only the tmx file for adding things to the Stage</span>
<div class="viewcode-block" id="Level.screen_func"><a class="viewcode-back" href="../spygame.html#spygame.Level.screen_func">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">screen_func</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        sets up the Stage by adding all layers (one-by-one) from the tmx file to the Stage</span>

<span class="sd">        :param Stage stage:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="n">Level</span><span class="p">),</span> <span class="s2">&quot;ERROR: screen property of a Stage that uses Level.screen_func to stage a Screen must be a Level object!&quot;</span>

        <span class="c1"># force add the default physics functions to the Stage&#39;s options</span>
        <span class="n">defaults</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;components&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">Viewport</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">display</span><span class="p">)],</span>
                                 <span class="s2">&quot;tile_layer_physics_collision_detector&quot;</span><span class="p">:</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">,</span>
                                 <span class="s2">&quot;tile_layer_physics_collision_postprocessor&quot;</span><span class="p">:</span> <span class="n">PhysicsComponent</span><span class="o">.</span><span class="n">tile_layer_physics_collision_postprocessor</span>
                                 <span class="p">})</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
            <span class="n">stage</span><span class="o">.</span><span class="n">add_tiled_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">tmx_obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="Level.play"><a class="viewcode-back" href="../spygame.html#spygame.Level.play">[docs]</a>    <span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        start level (stage the scene; will overwrite the old 0-stage (=main-stage))</span>
<span class="sd">        - the options-object below will be also stored in [Stage object].options</span>
<span class="sd">        - child Level classes only need to do these three things: a) stage a screen, b) register some possible events, c) play a new game loop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">stage_screen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen_func</span><span class="p">,</span> <span class="n">stage</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># activate level triggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;agent_reached_exit&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;done&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># play a new GameLoop giving it some options</span>
        <span class="n">GameLoop</span><span class="o">.</span><span class="n">play_a_loop</span><span class="p">(</span><span class="n">screen_obj</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Level.done"><a class="viewcode-back" href="../spygame.html#spygame.Level.done">[docs]</a>    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">get_stage</span><span class="p">()</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

        <span class="c1"># switch off keyboard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">update_keys</span><span class="p">([])</span>  <span class="c1"># empty list -&gt; no more keys</span></div></div>


<div class="viewcode-block" id="Game"><a class="viewcode-back" href="../spygame.html#spygame.Game">[docs]</a><span class="k">class</span> <span class="nc">Game</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">instantiated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object that serves as a container for Screen and Level objects</span>
<span class="sd">    - manages displaying the screens (start screen, menus, etc..) and playable levels of the game</span>
<span class="sd">    - also keeps a Display object (and determines its size), which is used for rendering and displaying the game</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">screens_and_levels</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;spygame Demo!&quot;</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">debug_flags</span><span class="o">=</span><span class="n">DEBUG_NONE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param list screens_and_levels: a list of Screen and Level definitions. Each item is a dict with</span>
<span class="sd">        :param int width: the width of the screen in pixels (0 for auto)</span>
<span class="sd">        :param int height: the height of the screen in pixels (0 for auto)</span>
<span class="sd">        :param str title: the title of the game (will be displayed as the game Window caption)</span>
<span class="sd">        :param int max_fps: the max. number of frames in one second (could be less if Game runs slow, but never more)</span>
<span class="sd">        :param int debug_flags: a bitmap for setting different debug flags (see global variables DEBUG_...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">Game</span><span class="o">.</span><span class="n">instantiated</span><span class="p">,</span> <span class="s2">&quot;ERROR: can only create one </span><span class="si">{}</span><span class="s2"> object!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">Game</span><span class="o">.</span><span class="n">instantiated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># init the pygame module (if this did not already happen)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">screens_by_name</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># holds the Screen objects by key=level-name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screens</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of screens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels_by_name</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># holds the Level objects by key=level-name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># sorted list of levels</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span> <span class="o">=</span> <span class="n">max_fps</span>

        <span class="c1"># try this: set debug flags globally</span>
        <span class="k">global</span> <span class="n">DEBUG_FLAGS</span>
        <span class="n">DEBUG_FLAGS</span> <span class="o">=</span> <span class="n">debug_flags</span>

        <span class="c1"># create the Display object for the entire game: we pass it to all levels and screen objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">Display</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>  <span class="c1"># use widthxheight for now (default); this will be reset to the largest Level dimensions further below</span>

        <span class="c1"># our levels (if any) determine the size of the display</span>
        <span class="n">get_w_from_levels</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">get_h_from_levels</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># initialize all screens and levels</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">screen_or_level</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">screens_and_levels</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;screen</span><span class="si">{:02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">id_</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">,</span> <span class="n">KeyboardInputs</span><span class="p">([]))</span>
            <span class="n">max_fps</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;max_fps&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span><span class="p">)</span>

            <span class="c1"># Screen class has to be given since Screen (as a default) would be abstract</span>
            <span class="k">assert</span> <span class="s2">&quot;class&quot;</span> <span class="ow">in</span> <span class="n">screen_or_level</span><span class="p">,</span> <span class="s2">&quot;ERROR: Game object needs the &#39;class&#39; property for all given Screens and Levels!&quot;</span>
            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">screen_or_level</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">],</span> <span class="n">Screen</span><span class="p">),</span> <span class="s2">&quot;ERROR: Game object needs the &#39;class&#39; property to be a subclass of Screen!&quot;</span>
            <span class="n">class_</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span>
            <span class="c1"># only distinguish between Level and &quot;regular&quot; Screen</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">class_</span><span class="p">,</span> <span class="n">Level</span><span class="p">):</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">class_</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">,</span> <span class="n">keyboard_inputs</span><span class="o">=</span><span class="n">keyboard_inputs</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="n">max_fps</span><span class="p">,</span> <span class="o">**</span><span class="n">screen_or_level</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels_by_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="c1"># register events</span>
                <span class="n">level</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;mastered&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;level_mastered&quot;</span><span class="p">)</span>
                <span class="n">level</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;aborted&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;level_aborted&quot;</span><span class="p">)</span>
                <span class="n">level</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;lost&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;level_lost&quot;</span><span class="p">)</span>
                <span class="c1"># store level dimensions for display</span>
                <span class="k">if</span> <span class="n">get_w_from_levels</span> <span class="ow">and</span> <span class="n">level</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">width</span><span class="p">:</span>
                    <span class="n">width</span> <span class="o">=</span> <span class="n">level</span><span class="o">.</span><span class="n">width</span>
                <span class="k">if</span> <span class="n">get_h_from_levels</span> <span class="ow">and</span> <span class="n">level</span><span class="o">.</span><span class="n">height</span> <span class="o">&gt;</span> <span class="n">height</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">level</span><span class="o">.</span><span class="n">height</span>
            <span class="c1"># a Screen</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">screen</span> <span class="o">=</span> <span class="n">class_</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">,</span> <span class="n">keyboard_inputs</span><span class="o">=</span><span class="n">keyboard_inputs</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="n">max_fps</span><span class="p">,</span> <span class="o">**</span><span class="n">screen_or_level</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">screens_by_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">screen</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">screens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">screen</span><span class="p">)</span>

        <span class="c1"># now that we know all Level sizes, change the dims of the pygame.display if width and/or height were Level-dependent</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">get_w_from_levels</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">get_h_from_levels</span> <span class="ow">and</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># static method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">change_dims</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

    <span class="c1"># returns the next level (if exists) as object</span>
    <span class="c1"># false if no next level</span>
<div class="viewcode-block" id="Game.get_next_level"><a class="viewcode-back" href="../spygame.html#spygame.Game.get_next_level">[docs]</a>    <span class="k">def</span> <span class="nf">get_next_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[(</span><span class="n">level</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">level</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">next_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">next_</span></div>

    <span class="c1"># a level has been successfully finished</span>
    <span class="c1"># load/play next one</span>
<div class="viewcode-block" id="Game.level_mastered"><a class="viewcode-back" href="../spygame.html#spygame.Game.level_mastered">[docs]</a>    <span class="k">def</span> <span class="nf">level_mastered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="n">next_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">next_</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;All done!! Congrats!!&quot;</span><span class="p">)</span></div>

    <span class="c1"># a level has been aborted</span>
<div class="viewcode-block" id="Game.level_aborted"><a class="viewcode-back" href="../spygame.html#spygame.Game.level_aborted">[docs]</a>    <span class="k">def</span> <span class="nf">level_aborted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">clear_stages</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screens_by_name</span><span class="p">[</span><span class="s2">&quot;start&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">play</span><span class="p">()</span></div>

    <span class="c1"># a level has been lost (all characters died)</span>
<div class="viewcode-block" id="Game.level_lost"><a class="viewcode-back" href="../spygame.html#spygame.Game.level_lost">[docs]</a>    <span class="k">def</span> <span class="nf">level_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level_aborted</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>  <span class="c1"># for now: same as aborted level</span></div></div>


<div class="viewcode-block" id="CollisionAlgorithm"><a class="viewcode-back" href="../spygame.html#spygame.CollisionAlgorithm">[docs]</a><span class="k">class</span> <span class="nc">CollisionAlgorithm</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a static class that is used to store a collision algorithm</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the default collision objects</span>
    <span class="c1"># - can be overridden via the collide method</span>
    <span class="n">default_collision_objects</span> <span class="o">=</span> <span class="p">(</span><span class="n">Collision</span><span class="p">(),</span> <span class="n">Collision</span><span class="p">())</span>

<div class="viewcode-block" id="CollisionAlgorithm.collide"><a class="viewcode-back" href="../spygame.html#spygame.CollisionAlgorithm.collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        solves a simple spatial collision problem for two Sprites (that have a rect property)</span>
<span class="sd">        - defaults to SAT collision between two objects</span>
<span class="sd">        - thanks to doc&#39;s at: http://www.sevenson.com.au/actionscript/sat/</span>
<span class="sd">        - TODO: handle angles on objects</span>
<span class="sd">        - TODO: handle velocities of sprites prior to collision to calculate correct normals</span>

<span class="sd">        :param Sprite sprite1: sprite 1</span>
<span class="sd">        :param Sprite sprite2: sprite 2 (the other sprite)</span>
<span class="sd">        :param Union[None,Tuple[Collision]] collision_objects: the two always-recycled returnable Collision instances (aside from None); if None,</span>
<span class="sd">            use our default ones</span>
<span class="sd">        :return: a Collision object with all details of the collision between the two Sprites (None if there is no collision)</span>
<span class="sd">        :rtype: Union[None,Collision]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="AABBCollision"><a class="viewcode-back" href="../spygame.html#spygame.AABBCollision">[docs]</a><span class="k">class</span> <span class="nc">AABBCollision</span><span class="p">(</span><span class="n">CollisionAlgorithm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a simple axis-aligned bounding-box collision mechanism which only works on Pygame rects</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AABBCollision.collide"><a class="viewcode-back" href="../spygame.html#spygame.AABBCollision.collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="c1"># TODO: actually, we only need one collision object as we should always only resolve one object at a time</span>

        <span class="c1"># TODO: utilize direction veloc information to only return the smallest separation collision</span>

        <span class="c1"># use default CollisionObjects?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">collision_objects</span><span class="p">:</span>
            <span class="n">collision_objects</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">default_collision_objects</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">try_collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">normal_x</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">normal_y</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AABBCollision.try_collide"><a class="viewcode-back" href="../spygame.html#spygame.AABBCollision.try_collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">try_collide</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">collision_obj</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        does the actual AABB collision test</span>

<span class="sd">        :param Sprite o1: object 1</span>
<span class="sd">        :param Sprite o2: object 2</span>
<span class="sd">        :param Collision collision_obj: the collision object to be populated</span>
<span class="sd">        :param str direction: the direction in which we have to measure a collision (x or y)</span>
<span class="sd">        :param float direction_veloc: the velocity value in the given x- or y-direction</span>
<span class="sd">        :return: the populated Collision object</span>
<span class="sd">        :rtype: Collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="ow">or</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s2">&quot;ERROR: parameter direction needs to be either &#39;x&#39; or &#39;y&#39;!&quot;</span>

        <span class="c1"># reset the recycled collision object</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">=</span> <span class="n">direction_veloc</span>

        <span class="c1"># overlap?</span>
        <span class="k">if</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="ow">and</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span><span class="p">:</span>
            <span class="n">collision_obj</span><span class="o">.</span><span class="n">sprite1</span> <span class="o">=</span> <span class="n">o1</span>
            <span class="n">collision_obj</span><span class="o">.</span><span class="n">sprite2</span> <span class="o">=</span> <span class="n">o2</span>
            <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction_veloc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="k">elif</span> <span class="n">direction_veloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction_veloc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="k">elif</span> <span class="n">direction_veloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># if flip:</span>
            <span class="c1">#    collision_obj.distance *= -1</span>
            <span class="c1">#    collision_obj.normal_x *= -1</span>
            <span class="n">collision_obj</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>

            <span class="c1">## take the smaller direction (x/y)</span>
            <span class="c1"># dist = -(o1.rect.bottom - o2.rect.top)</span>
            <span class="c1"># y_magnitude = abs(dist)</span>
            <span class="c1"># if y_magnitude &lt; collision_obj.magnitude:</span>
            <span class="c1">#    collision_obj.magnitude = y_magnitude</span>
            <span class="c1">#    collision_obj.distance = dist</span>
            <span class="c1">#    collision_obj.normal_x = 0.0</span>
            <span class="c1">#    collision_obj.normal_y = -1.0</span>
            <span class="c1">#    if flip:</span>
            <span class="c1">#        collision_obj.distance *= -1</span>
            <span class="c1">#        collision_obj.normal_y *= -1</span>

        <span class="c1"># collision_obj.separate = [collision_obj.distance * collision_obj.normal_x, collision_obj.distance * collision_obj.normal_y]</span>

        <span class="k">return</span> <span class="n">collision_obj</span> <span class="k">if</span> <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="k">else</span> <span class="kc">None</span></div></div>


<span class="c1"># TODO: SATCollisions are WIP</span>
<div class="viewcode-block" id="SATCollision"><a class="viewcode-back" href="../spygame.html#spygame.SATCollision">[docs]</a><span class="k">class</span> <span class="nc">SATCollision</span><span class="p">(</span><span class="n">CollisionAlgorithm</span><span class="p">):</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

<div class="viewcode-block" id="SATCollision.collide"><a class="viewcode-back" href="../spygame.html#spygame.SATCollision.collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># use default CollisionObjects?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">collision_objects</span><span class="p">:</span>
            <span class="n">collision_objects</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">default_collision_objects</span>

        <span class="c1"># do AABB first for a likely early out</span>
        <span class="c1"># TODO: right now, we only have pygame.Rect anyway, so these are AABBs</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&lt;</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="ow">or</span>
                    <span class="n">sprite2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">test</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">try_collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">test</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">try_collide</span><span class="p">(</span><span class="n">sprite2</span><span class="p">,</span> <span class="n">sprite1</span><span class="p">,</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">&lt;</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span> <span class="k">else</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">normal_x</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">normal_y</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="SATCollision.calculate_normal"><a class="viewcode-back" href="../spygame.html#spygame.SATCollision.calculate_normal">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_normal</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">pt1</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">pt2</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">dist</span>
            <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="SATCollision.dot_product_against_normal"><a class="viewcode-back" href="../spygame.html#spygame.SATCollision.dot_product_against_normal">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dot_product_against_normal</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="SATCollision.try_collide"><a class="viewcode-back" href="../spygame.html#spygame.SATCollision.try_collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">try_collide</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">collision_obj</span><span class="p">,</span> <span class="n">flip</span><span class="p">):</span>
        <span class="n">shortest_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># the following only works for AABBs, we will have to change that once objects start rotating or being non-rects</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">],</span>
              <span class="p">[</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">],</span> <span class="p">[</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">]]</span>

        <span class="n">p2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">],</span>
              <span class="p">[</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">],</span> <span class="p">[</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">]]</span>

        <span class="c1"># loop through all axes of sprite1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)):</span>
            <span class="n">SATCollision</span><span class="o">.</span><span class="n">calculate_normal</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="n">min1</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">dot_product_against_normal</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max1</span> <span class="o">=</span> <span class="n">min1</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">dot_product_against_normal</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">min1</span><span class="p">:</span>
                    <span class="n">min1</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">max1</span><span class="p">:</span>
                    <span class="n">max1</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="n">min2</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">dot_product_against_normal</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max2</span> <span class="o">=</span> <span class="n">min2</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p2</span><span class="p">)):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">dot_product_against_normal</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">min2</span><span class="p">:</span>
                    <span class="n">min2</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">max2</span><span class="p">:</span>
                    <span class="n">max2</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="n">d1</span> <span class="o">=</span> <span class="n">min1</span> <span class="o">-</span> <span class="n">max2</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">min2</span> <span class="o">-</span> <span class="n">max1</span>

            <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">d2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">min_dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">max2</span> <span class="o">-</span> <span class="n">min1</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">flip</span><span class="p">:</span>
                <span class="n">min_dist</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">min_dist_abs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">min_dist_abs</span> <span class="o">&lt;</span> <span class="n">shortest_dist</span><span class="p">:</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">sprite1</span> <span class="o">=</span> <span class="n">o1</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">sprite2</span> <span class="o">=</span> <span class="n">o2</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">min_dist</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="n">min_dist_abs</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">shortest_dist</span> <span class="o">=</span> <span class="n">min_dist_abs</span>

        <span class="c1"># return the actual collision</span>
        <span class="k">return</span> <span class="n">collision_obj</span> <span class="k">if</span> <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="k">else</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="defaults"><a class="viewcode-back" href="../spygame.html#spygame.defaults">[docs]</a><span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">defaults_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    adds all key/value pairs from defaults_dict into dictionary, but only if dictionary doesn&#39;t have the key defined yet</span>

<span class="sd">    :param dict dictionary: the target dictionary</span>
<span class="sd">    :param dict defaults_dict: the source (default) dictionary to take the keys from (only if they are not defined in dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>  <span class="c1"># overwrite only if key is missing</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<span class="c1"># OBSOLETE: use</span>
<div class="viewcode-block" id="extend"><a class="viewcode-back" href="../spygame.html#spygame.extend">[docs]</a><span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">extend_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    extends the dictionary with extend_dict, thereby overwriting existing keys</span>

<span class="sd">    :param dict dictionary: the target dictionary</span>
<span class="sd">    :param dict extend_dict: the source (extension) dictionary to take the keys from (even if they are not defined in dictionary)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">extend_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># overwrite no matter what</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">spygame 0.1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, Sven Mika.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>