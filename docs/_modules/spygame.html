
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spygame &#8212; spygame 0.1a8 documentation</title>
    
    <link rel="stylesheet" href="../_static/spygame_sphinx.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '0.1a8',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
  </head>
  <body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">spygame 0.1a8 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" accesskey="U">Module code</a> &#187;</li> 
      </ul>
    </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spygame</h1><div class="highlight"><pre>
<span></span><span class="c1"># --------------------------------------------------------------</span>
<span class="c1">#</span>
<span class="c1"># spygame (pygame based 2D game engine for the openAI gym)</span>
<span class="c1">#</span>
<span class="c1"># created: 2017/04/04 in PyCharm</span>
<span class="c1"># (c) 2017 Sven Mika - ducandu GmbH</span>
<span class="c1">#</span>
<span class="c1"># --------------------------------------------------------------</span>

<span class="kn">from</span> <span class="nn">abc</span> <span class="k">import</span> <span class="n">ABCMeta</span><span class="p">,</span> <span class="n">abstractmethod</span>
<span class="kn">import</span> <span class="nn">xml.etree.ElementTree</span>
<span class="kn">import</span> <span class="nn">pygame</span>
<span class="kn">import</span> <span class="nn">os.path</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="k">import</span> <span class="n">chain</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="n">Union</span>
<span class="kn">import</span> <span class="nn">types</span>
<span class="kn">import</span> <span class="nn">pytmx</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">functools</span>

<span class="n">VERSION_</span> <span class="o">=</span> <span class="s1">&#39;0.1&#39;</span>
<span class="n">RELEASE_</span> <span class="o">=</span> <span class="s1">&#39;0.1a8&#39;</span>

<span class="c1"># some debug flags that we can set to switch on debug rendering, collision handling, etc..</span>
<span class="n">DEBUG_NONE</span> <span class="o">=</span> <span class="mh">0x0</span>  <span class="c1"># no debugging</span>
<span class="n">DEBUG_ALL</span> <span class="o">=</span> <span class="mh">0xffff</span>  <span class="c1"># full debugging</span>
<span class="c1"># will not render TiledTileLayers that are marked as &#39;do_render&#39;==true in the tmx files</span>
<span class="n">DEBUG_DONT_RENDER_TILED_TILE_LAYERS</span> <span class="o">=</span> <span class="mh">0x1</span>
<span class="c1"># will render all collision tiles (those layers that have a type) with a square frame and - when being considered - filled green</span>
<span class="n">DEBUG_RENDER_COLLISION_TILES</span> <span class="o">=</span> <span class="mh">0x2</span>
<span class="n">DEBUG_RENDER_COLLISION_TILES_COLOR_DEFAULT</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;red&quot;</span><span class="p">)</span>
<span class="n">DEBUG_RENDER_COLLISION_TILES_COLOR_OTHER</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;cyan&quot;</span><span class="p">)</span>
<span class="c1"># render the tiles currently under consideration for colliding with a sprite</span>
<span class="n">DEBUG_RENDER_ACTIVE_COLLISION_TILES</span> <span class="o">=</span> <span class="mh">0x4</span>
<span class="n">DEBUG_RENDER_ACTIVE_COLLISION_TILES_COLOR</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;green&quot;</span><span class="p">)</span>
<span class="n">DEBUG_RENDER_ACTIVE_COLLISION_TILES_COLOR_GREYED_OUT</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;grey&quot;</span><span class="p">)</span>
<span class="c1"># will render all Sprites (even those without an image (e.g. when blinking) with a rectangular frame representing the Sprite&#39;s .rect property</span>
<span class="n">DEBUG_RENDER_SPRITES_RECTS</span> <span class="o">=</span> <span class="mh">0x8</span>
<span class="n">DEBUG_RENDER_SPRITES_RECTS_COLOR</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;orange&quot;</span><span class="p">)</span>
<span class="c1"># will render every Sprite before the Sprite&#39;s tick method was called</span>
<span class="n">DEBUG_RENDER_SPRITES_BEFORE_EACH_TICK</span> <span class="o">=</span> <span class="mh">0x10</span>
<span class="n">DEBUG_RENDER_SPRITES_AFTER_EACH_TICK</span> <span class="o">=</span> <span class="mh">0x20</span>
<span class="c1"># will render every Sprite before the Sprite&#39;s collision detection algo runs</span>
<span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span> <span class="o">=</span> <span class="mh">0x40</span>

<span class="c1"># by default, no debugging (you can set this through a Game&#39;s c&#39;tor using the debug_flags kwarg)</span>
<span class="n">DEBUG_FLAGS</span> <span class="o">=</span> <span class="n">DEBUG_NONE</span>


<div class="viewcode-block" id="EventObject"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject">[docs]</a><span class="k">class</span> <span class="nc">EventObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An EventObject introduces event handling and most objects that occur in spygame games will inherit from this class.</span>
<span class="sd">    NOTE: spygame events are not(!) pygame events.</span>
<span class="sd">    EventObject can &#39;have&#39; some events, which are simple strings (the names of the events, e.g. &#39;hit&#39;, &#39;jump&#39;, &#39;collided&#39;, etc..).</span>
<span class="sd">    EventObject can trigger any event by their name.</span>
<span class="sd">    If an EventObject wants to trigger an event, this event must have been registered with the EventObject beforehand (will raise exception otherwise).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># - listeners keeps a list of callbacks indexed by event name for quick lookup</span>
        <span class="c1"># - a listener is an array of 2 elements: 0=target, 1=callback</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># keys=event names; values=list of 2 elements (0=target object, 1=callback method)</span>
        <span class="c1"># stores all valid event names; that way, we can check validity of event when subscribers subscribe to some event</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

<div class="viewcode-block" id="EventObject.register_event"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject.register_event">[docs]</a>    <span class="k">def</span> <span class="nf">register_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">events</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        registers a possible event (str) with this object; only registered events are allowed to be triggered later</span>

<span class="sd">        :param str events: the event (or events) that should be registered</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">event</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">event</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventObject.unregister_event"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject.unregister_event">[docs]</a>    <span class="k">def</span> <span class="nf">unregister_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">events</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes one or more events from this EventObject&#39;s event registry; unregistered events are no longer allowed to be triggered.</span>

<span class="sd">        :param str events: the event(s) that should be removed from the registry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">event</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventObject.unregister_events"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject.unregister_events">[docs]</a>    <span class="k">def</span> <span class="nf">unregister_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unregisters all events from this GameObject (see &#39;unregister_event&#39;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span></div>

<div class="viewcode-block" id="EventObject.check_event"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject.check_event">[docs]</a>    <span class="k">def</span> <span class="nf">check_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether the given event is in this EventObject&#39;s registry (raises exception if not).</span>

<span class="sd">        :param str event: the event to be checked</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># make sure the event is valid (registered)</span>
        <span class="k">if</span> <span class="n">event</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">valid_events</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: event &#39;</span><span class="si">{}</span><span class="s2">&#39; not valid in this EventObject (</span><span class="si">{}</span><span class="s2">); event has not been registered!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span></div>

<div class="viewcode-block" id="EventObject.on_event"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject.on_event">[docs]</a>    <span class="k">def</span> <span class="nf">on_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Binds a callback to an event on this EventObject.</span>
<span class="sd">        If you provide a `target` object, that object will add this event to it&#39;s list of binds, allowing it to automatically remove it when</span>
<span class="sd">        it is destroyed.</span>
<span class="sd">        From here on, if the event gets triggered, the callback will be called on the target object.</span>
<span class="sd">        Note: Only previously registered events may be triggered (we can register the event here by setting register=True).</span>

<span class="sd">        :param Union[str,List[str]] event: the name of the event to be bound to the callback (e.g. tick, got_hit, etc..)</span>
<span class="sd">        :param target (EventObject): The target object on which to call the callback (defaults to self if not given)</span>
<span class="sd">        :param callable callback: the bound method to call on target if the event gets triggered</span>
<span class="sd">        :param bool register: whether we should register this event right now (only registered events are allowed to be triggered later)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">register</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>  <span class="c1"># checks whether it&#39;s already registered</span>

        <span class="c1"># more than one event given</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">event</span><span class="p">)):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="n">event</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">target</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># handle the case where there is no target provided, swapping the target and callback parameters</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">target</span>
            <span class="n">target</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># if there&#39;s still no callback, default to the event name</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback</span><span class="p">:</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="n">event</span>

        <span class="c1"># handle case for callback that is a string, this will pull the callback from the target object or from this object</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">callback</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

        <span class="c1"># listener is an array of 2 elements: 0=target, 1=callback</span>
        <span class="k">if</span> <span class="n">event</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">target</span> <span class="ow">or</span> <span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">])</span>

        <span class="c1"># with a provided target, the events bound to the target, so we can erase these events if the target no longer exists</span>
        <span class="k">if</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="s2">&quot;binds&quot;</span><span class="p">):</span>
                <span class="n">target</span><span class="o">.</span><span class="n">event_binds</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">target</span><span class="o">.</span><span class="n">event_binds</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">callback</span><span class="p">])</span></div>

    <span class="c1"># TODO: good debugging: warn if a registered event doesn&#39;t get triggered for a long time?</span>
<div class="viewcode-block" id="EventObject.trigger_event"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject.trigger_event">[docs]</a>    <span class="k">def</span> <span class="nf">trigger_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Triggers an event and specifies the parameters to be passed to the bound event handlers (callbacks) as \*params.</span>

<span class="sd">        :param str event: the name of the event that should be triggered; note: this event name will have to be registered with the EventObject</span>
<span class="sd">            in order for the trigger to succeed</span>
<span class="sd">        :param any params: the parameters to be passed to the handler methods as \*args</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">check_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

        <span class="c1"># make sure there are any listeners for this specific event, if not, early out</span>
        <span class="k">if</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
            <span class="c1"># call each listener in the context of either the target passed into `on_event` ([0]) or the object itself</span>
            <span class="k">for</span> <span class="n">listener</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]:</span>
                <span class="n">listener</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="o">*</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventObject.off_event"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject.off_event">[docs]</a>    <span class="k">def</span> <span class="nf">off_event</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">callback</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unregister</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unbinds an event from a target/callback.</span>
<span class="sd">        Can be called with 1, 2, or 3 parameters, each of which unbinds a more specific listener.</span>

<span class="sd">        :param str event: the name of the event to unbind from the callback</span>
<span class="sd">        :param EventObject target: the target EventObject to unbind this event from (callback would be a member of this target)</span>
<span class="sd">        :param callable callback: the callback to unbind the event from</span>
<span class="sd">        :param bool unregister: whether we should unregister this event as well</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">unregister</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">unregister_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">check_event</span><span class="p">(</span><span class="n">event</span><span class="p">)</span>

        <span class="c1"># without a target, remove all the listeners</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">target</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;listeners&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
                <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># if the callback is a string, find a method of the same name on the target</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">callback</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">callback</span><span class="p">):</span>
                <span class="n">callback</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;listeners&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">event</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listeners</span><span class="p">[</span><span class="n">event</span><span class="p">]</span>
                <span class="c1"># loop from the end to the beginning, which allows us to remove elements without having to affect the loop</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">target</span><span class="p">:</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">callback</span> <span class="ow">or</span> <span class="n">callback</span> <span class="ow">is</span> <span class="n">l</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                            <span class="n">l</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="EventObject.debind_events"><a class="viewcode-back" href="../spygame_reference.html#spygame.EventObject.debind_events">[docs]</a>    <span class="k">def</span> <span class="nf">debind_events</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called to remove any listeners from this object.</span>
<span class="sd">        E.g. when this object is destroyed you&#39;ll want all the event listeners to be removed from this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;event_binds&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">source</span><span class="p">,</span> <span class="n">event</span><span class="p">,</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">event_binds</span><span class="p">:</span>
                <span class="n">source</span><span class="o">.</span><span class="n">off_event</span><span class="p">(</span><span class="n">event</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div></div>


<span class="c1"># can handle events as well as</span>
<div class="viewcode-block" id="State"><a class="viewcode-back" href="../spygame_reference.html#spygame.State">[docs]</a><span class="k">class</span> <span class="nc">State</span><span class="p">(</span><span class="n">EventObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple state class that serves as a dict with settable and gettable key/value pairs.</span>
<span class="sd">    Setting a new value will trigger &quot;changed&quot;+key events.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># sets a value in our dict and triggers a changed event</span>
<div class="viewcode-block" id="State.set"><a class="viewcode-back" href="../spygame_reference.html#spygame.State.set">[docs]</a>    <span class="k">def</span> <span class="nf">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">trigger_event</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># trigger an event that the value changed</span>
        <span class="k">if</span> <span class="n">trigger_event</span><span class="p">:</span>
            <span class="n">old</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span> <span class="k">else</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;changed.&quot;</span> <span class="o">+</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="c1"># set to new value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>

    <span class="c1"># retrieve a value from the dict</span>
<div class="viewcode-block" id="State.get"><a class="viewcode-back" href="../spygame_reference.html#spygame.State.get">[docs]</a>    <span class="k">def</span> <span class="nf">get</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">:</span>
            <span class="k">raise</span> <span class="p">(</span><span class="ne">Exception</span><span class="p">,</span> <span class="s2">&quot;ERROR: key </span><span class="si">{}</span><span class="s2"> not in dict!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span></div>

    <span class="c1"># decrease value by amount</span>
<div class="viewcode-block" id="State.dec"><a class="viewcode-back" href="../spygame_reference.html#spygame.State.dec">[docs]</a>    <span class="k">def</span> <span class="nf">dec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">-=</span> <span class="n">amount</span></div>

    <span class="c1"># increase value by amount</span>
<div class="viewcode-block" id="State.inc"><a class="viewcode-back" href="../spygame_reference.html#spygame.State.inc">[docs]</a>    <span class="k">def</span> <span class="nf">inc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">amount</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dict</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">+=</span> <span class="n">amount</span></div></div>


<div class="viewcode-block" id="KeyboardInputs"><a class="viewcode-back" href="../spygame_reference.html#spygame.KeyboardInputs">[docs]</a><span class="k">class</span> <span class="nc">KeyboardInputs</span><span class="p">(</span><span class="n">EventObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to handle keyboard inputs by the user playing the spygame game.</span>
<span class="sd">    A KeyboardInput object is passed to the GameLoop c&#39;tor, so that the GameLoop can `tick` the KeyboardInput object each frame.</span>
<span class="sd">    Single keys to watch out for can be registered via the `update_keys` method (not registered keys will be ignored).</span>
<span class="sd">    The tick method collects all keydown/keyup pygame events and stores the currently registered keys in the `keyboard_registry` as True (currently pressed)</span>
<span class="sd">    or False (currently not pressed).</span>
<span class="sd">    All keys are described by their pygame names (without the leading `K_`), e.g. pygame.K_UP=`up`, pygame.K_ESCAPE=`escape`, etc..</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param Union[list,None] key_list: the list of keys to be added right away to our keyboard_registry dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="c1"># stores the keys that we would like to be registered as important</span>
        <span class="c1"># - key: pygame keyboard code (e.g. pygame.K_ESCAPE, pygame.K_UP, etc..)</span>
        <span class="c1"># - value: True if currently pressed, False otherwise</span>
        <span class="c1"># - needs to be ticked in order to yield up-to-date information (this will be done by a GameLoop playing a Screen)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">key_list</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_keys</span><span class="p">(</span><span class="n">key_list</span><span class="p">)</span>

<div class="viewcode-block" id="KeyboardInputs.update_keys"><a class="viewcode-back" href="../spygame_reference.html#spygame.KeyboardInputs.update_keys">[docs]</a>    <span class="k">def</span> <span class="nf">update_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_key_list</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populates our registry and other dicts with the new key-list given (may be an empty list).</span>

<span class="sd">        :param Union[List,None] new_key_list: the new key list, where each item is the lower-case pygame keycode without the leading</span>
<span class="sd">            `K_` e.g. `up` for pygame.K_UP; use None for clearing out the registry (no keys assigned)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unregister_events</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="c1">#OBSOLETE: self.desc_to_key.clear()</span>
        <span class="k">if</span> <span class="n">new_key_list</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">desc</span> <span class="ow">in</span> <span class="n">new_key_list</span><span class="p">:</span>
                <span class="n">key</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">pygame</span><span class="p">,</span> <span class="s2">&quot;K_&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="n">desc</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">desc</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">desc</span>
                <span class="c1">#OBSOLETE: self.desc_to_key[desc] = key</span>
                <span class="c1"># signal that we might trigger the following events:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;key_down.&quot;</span> <span class="o">+</span> <span class="n">desc</span><span class="p">,</span> <span class="s2">&quot;key_up.&quot;</span> <span class="o">+</span> <span class="n">desc</span><span class="p">)</span></div>

<div class="viewcode-block" id="KeyboardInputs.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.KeyboardInputs.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pulls all keyboard events from the event queue and processes them according to our keyboard_registry/descriptions.</span>
<span class="sd">        Triggers events for all registered keys like: &#39;key_down.[desc]&#39; (when  pressed) and &#39;key_up.[desc]&#39; (when released),</span>
<span class="sd">        where desc is the lowercase string after `pygame.K_`... (e.g. &#39;down&#39;, &#39;up&#39;, etc..).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">([</span><span class="n">pygame</span><span class="o">.</span><span class="n">KEYDOWN</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">KEYUP</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="c1"># a key was pressed that we are interested in -&gt; set to True or False</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">KEYDOWN</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;key_down.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;key_up.&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">descriptions</span><span class="p">[</span><span class="n">e</span><span class="o">.</span><span class="n">key</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="GameObject"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameObject">[docs]</a><span class="k">class</span> <span class="nc">GameObject</span><span class="p">(</span><span class="n">EventObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A GameObject adds the capability to add one or more Component objects to the GameObject</span>
<span class="sd">    (e.g. animation, physics, etc..).</span>
<span class="sd">    Component objects are stored by their name in the GameObject.components dict.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># stores all GameObjects by a unique int ID</span>
    <span class="n">id_to_obj</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">next_id</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">components</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># dict of added components by component&#39;s name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_destroyed</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">GameObject</span><span class="o">.</span><span class="n">next_id</span>
        <span class="n">GameObject</span><span class="o">.</span><span class="n">id_to_obj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">GameObject</span><span class="o">.</span><span class="n">next_id</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="c1"># register events that need to trigger (later)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;destroyed&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="GameObject.add_component"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameObject.add_component">[docs]</a>    <span class="k">def</span> <span class="nf">add_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a component object to this GameObject -&gt; calls the component&#39;s added method.</span>

<span class="sd">        :param Component component: component to be added to GameObject under game_obj.components[component.name]</span>
<span class="sd">        :return: the same Component for chaining</span>
<span class="sd">        :rtype: Component</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">component</span><span class="o">.</span><span class="n">game_object</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">assert</span> <span class="n">component</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="s2">&quot;ERROR: component with name </span><span class="si">{}</span><span class="s2"> already exists in Entity!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">component</span>
        <span class="n">component</span><span class="o">.</span><span class="n">added</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">component</span></div>

<div class="viewcode-block" id="GameObject.remove_component"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameObject.remove_component">[docs]</a>    <span class="k">def</span> <span class="nf">remove_component</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">component</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes the given component from this GameObject.</span>

<span class="sd">        :param Component component: the Component object to be removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">component</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">,</span> <span class="s2">&quot;ERROR: component with name </span><span class="si">{}</span><span class="s2"> does no exist in Entity!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># call the removed handler (if implemented)</span>
        <span class="n">component</span><span class="o">.</span><span class="n">removed</span><span class="p">()</span>
        <span class="c1"># only then erase the component from the GameObject</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="n">component</span><span class="o">.</span><span class="n">name</span><span class="p">]</span></div>

<div class="viewcode-block" id="GameObject.destroy"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameObject.destroy">[docs]</a>    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Destroys the GameObject by calling debind and removing the object from it&#39;s parent.</span>
<span class="sd">        Will trigger a `destroyed` event (callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we are already dead -&gt; return</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_destroyed</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># debind events where we are the target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">debind_events</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_destroyed</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># tell everyone we are done</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;destroyed&quot;</span><span class="p">)</span>

        <span class="c1"># remove ourselves from the id_to_obj dict</span>
        <span class="k">del</span> <span class="n">GameObject</span><span class="o">.</span><span class="n">id_to_obj</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">id</span><span class="p">]</span></div>

<div class="viewcode-block" id="GameObject.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameObject.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A tick (coming from the GameObject containing Stage).</span>
<span class="sd">        Override this if you want your GameObject to do something each frame.</span>

<span class="sd">        :param GameLoop game_loop: the GameLoop that&#39;s currently playing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="SpriteSheet"><a class="viewcode-back" href="../spygame_reference.html#spygame.SpriteSheet">[docs]</a><span class="k">class</span> <span class="nc">SpriteSheet</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Represents a spritesheet loaded from a tsx file.</span>
<span class="sd">    Stores each single image (as pygame.Surface) in the sheet by its position.</span>
<span class="sd">    Allows for already doing flip transformations (x/y and/or both axes) so we save time during the game.</span>
<span class="sd">    Stores single tile properties in tile_props_by_id dict (only for those tiles that actually have custom properties defined in the tsx file).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">store_flips</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str file: the tsx file name to be loaded into this object</span>
<span class="sd">        :param dict store_flips: dictionary ({&quot;x&quot;: [True|False], &quot;y&quot;: [True|False]}) with the flip-options; None for default (only x)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">tree</span> <span class="o">=</span> <span class="n">xml</span><span class="o">.</span><span class="n">etree</span><span class="o">.</span><span class="n">ElementTree</span><span class="o">.</span><span class="n">parse</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: could not open tsx(xml) file: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>

        <span class="n">elem</span> <span class="o">=</span> <span class="n">tree</span><span class="o">.</span><span class="n">getroot</span><span class="p">()</span>
        <span class="n">props</span> <span class="o">=</span> <span class="n">elem</span><span class="o">.</span><span class="n">attrib</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">props</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tw</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;tilewidth&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">th</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;tileheight&quot;</span><span class="p">])</span>
        <span class="k">assert</span> <span class="s2">&quot;tilecount&quot;</span> <span class="ow">in</span> <span class="n">props</span><span class="p">,</span> <span class="s2">&quot;ERROR: no `tilecount` property in properties of tsx file: `</span><span class="si">{}</span><span class="s2">`!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">count</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;tilecount&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;columns&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the list of all Surfaces</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_x</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the list of all Surfaces (flipped on x-axis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_y</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the list of all Surfaces (flipped on y-axis)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_xy</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the list of all Surfaces (flipped on both axes)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tile_props_by_id</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># contains tile properties set in the tmx file for each tile by tile ID</span>

        <span class="c1"># by default, only flip on x-axis (usually that&#39;s enough for 2D games)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">store_flips</span><span class="p">:</span>
            <span class="n">store_flips</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>

        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">elem</span><span class="p">:</span>
            <span class="c1"># the image asset -&gt; load and save all Surfaces</span>
            <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;image&quot;</span><span class="p">:</span>
                <span class="n">props</span> <span class="o">=</span> <span class="n">child</span><span class="o">.</span><span class="n">attrib</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">w</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;width&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">h</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;height&quot;</span><span class="p">])</span>
                <span class="n">image_file</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">file</span><span class="p">)),</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">relpath</span><span class="p">(</span><span class="n">props</span><span class="p">[</span><span class="s2">&quot;source&quot;</span><span class="p">])))</span>
                <span class="c1"># image_file = os.path.normpath(os.path.join(os.path.dirname(os.path.abspath(file)), os.path.relpath(&quot;../images/debug.png&quot;)))</span>
                <span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">image_file</span><span class="p">)</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">()</span>
                <span class="n">col</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">tile</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">):</span>
                    <span class="n">col</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="k">if</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cols</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">row</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">surf</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">th</span><span class="p">),</span> <span class="n">flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">SRCALPHA</span><span class="p">)</span>
                    <span class="n">surf</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                              <span class="n">area</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">col</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="n">row</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">th</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">th</span><span class="p">))</span>  <span class="c1"># blits the correct frame of the image to this new surface</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tiles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf</span><span class="p">)</span>
                    <span class="c1"># do the necessary flippings (will save time later when rendering the Sprite)</span>
                    <span class="k">if</span> <span class="n">store_flips</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]:</span>
                        <span class="n">surf_x_flipped</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_x</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">surf_x_flipped</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">store_flips</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>  <span class="c1"># x and y</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_xy</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">surf_x_flipped</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">store_flips</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tiles_flipped_y</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">transform</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

            <span class="c1"># single tiles (and their properties)</span>
            <span class="k">elif</span> <span class="n">child</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;tile&quot;</span><span class="p">:</span>
                <span class="n">id_</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">child</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;id&quot;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tile_props_by_id</span><span class="p">[</span><span class="n">id_</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># create new dict for this tile</span>
                <span class="k">for</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">child</span><span class="p">:</span>
                    <span class="c1"># the expected properties tag</span>
                    <span class="k">if</span> <span class="n">tag</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;properties&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">tag</span><span class="p">:</span>
                            <span class="n">val</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;value&quot;</span><span class="p">]</span>
                            <span class="n">type_</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;type&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;type&quot;</span> <span class="ow">in</span> <span class="n">prop</span><span class="o">.</span><span class="n">attrib</span> <span class="k">else</span> <span class="kc">None</span>
                            <span class="k">if</span> <span class="n">type_</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
                                    <span class="n">val</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">val</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span> <span class="k">else</span> <span class="kc">False</span>
                                <span class="k">else</span><span class="p">:</span>
                                    <span class="n">val</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span> <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="k">else</span> <span class="n">val</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">tile_props_by_id</span><span class="p">[</span><span class="n">id_</span><span class="p">][</span><span class="n">prop</span><span class="o">.</span><span class="n">attrib</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">]]</span> <span class="o">=</span> <span class="n">val</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="p">(</span><span class="s2">&quot;ERROR: expected only &lt;properties&gt; tag within &lt;tile&gt; in tsx file </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">file</span><span class="p">))</span></div>


<div class="viewcode-block" id="Sprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.Sprite">[docs]</a><span class="k">class</span> <span class="nc">Sprite</span><span class="p">(</span><span class="n">GameObject</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Sprite can be added to a Stage; has a type and a collision mask for collision detection with other Sprites or TiledTileLayers also on the Stage.</span>
<span class="sd">    Sprite objects inherit from pygame.sprite.Sprite, so a Sprite has an image and a position/collision rect via rect property (pygame.rect).</span>
<span class="sd">    Each Sprite can have either a static image or hold a SpriteSheet object from which it can pull images for animation purposes; either way, the `image`</span>
<span class="sd">    property holds the current image.</span>
<span class="sd">    The image rect (property `image_rect`) can be different from the collision rect (property `rect`); usually one would want the collision rect to be</span>
<span class="sd">    a little smaller than the actual image.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># dict of Sprite types (by name) to bitmappable-int (1, 2, 4, 8, 16, etc..)</span>
    <span class="c1"># - this can be used to determine which Sprites collide with which other Sprites</span>
    <span class="n">types</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;none&quot;</span><span class="p">:</span>             <span class="mh">0x0</span><span class="p">,</span>  <span class="c1"># e.g. background Sprites (e.g. waterfalls)</span>
        <span class="s2">&quot;dockable&quot;</span><span class="p">:</span>         <span class="mh">0x1</span><span class="p">,</span>  <span class="c1"># if other objects would like to dock to this Sprite</span>
        <span class="s2">&quot;default&quot;</span><span class="p">:</span>          <span class="mh">0x2</span><span class="p">,</span>  <span class="c1"># e.g. collision layers (should normally also be dockable)</span>
        <span class="s2">&quot;one_way_platform&quot;</span><span class="p">:</span> <span class="mh">0x4</span><span class="p">,</span>  <span class="c1"># objects can only collide with this Sprite when coming from the top (also no x-collisions) (should normally also be dockable)</span>
        <span class="s2">&quot;particle&quot;</span><span class="p">:</span>         <span class="mh">0x8</span><span class="p">,</span>  <span class="c1"># e.g. an arrow/shot/etc..</span>
        <span class="s2">&quot;friendly&quot;</span><span class="p">:</span>         <span class="mh">0x10</span><span class="p">,</span>
        <span class="s2">&quot;enemy&quot;</span><span class="p">:</span>            <span class="mh">0x20</span><span class="p">,</span>
        <span class="s2">&quot;all&quot;</span><span class="p">:</span>              <span class="mh">0xffff</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">next_type</span> <span class="o">=</span> <span class="mh">0x200</span>

<div class="viewcode-block" id="Sprite.get_type"><a class="viewcode-back" href="../spygame_reference.html#spygame.Sprite.get_type">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_type</span><span class="p">(</span><span class="n">types_</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the bitmap code for an already existing Sprite type or for a new type (the code will be created then).</span>
<span class="sd">        Types are usually used for collision masks.</span>

<span class="sd">        :param str types_: the type(s) (comma-separated), whose code(s) should be returned</span>
<span class="sd">        :return: the type as an int; if many types are given, returns a bitmask with all those bits set that represent the given types</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">type_</span> <span class="ow">in</span> <span class="n">types_</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">type_</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">types</span><span class="p">:</span>
                <span class="n">Sprite</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">next_type</span>
                <span class="n">Sprite</span><span class="o">.</span><span class="n">next_type</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">ret</span> <span class="o">|=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">types</span><span class="p">[</span><span class="n">type_</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int x: the initial x position of this Sprite</span>
<span class="sd">        :param int y: the initial y position of this Sprite</span>
<span class="sd">        :param any **kwargs:</span>
<span class="sd">         - sprite_sheet: a ready SpriteSheet object to use (set initial image to first frame in the SpriteSheet)</span>
<span class="sd">         - image_file: use image_file (str) as a file name for a static image</span>
<span class="sd">         - image_section (Tuple[int,int,int,int]): offset-x, offset-y, width, height defining a rect to use only a subsection of the given static image</span>
<span class="sd">         - width_height (Tuple[int,int]): the dimensions of the collision rect; if not given, we&#39;ll try to derive the collision rect from</span>
<span class="sd">           the given image/spritesheet</span>
<span class="sd">         - image_rect: a pygame.Rect defining the x/y offset and width/height of the Sprite&#39;s image with respect to the Sprite&#39;s rect (collision)</span>
<span class="sd">           e.g. if the image is 32x32 but the collision rect should only be 16x32 (slim), the width_height kwarg should be (16, 32) and the image_rect kwarg</span>
<span class="sd">           should be pygame.Rect(-8, 0, 32, 32)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">GameObject</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># can be set to the number of ticks to ignore by the containing stage depending on whether this Sprite is within the Stage&#39;s viewable borders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_after_n_ticks</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># &gt;0: not to be ignored; &lt;=0: ignore this sprite for one tick</span>

        <span class="c1"># determine the image of this Sprite, its collision rect, and its image-offset-rect (where with respect to the collision rect do we draw the image?)</span>
        <span class="c1"># - with SpriteSheet</span>
        <span class="k">if</span> <span class="s2">&quot;sprite_sheet&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">sheet</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sprite_sheet&quot;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sheet</span><span class="p">,</span> <span class="n">SpriteSheet</span><span class="p">),</span> <span class="s2">&quot;ERROR: in Sprite&#39;s ctor: kwargs[`sprite_sheet`] must be of type `SpriteSheet`!&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span> <span class="o">=</span> <span class="n">sheet</span>
            <span class="c1"># TODO: make it possible to create a Sprite from more than one tile (e.g. for a platform/elevator). Either in x-direction or y-direction or both</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">sheet</span><span class="o">.</span><span class="n">tiles</span><span class="p">[</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tile&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]</span>
            <span class="n">width_height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;width_height&quot;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">th</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width_height</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">width_height</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># collision rect</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;image_rect&quot;</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">width_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tw</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                                   <span class="n">width_height</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">th</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tw</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">th</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># - an image file -&gt; fixed image -&gt; store as Surface in self.image</span>
        <span class="k">elif</span> <span class="s2">&quot;image_file&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">image</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;image_file&quot;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;ERROR: in Sprite&#39;s ctor: kwargs[`image_file`] must be of type str!&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">source</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">image</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;image_section&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">sec</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;image_section&quot;</span><span class="p">]</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sec</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sec</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">,</span>\
                    <span class="s2">&quot;ERROR: in Sprite&#39;s ctor: kwargs[`image_section`] must be of type tuple and of len 4 (offset-x, offset-y, width, height)!&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="n">sec</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sec</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">source</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">area</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="o">*</span><span class="n">sec</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">source</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="o">.</span><span class="n">get_rect</span><span class="p">()</span>
            <span class="n">width_height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;width_height&quot;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span><span class="o">.</span><span class="n">height</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width_height</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">width_height</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># collision</span>
            <span class="c1"># fix image x/y (would be 0,0 otherwise)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;image_rect&quot;</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">width_height</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                                   <span class="n">width_height</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span><span class="o">.</span><span class="n">height</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># - empty image plus a collision rect of some size</span>
        <span class="k">elif</span> <span class="s2">&quot;width_height&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">width_height</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;width_height&quot;</span><span class="p">]</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">width_height</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">width_height</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span>\
                <span class="s2">&quot;ERROR: in Sprite&#39;s ctor: kwargs[`width_height`] must be of type tuple and of len 2!&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">width_height</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">width_height</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width_height</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">width_height</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_RECTS</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="c1"># - tiny-size rect (no image)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">spritesheet</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_RECTS</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># GameObject specific stuff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>  <span class="c1"># specifies the type of the Sprite (can be used e.g. for collision detection)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">handles_own_collisions</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># set to True if this object takes care of its own collision handling</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span>  <span class="c1"># set the bits here that we would like to collide with (all other types will be ignored)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">stage</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the current Stage this Sprite is in</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the current Groups that this Sprite belongs to</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;do_render&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span><span class="p">)</span>  <span class="c1"># we may overwrite this</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">render_order</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;render_order&quot;</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span>  <span class="c1"># the higher this number the later this Sprite will be rendered in the Stage&#39;s render function</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flip</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">}</span>  <span class="c1"># &#39;x&#39;: flip in x direction, &#39;y&#39;: flip in y direction, False: don&#39;t flip</span>

        <span class="c1"># our min/max positions (might be adjusted to more accurate values once placed onto a Stage)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>  <span class="c1"># by default, make x-position be limited automatically by Stage/Level borders</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="s2">&quot;auto&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># by default, make y-positions not limited</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;added_to_stage&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;added_to_stage&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>  <span class="c1"># allow any Stage to trigger this event using this Sprite</span>

<div class="viewcode-block" id="Sprite.added_to_stage"><a class="viewcode-back" href="../spygame_reference.html#spygame.Sprite.added_to_stage">[docs]</a>    <span class="k">def</span> <span class="nf">added_to_stage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        adjusts our max positions based on the stage&#39;s level&#39;s dimensions - only if it&#39;s a Level (not a simple Screen)</span>

<span class="sd">        :param Stage stage: the Stage we were added to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: make this independent on Level or simple Screen (even a Screen should have dimensions)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="n">Level</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">==</span> <span class="s2">&quot;auto&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span></div>

<div class="viewcode-block" id="Sprite.move"><a class="viewcode-back" href="../spygame_reference.html#spygame.Sprite.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves us by x/y pixels (or to x,y if absolute=True).</span>

<span class="sd">        :param Union[int,None] x: the amount in pixels to move in x-direction</span>
<span class="sd">        :param Union[int,None] y: the amount in pixels to move in y-direction</span>
<span class="sd">        :param bool absolute: whether x and y are given as absolute coordinates (default: False): in this case x/y=None means do not move in this dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># absolute coordinates given</span>
        <span class="k">if</span> <span class="n">absolute</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="c1"># do a minimum of 1 pix (if larger 0.0)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">x</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;</span> <span class="n">y</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">y</span>

        <span class="c1"># then we do the boundary checking</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span></div>

    <span class="c1"># @override(GameObject)</span>
<div class="viewcode-block" id="Sprite.destroy"><a class="viewcode-back" href="../spygame_reference.html#spygame.Sprite.destroy">[docs]</a>    <span class="k">def</span> <span class="nf">destroy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>

        <span class="c1"># if we are on a stage -&gt; remove us from that stage</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">remove_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># remove us from all our pygame.sprite.Groups</span>
        <span class="k">for</span> <span class="n">sprite_group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">:</span>
            <span class="n">sprite_group</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Sprite.render"><a class="viewcode-back" href="../spygame_reference.html#spygame.Sprite.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Paints the Sprite with its current image onto the given Display object.</span>

<span class="sd">        :param Display display: the Display object to render on (Display has a pygame.Surface, on which we blit our image)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">:</span>
            <span class="c1">#print(&quot;render at x={}&quot;.format(self.rect.x + self.image_rect.x - display.offsets[0]))</span>
            <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">image_rect</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_RECTS</span><span class="p">:</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="p">,</span> <span class="n">DEBUG_RENDER_SPRITES_RECTS_COLOR</span><span class="p">,</span>
                             <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">h</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Repeater"><a class="viewcode-back" href="../spygame_reference.html#spygame.Repeater">[docs]</a><span class="k">class</span> <span class="nc">Repeater</span><span class="p">(</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A background 2D image that scrolls slower than the Viewport (to create a pseudo 3D effect).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image_file</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">ro</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;render_order&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># by default, make this Sprite render first</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image_file</span><span class="o">=</span><span class="n">image_file</span><span class="p">,</span> <span class="n">render_order</span><span class="o">=</span><span class="n">ro</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vx&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;vy&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat_x</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;repeat_x&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat_y</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;repeat_y&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat_w</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;repeat_w&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">repeat_h</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;repeat_h&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>
        <span class="c1"># don&#39;t collide with anything</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;none&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># @override(Sprite)</span>
<div class="viewcode-block" id="Repeater.render"><a class="viewcode-back" href="../spygame_reference.html#spygame.Repeater.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="c1"># debug rendering (no backgrounds) -&gt; early out</span>
        <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_DONT_RENDER_TILED_TILE_LAYERS</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ignore_after_n_ticks</span> <span class="o">=</span> <span class="mi">100</span>  <span class="c1"># replenish counter so that the repeater never goes out of the Viewport&#39;s scope</span>

        <span class="n">view_x</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">view_y</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">offset_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">view_x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span>
        <span class="n">offset_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">view_y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_x</span><span class="p">:</span>
            <span class="n">start_x</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="o">-</span><span class="n">offset_x</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_w</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_x</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_x</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_w</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">view_x</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_y</span><span class="p">:</span>
            <span class="n">start_y</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="o">-</span><span class="n">offset_y</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_h</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">start_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start_y</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_h</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">view_y</span>

        <span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="n">cur_y</span> <span class="o">=</span> <span class="n">start_y</span>
        <span class="k">while</span> <span class="n">cur_y</span> <span class="o">&lt;</span> <span class="n">display</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="n">scale</span><span class="p">:</span>
            <span class="n">cur_x</span> <span class="o">=</span> <span class="n">start_x</span>
            <span class="k">while</span> <span class="n">cur_x</span> <span class="o">&lt;</span> <span class="n">display</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="n">scale</span><span class="p">:</span>
                <span class="c1">#display.surface.blit(self.image, dest=(math.floor(cur_x + view_x), math.floor(cur_y + view_y)))</span>
                <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">cur_x</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">cur_y</span><span class="p">)))</span>
                <span class="n">cur_x</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_w</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_x</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="n">cur_y</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_h</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_y</span><span class="p">:</span>
                <span class="k">break</span></div></div>


<div class="viewcode-block" id="MovableRock"><a class="viewcode-back" href="../spygame_reference.html#spygame.MovableRock">[docs]</a><span class="k">class</span> <span class="nc">MovableRock</span><span class="p">(</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;image_file&quot;</span><span class="p">):</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;image_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;images/movable_rock.png&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default,dockable&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default,friendly,enemy,particle&quot;</span><span class="p">)</span>

        <span class="c1"># add Physics (and thus Dockable) components to this Rock</span>
        <span class="c1"># - pre-tick: Physics (movement + collision resolution)</span>
        <span class="c1">#self.register_event(&quot;collision&quot;)</span>

        <span class="n">phys</span> <span class="o">=</span> <span class="n">PlatformerPhysics</span><span class="p">(</span><span class="s2">&quot;physics&quot;</span><span class="p">)</span>
        <span class="n">phys</span><span class="o">.</span><span class="n">is_pushable</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># rock can be pushed by an agent</span>
        <span class="n">phys</span><span class="o">.</span><span class="n">vx_max</span> <span class="o">=</span> <span class="mi">10</span>  <span class="c1"># max move speed (when pushed): this should be very slow</span>
        <span class="n">phys</span><span class="o">.</span><span class="n">is_heavy</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># rock makes Stage&#39;s viewport rock if it hits ground AND squeezes agents :(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmp_physics</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">phys</span><span class="p">)</span>

        <span class="c1"># subscribe/register to some events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;bump.bottom&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;land&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;bump.top&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.left&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.right&quot;</span><span class="p">,</span> <span class="s2">&quot;hit.liquid&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="MovableRock.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.MovableRock.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="c1"># let our physics component handle all movements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmp_physics</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">game_loop</span><span class="p">)</span></div>

<div class="viewcode-block" id="MovableRock.land"><a class="viewcode-back" href="../spygame_reference.html#spygame.MovableRock.land">[docs]</a>    <span class="k">def</span> <span class="nf">land</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">shake_viewport</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Autobuild"><a class="viewcode-back" href="../spygame_reference.html#spygame.Autobuild">[docs]</a><span class="k">class</span> <span class="nc">Autobuild</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Mix-in class to force x, y, width, height structure of ctors. All autobuild objects (objects that are built automatically by a TiledTileLayer with</span>
<span class="sd">    the property autobuild_objects=true) will have to abode to this ctor parameter structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">tile_w</span><span class="p">,</span> <span class="n">tile_h</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int x: the x position of the Autobuild in tile units</span>
<span class="sd">        :param int y: the y position of the Autobuild in tile units</span>
<span class="sd">        :param int w: the width of the Autobuild in tile units</span>
<span class="sd">        :param int h: the height of the Autobuild in tile units</span>
<span class="sd">        :param int tile_w: the tile width of the layer</span>
<span class="sd">        :param int tile_h: the tile height of the layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_in_tiles</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_in_tiles</span> <span class="o">=</span> <span class="n">y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">w_in_tiles</span> <span class="o">=</span> <span class="n">w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">h_in_tiles</span> <span class="o">=</span> <span class="n">h</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_w</span> <span class="o">=</span> <span class="n">tile_w</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span> <span class="o">=</span> <span class="n">tile_h</span></div>


<div class="viewcode-block" id="Ladder"><a class="viewcode-back" href="../spygame_reference.html#spygame.Ladder">[docs]</a><span class="k">class</span> <span class="nc">Ladder</span><span class="p">(</span><span class="n">Sprite</span><span class="p">,</span> <span class="n">Autobuild</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Ladder object that actors can climb on.</span>
<span class="sd">    One-way-platform type: one cannot fall through the top of the ladder but does not collide with the rest (e.g. from below) of the ladder.</span>
<span class="sd">    A Ladder object does not have an image and is thus not(!) being rendered; the image of the ladder has to be integrated into a rendered TiledTileLayer.</span>
<span class="sd">    TiledTileLayers have the possibility to generate Ladder objects automatically from those tiles that are flagged with the type=&#39;ladder&#39; property. In that</span>
<span class="sd">    case, the TiledTileLayer property &#39;build_ladders&#39; (bool) has to be set to true.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">tile_w</span><span class="p">,</span> <span class="n">tile_h</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int x: the x position of the Ladder in tile units</span>
<span class="sd">        :param int y: the y position of the Ladder in tile units</span>
<span class="sd">        :param int w: the width of the Ladder in tile units</span>
<span class="sd">        :param int h: the height of the Ladder in tile units</span>
<span class="sd">        :param int tile_w: the tile width of the layer</span>
<span class="sd">        :param int tile_h: the tile height of the layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Autobuild</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">tile_w</span><span class="p">,</span> <span class="n">tile_h</span><span class="p">)</span>
        <span class="c1"># transform values here to make collision with ladder to only trigger when player is relatively close to the x-center of the ladder</span>
        <span class="c1"># - make this a 2px wide vertical axis in the center of the ladder</span>
        <span class="n">x_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_in_tiles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_w</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_in_tiles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_w</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">y_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_in_tiles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span>

        <span class="c1"># call the Sprite ctor (now everything is in px)</span>
        <span class="n">Sprite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_px</span><span class="p">,</span> <span class="n">y_px</span><span class="p">,</span> <span class="n">width_height</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_in_tiles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span><span class="p">))</span>

        <span class="c1"># collision types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;ladder,dockable,one_way_platform&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># do not do any collisions</span></div>


<div class="viewcode-block" id="LiquidBody"><a class="viewcode-back" href="../spygame_reference.html#spygame.LiquidBody">[docs]</a><span class="k">class</span> <span class="nc">LiquidBody</span><span class="p">(</span><span class="n">Sprite</span><span class="p">,</span> <span class="n">Autobuild</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A LiquidBody object (quicksand, water, etc..) that an actor will sink into and die. The AIBrain of enemies will avoid stepping into such an object.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">tile_w</span><span class="p">,</span> <span class="n">tile_h</span><span class="p">,</span> <span class="n">description</span><span class="o">=</span><span class="s2">&quot;quicksand&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int x: the x position of the Ladder in tile units</span>
<span class="sd">        :param int y: the y position of the Ladder in tile units</span>
<span class="sd">        :param int w: the width of the Ladder in tile units</span>
<span class="sd">        :param int h: the height of the Ladder in tile units</span>
<span class="sd">        :param int tile_w: the tile width of the layer</span>
<span class="sd">        :param int tile_h: the tile height of the layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Autobuild</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">tile_w</span><span class="p">,</span> <span class="n">tile_h</span><span class="p">)</span>
        <span class="c1"># make the liquid object a little lower than the actual tiles (especially at the top assuming that the top is done with tiles only showing</span>
        <span class="c1"># the very shallow surface of the liquid body)</span>
        <span class="n">x_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_in_tiles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_w</span>
        <span class="n">y_px</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_in_tiles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)</span>

        <span class="c1"># call the Sprite ctor (now everything is in px)</span>
        <span class="n">Sprite</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x_px</span><span class="p">,</span> <span class="n">y_px</span><span class="p">,</span> <span class="n">width_height</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">w_in_tiles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">h_in_tiles</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span> <span class="o">-</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tile_h</span> <span class="o">*</span> <span class="mf">0.9</span><span class="p">)))</span>

        <span class="c1"># can be used to distinguish between different types of liquids (water, quicksand, lava, etc..)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">description</span> <span class="o">=</span> <span class="n">description</span>

        <span class="c1"># collision types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;liquid&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># do not do any collisions</span></div>


<div class="viewcode-block" id="AnimatedSprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.AnimatedSprite">[docs]</a><span class="k">class</span> <span class="nc">AnimatedSprite</span><span class="p">(</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds an Animation component to each Sprite instance.</span>
<span class="sd">    AnimatedSprites need a SpriteSheet (no static images or no-render allowed).</span>

<span class="sd">    :param int x: the initial x position of the Sprite</span>
<span class="sd">    :param int y: the initial y position of the Sprite</span>
<span class="sd">    :param SpriteSheet spritesheet: the SpriteSheet object to use for this Sprite</span>
<span class="sd">    :param dict animation_setup: the dictionary with the animation setup data to be sent to Animation.register_settings (the name of the registry record will</span>
<span class="sd">            be kwargs[&quot;anim_settings_name&quot;] OR spritesheet.name)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sprite_sheet</span><span class="p">,</span> <span class="n">animation_setup</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int x: the initial x position of the AnimatedSprite</span>
<span class="sd">        :param int y: the initial y position of the AnimatedSprite</span>
<span class="sd">        :param SpriteSheet sprite_sheet: the SpriteSheet to use for animations</span>
<span class="sd">        :param dict animation_setup: a dictionary with all the different animation name and their settings (animation speed, frames to use, etc..)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sprite_sheet</span><span class="p">,</span> <span class="n">SpriteSheet</span><span class="p">),</span> <span class="s2">&quot;ERROR: AnimatedSprite needs a SpriteSheet in its c&#39;tor!&quot;</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">sprite_sheet</span><span class="o">=</span><span class="n">sprite_sheet</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmp_animation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">Animation</span><span class="p">(</span><span class="s2">&quot;animation&quot;</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">anim_settings_name</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;anim_settings_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sprite_sheet</span><span class="o">.</span><span class="n">name</span>
        <span class="n">Animation</span><span class="o">.</span><span class="n">register_settings</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">anim_settings_name</span><span class="p">,</span> <span class="n">animation_setup</span><span class="p">,</span> <span class="n">register_events_on</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># play the default animation (now that we have added the Animation Component, we can call play_animation on ourselves)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">play_animation</span><span class="p">(</span><span class="n">animation_setup</span><span class="p">[</span><span class="s2">&quot;default&quot;</span><span class="p">])</span></div>


<div class="viewcode-block" id="Display"><a class="viewcode-back" href="../spygame_reference.html#spygame.Display">[docs]</a><span class="k">class</span> <span class="nc">Display</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple wrapper class for a pygame.display/pygame.Surface object representing the pygame display.</span>
<span class="sd">    Also stores offset information for Viewport focusing (if Viewport is smaller that the Level, which is usually the case).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">instantiated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">600</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">400</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;Spygame Rocks!&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param int width: the width of the Display</span>
<span class="sd">        :param int height: the height of the Display</span>
<span class="sd">        :param str title: the caption to use on the pygame display</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">Display</span><span class="o">.</span><span class="n">instantiated</span><span class="p">,</span> <span class="s2">&quot;ERROR: can only create one </span><span class="si">{}</span><span class="s2"> object!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">Display</span><span class="o">.</span><span class="n">instantiated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_caption</span><span class="p">(</span><span class="n">title</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offsets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

<div class="viewcode-block" id="Display.change_dims"><a class="viewcode-back" href="../spygame_reference.html#spygame.Display.change_dims">[docs]</a>    <span class="k">def</span> <span class="nf">change_dims</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the Display&#39;s size dynamically (during the game).</span>

<span class="sd">        :param int width: the new width to use</span>
<span class="sd">        :param int height: the new height to use</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">height</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">set_mode</span><span class="p">((</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">))</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">surface</span> <span class="ow">is</span> <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">get_surface</span><span class="p">(),</span> <span class="s2">&quot;ERROR: self.display is not same object as pygame.display.get_surface() anymore!&quot;</span></div>

<div class="viewcode-block" id="Display.debug_refresh"><a class="viewcode-back" href="../spygame_reference.html#spygame.Display.debug_refresh">[docs]</a>    <span class="k">def</span> <span class="nf">debug_refresh</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force-refreshes the display (used only for debug purposes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">([])</span>  <span class="c1"># we seem to have to do this</span></div></div>


<div class="viewcode-block" id="GameLoop"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameLoop">[docs]</a><span class="k">class</span> <span class="nc">GameLoop</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class that represents the GameLoop.</span>
<span class="sd">    Has play and pause functions: play starts the tick/callback loop.</span>
<span class="sd">    Has clock for ticking (keeps track of self.dt each tick), handles and abides to max-fps rate setting.</span>
<span class="sd">    Handles keyboard input registrations via its KeyboardInputs object.</span>
<span class="sd">    Needs a callback to know what to do each tick.</span>
<span class="sd">    Tick method does keyboard_inputs.tick, then calls the given callback with self as only argument.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># static loop object (the currently active GameLoop gets stored here)</span>
    <span class="n">active_loop</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="GameLoop.play_a_loop"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameLoop.play_a_loop">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">play_a_loop</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory: plays a given GameLoop object or creates a new one using the given \*\*kwargs options.</span>

<span class="sd">        :param any kwargs:</span>
<span class="sd">                force_loop (bool): whether to play regardless of whether we still have some active loop running</span>
<span class="sd">                callback (callable): the GameLoop&#39;s callback loop function</span>
<span class="sd">                keyboard_inputs (KeyboardInputs): the GameLoop&#39;s KeyboardInputs object</span>
<span class="sd">                display (Display): the Display object to render everything on</span>
<span class="sd">                max_fps (int): the max frames per second to loop through</span>
<span class="sd">                screen_obj (Screen): alternatively, a Screen can be given, from which we will extract `display`, `max_fps` and `keyboard_inputs`</span>
<span class="sd">                game_loop (Union[str,GameLoop]): the GameLoop to use (instead of creating a new one); &quot;new&quot; or [empty] for new one</span>
<span class="sd">                dont_play (bool): whether - after creating the GameLoop - it should be `play`ed. Can be used for openAI gym purposes, where we just `step`, not `tick`</span>
<span class="sd">        :return: the created/played GameLoop object or None</span>
<span class="sd">        :rtype: Union[GameLoop,None]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">defaults</span><span class="p">(</span><span class="n">kwargs</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;force_loop&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;screen_obj&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;display&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;max_fps&quot;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="s2">&quot;game_loop&quot;</span> <span class="p">:</span> <span class="s2">&quot;new&quot;</span><span class="p">,</span> <span class="s2">&quot;dont_play&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">})</span>

        <span class="c1"># - if there&#39;s no other loop active, run the default stageGameLoop</span>
        <span class="c1"># - or: there is an active loop, but we force overwrite it</span>
        <span class="k">if</span> <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="p">(</span><span class="s2">&quot;force_loop&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="ow">and</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;force_loop&quot;</span><span class="p">]):</span>
            <span class="c1"># generate a new loop (and play)</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;game_loop&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;new&quot;</span><span class="p">:</span>
                <span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># set keyboard inputs directly</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">]:</span>
                    <span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">]</span>
                <span class="c1"># or through the screen_obj</span>
                <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]:</span>
                    <span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">keyboard_inputs</span>

                <span class="n">display</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="c1"># set display directly</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;display&quot;</span><span class="p">]:</span>
                    <span class="n">display</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;display&quot;</span><span class="p">]</span>
                <span class="c1"># or through the screen_obj</span>
                <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]:</span>
                    <span class="n">display</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">display</span>

                <span class="n">max_fps</span> <span class="o">=</span> <span class="mi">60</span>
                <span class="c1"># set display directly</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_fps&quot;</span><span class="p">]:</span>
                    <span class="n">max_fps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;max_fps&quot;</span><span class="p">]</span>
                <span class="c1"># or through the screen_obj</span>
                <span class="k">elif</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]:</span>
                    <span class="n">max_fps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">max_fps</span>

                <span class="n">loop</span> <span class="o">=</span> <span class="n">GameLoop</span><span class="p">(</span><span class="n">Stage</span><span class="o">.</span><span class="n">stage_default_game_loop_callback</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="n">display</span><span class="p">,</span>
                                <span class="n">keyboard_inputs</span><span class="o">=</span><span class="n">keyboard_inputs</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="n">max_fps</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;dont_play&quot;</span><span class="p">]:</span>
                    <span class="n">loop</span><span class="o">.</span><span class="n">play</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">loop</span>

            <span class="c1"># just play an already existing loop</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;game_loop&quot;</span><span class="p">],</span> <span class="n">GameLoop</span><span class="p">):</span>
                <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;game_loop&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">play</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;game_loop&quot;</span><span class="p">]</span>

            <span class="c1"># do nothing</span>
            <span class="k">return</span> <span class="kc">None</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">display</span><span class="p">,</span> <span class="n">keyboard_inputs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="mi">60</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param callable callback: the callback function to call each time we `tick` (after collecting keyboard events)</span>
<span class="sd">        :param Display display: the Display object associated with the loop</span>
<span class="sd">        :param KeyboardInputs keyboard_inputs: the KeyboardInputs object to use for collecting keyboard information each tick (we simply call the</span>
<span class="sd">        KeyboardInputs&#39; `tick` method during our own `tick` method)</span>
<span class="sd">        :param int max_fps: the maximum frame rate per second to allow when ticking. fps can be slower, but never faster</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True -&gt; Game loop will be paused (no frames, no ticks)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span> <span class="o">=</span> <span class="n">callback</span>  <span class="c1"># gets called each tick with this GameLoop instance as the first parameter (can then extract dt as `game_loop.dt`)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">timer</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">time</span><span class="o">.</span><span class="n">Clock</span><span class="p">()</span>  <span class="c1"># our tick object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># global frame counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># time since last tick was executed</span>
        <span class="c1"># registers those keyboard inputs to capture each tick (up/right/down/left as default if none given)</span>
        <span class="c1"># - keyboard inputs can be changed during the loop via self.keyboard_input.update_keys([new key list])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">keyboard_inputs</span> <span class="ow">or</span> <span class="n">KeyboardInputs</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span> <span class="o">=</span> <span class="n">max_fps</span>

<div class="viewcode-block" id="GameLoop.pause"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameLoop.pause">[docs]</a>    <span class="k">def</span> <span class="nf">pause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pauses this GameLoop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="GameLoop.play"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameLoop.play">[docs]</a>    <span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plays this GameLoop (after pausing the currently running GameLoop, if any).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># pause the current loop</span>
        <span class="k">if</span> <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span><span class="p">:</span>
            <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span><span class="o">.</span><span class="n">pause</span><span class="p">()</span>
        <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># tick as long as we are not paused</span>
        <span class="k">while</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">max_fps</span><span class="p">)</span></div>

<div class="viewcode-block" id="GameLoop.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameLoop.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called each frame of the GameLoop.</span>
<span class="sd">        Collects keyboard events.</span>
<span class="sd">        Calls the GameLoop&#39;s `callback`.</span>
<span class="sd">        Keeps a frame counter.</span>

<span class="sd">        :param int max_fps: the maximum allowed number of frames per second (usually 60)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">max_fps</span><span class="p">:</span>
            <span class="n">max_fps</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span>

        <span class="c1"># move the clock and store the dt (since last frame) in sec</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">timer</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">max_fps</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span>

        <span class="c1"># default global events?</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">)</span>  <span class="c1"># TODO: add more here?</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="ne">SystemExit</span><span class="p">,</span> <span class="s2">&quot;QUIT&quot;</span><span class="p">)</span>

        <span class="c1"># collect keyboard events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>

        <span class="c1"># call the callback with self (for references to important game parameters)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># increase global frame counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="GameLoop.step"><a class="viewcode-back" href="../spygame_reference.html#spygame.GameLoop.step">[docs]</a>    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        (!)for reinforcement learning only(!) WIP:</span>
<span class="sd">        Executes one action on the game.</span>
<span class="sd">        The action gets translated into a keyboard sequence first, then is played.</span>

<span class="sd">        :param str action: the action to execute on the MDP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># default global events?</span>
        <span class="n">events</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">event</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">)</span>  <span class="c1"># TODO: add more here?</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">events</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">pygame</span><span class="o">.</span><span class="n">QUIT</span><span class="p">:</span>
                <span class="k">raise</span> <span class="p">(</span><span class="ne">SystemExit</span><span class="p">,</span> <span class="s2">&quot;QUIT&quot;</span><span class="p">)</span>

        <span class="c1"># collect keyboard events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">tick</span><span class="p">()</span>

        <span class="c1"># call the callback with self (for references to important game parameters)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">callback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># increase global frame counter</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">+=</span> <span class="mi">1</span></div></div>


<div class="viewcode-block" id="Stage"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage">[docs]</a><span class="k">class</span> <span class="nc">Stage</span><span class="p">(</span><span class="n">GameObject</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Stage is a container class for Sprites sorted by pygame.sprite.Groups and TiledTileLayers.</span>
<span class="sd">    Sprites within a Stage can collide with each other or with the TiledTileLayers in the Stage.</span>
<span class="sd">    Sprites and TiledTileLayers that are to be rendered are stored sorted by their render_order property (lowest renders first).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># list of all Stages</span>
    <span class="n">max_stages</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">stages</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">max_stages</span><span class="p">)]</span>
    <span class="n">active_stage</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the currently ticked/rendered Stage</span>
    <span class="n">locate_obj</span> <span class="o">=</span> <span class="n">Sprite</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width_height</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>  <span class="c1"># used to do test collisions on a Stage</span>

<div class="viewcode-block" id="Stage.stage_default_game_loop_callback"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.stage_default_game_loop_callback">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stage_default_game_loop_callback</span><span class="p">(</span><span class="n">game_loop</span><span class="p">:</span> <span class="n">GameLoop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The default game loop callback to use if none is given when staging a Scene.</span>
<span class="sd">        Order: Clamps dt (to avoid extreme values), ticks all stages, renders all stages, updates the pygame.display</span>

<span class="sd">        :param GameLoop game_loop: the currently playing (active) GameLoop</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># clamp dt</span>
        <span class="k">if</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">60</span>
        <span class="k">elif</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span> <span class="o">&gt;</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">15</span><span class="p">:</span>
            <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="mi">15</span>

        <span class="c1"># tick all Stages</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stage</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">):</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">stage</span><span class="p">:</span>
                <span class="n">stage</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">game_loop</span><span class="p">)</span>

        <span class="c1"># render all Stages and refresh the pygame.display</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">render_stages</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">,</span> <span class="n">refresh_after_render</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="mi">0</span></div>

<div class="viewcode-block" id="Stage.render_stages"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.render_stages">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">render_stages</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">refresh_after_render</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loops through all Stages and renders all of them.</span>

<span class="sd">        :param Display display: Display object on which to render</span>
<span class="sd">        :param bool refresh_after_render: do we refresh the pygame.display after all Stages have been called with `render`?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># black out display (really necessary? I think so)</span>
        <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="s2">&quot;#000000&quot;</span><span class="p">))</span>
        <span class="c1"># call render on all Stages</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">stage</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">):</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">stage</span><span class="p">:</span>
                <span class="n">stage</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">display</span><span class="p">)</span>
        <span class="c1"># for debugging purposes</span>
        <span class="k">if</span> <span class="n">refresh_after_render</span><span class="p">:</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">flip</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stage.clear_stage"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.clear_stage">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">clear_stage</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears one of the Stage objects by index.</span>

<span class="sd">        :param int idx: the index of the Stage to clear (index==slot in static Stage.stages list)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">idx</span><span class="p">]:</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Stage.clear_stages"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.clear_stages">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">clear_stages</span><span class="p">():</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears all our Stage objects.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">)):</span>
            <span class="n">Stage</span><span class="o">.</span><span class="n">clear_stage</span><span class="p">(</span><span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.get_stage"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.get_stage">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_stage</span><span class="p">(</span><span class="n">idx</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the Stage at the given index (returns None if none found).</span>

<span class="sd">        :param Union[int,None] idx: the index of the Stage to return (0=default Stage)</span>
<span class="sd">        :return: the Stage object at the given index or None if there is no Stage at that index</span>
<span class="sd">        :rtype: Union[Stage,None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span>
        <span class="k">return</span> <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span></div>

<div class="viewcode-block" id="Stage.stage_screen"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.stage_screen">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">stage_screen</span><span class="p">(</span><span class="n">screen</span><span class="p">,</span> <span class="n">screen_func</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stage_idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Supported options are (if not given, we take some of them from given Screen object, instead):</span>
<span class="sd">        - stage_idx (int): sets the stage index to use (0-9)</span>
<span class="sd">        - stage_class (class): sets the class (must be a Stage class) to be used when creating the new Stage</span>
<span class="sd">        - force_loop (bool): if set to True and we currently have a GameLoop running, stop the current GameLoop and replace it with a new one, which has</span>
<span class="sd">        to be given via the &quot;game_loop&quot; option (as GameLoop object, or as string &quot;new&quot; for a default GameLoop)</span>
<span class="sd">        - keyboard_inputs (KeyboardInputs): the KeyboardInputs object to use for the new GameLoop</span>
<span class="sd">        - display (Display): the Display to use for the new GameLoop</span>
<span class="sd">        - components (List[Component]): a list of Component objects to add to the new Stage (e.g. a Viewport)</span>

<span class="sd">        :param Screen screen: the Screen object to set up on a certain stage</span>
<span class="sd">        :param callable screen_func: the function to use to set up the Stage (before playing it)</span>
<span class="sd">        :param int stage_idx: the Stage index to use (0=default Stage)</span>
<span class="sd">        :param dict options: options to be used when instantiating the Stage</span>
<span class="sd">        :return: the new Stage object</span>
<span class="sd">        :rtype: Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">options</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">options</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="n">defaults</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;stage_class&quot;</span><span class="p">:</span> <span class="n">Stage</span><span class="p">})</span>

        <span class="c1"># figure out which stage to use</span>
        <span class="n">stage_idx</span> <span class="o">=</span> <span class="n">stage_idx</span> <span class="k">if</span> <span class="n">stage_idx</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;stage_idx&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;stage_idx&quot;</span> <span class="ow">in</span> <span class="n">options</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># clean up an existing stage if necessary</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">clear_stage</span><span class="p">(</span><span class="n">stage_idx</span><span class="p">)</span>

        <span class="c1"># create a new Stage and make this this the active stage</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">Stage</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="n">stage_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">options</span><span class="p">[</span><span class="s2">&quot;stage_class&quot;</span><span class="p">](</span><span class="n">screen</span><span class="p">,</span> <span class="n">options</span><span class="p">)</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="n">stage_idx</span>

        <span class="c1"># setup the Stage via the screen_fun (passing it the newly created Stage)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">screen_func</span><span class="p">:</span>
            <span class="n">screen_func</span> <span class="o">=</span> <span class="n">screen</span><span class="o">.</span><span class="n">screen_func</span>

        <span class="n">screen_func</span><span class="p">(</span><span class="n">stage</span><span class="p">)</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">active_stage</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># finally return the stage to the user for use if needed</span>
        <span class="k">return</span> <span class="n">stage</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">screen</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param Screen screen: the Stage&#39;s Screen object (a Screen determines which elements (layers and sprites) go on the Stage)</span>
<span class="sd">        :param dict options: the options ruling the behavior of this Stage. options can be:</span>
<span class="sd">         components (list): a list of components to add to this Stage during construction (usually, a Viewport gets added)</span>
<span class="sd">         tile_sprite_handler (callable): a method taking a TiledTileLayer and returning an ndarray (tile-x/y position) of TileSprite objects (None if tile is</span>
<span class="sd">          empty)</span>
<span class="sd">         physics_collision_detector (callable): a method to use to detect a possible collision between two Sprites (defaults to AABBCollision.collide)</span>
<span class="sd">         tick_sprites_in_range_only (bool): if set to True (default), we will not tick those Sprite objects that are currently outside a) our Viewport</span>
<span class="sd">          component or b) outside the display</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screen</span> <span class="o">=</span> <span class="n">screen</span>  <span class="c1"># the screen object associated with this Stage</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_tile_layers</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># TiledLayer objects by name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_object_groups</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># TiledObjectGroup objects by name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of all layers and sprites by name (TiledTileLayers AND Sprites) in the order in which they have to be rendered</span>

        <span class="c1"># dict of pygame.sprite.Group objects (by name) that contain Sprites (each TiledObjectGroup results in one Group)</span>
        <span class="c1"># - the name of the group is always the name of the TiledObjectGroup in the tmx file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># a plain list of all Sprites in this Stage</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># sprites to be removed from the Stage (only remove when Stage gets ticked)</span>

        <span class="n">defaults</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;physics_collision_detector&quot;</span><span class="p">:</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">,</span> <span class="s2">&quot;tick_sprites_in_range_only&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;tick_sprites_n_more_frames&quot;</span><span class="p">:</span> <span class="mi">500</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">options</span> <span class="o">=</span> <span class="n">options</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># register events that we will trigger</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;destroyed&quot;</span><span class="p">,</span>
                            <span class="s2">&quot;added_to_stage&quot;</span><span class="p">,</span> <span class="s2">&quot;removed_from_stage&quot;</span><span class="p">,</span>  <span class="c1"># Sprites added/removed to/from us</span>
                            <span class="s2">&quot;pre_ticks&quot;</span><span class="p">,</span> <span class="s2">&quot;pre_collisions&quot;</span><span class="p">,</span>  <span class="c1"># before we tick all Sprites, before we analyse all Sprites for collisions</span>
                            <span class="s2">&quot;post_tick&quot;</span><span class="p">,</span>  <span class="c1"># after we ticked all Sprites</span>
                            <span class="s2">&quot;pre_render&quot;</span><span class="p">,</span> <span class="s2">&quot;post_render&quot;</span>  <span class="c1"># before/after we render all our layers</span>
                            <span class="p">)</span>

        <span class="c1"># add Components to this Stage (given in options)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmp_viewport</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Union[Viewport,None]</span>
        <span class="k">if</span> <span class="s2">&quot;components&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;components&quot;</span><span class="p">]:</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comp</span><span class="p">,</span> <span class="n">Component</span><span class="p">),</span> <span class="s2">&quot;ERROR: one of the given components in Stage&#39;s c&#39;tor (options[&#39;components&#39;]) is not of type Component!&quot;</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">comp</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">comp</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;viewport&quot;</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cmp_viewport</span> <span class="o">=</span> <span class="n">comp</span>

        <span class="c1"># store the viewable range Rect</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">respect_viewable_range</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp_viewport</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tick_sprites_in_range_only&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewable_rect</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">height</span><span class="p">)</span>

        <span class="c1"># make sure our destroyed method is called when the stage is destroyed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;destroyed&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Stage.destroyed"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.destroyed">[docs]</a>    <span class="k">def</span> <span class="nf">destroyed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invoke</span><span class="p">(</span><span class="s2">&quot;debind_events&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.for_each"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.for_each">[docs]</a>    <span class="k">def</span> <span class="nf">for_each</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls the given callback function for each sprite, each time passing it the sprite itself and \*params.</span>

<span class="sd">        :param callable callback: the callback to call for each sprite in the Stage</span>
<span class="sd">        :param any params: the params to pass as second/third/etc.. parameter to the callback</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">callback</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.invoke"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.invoke">[docs]</a>    <span class="k">def</span> <span class="nf">invoke</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls a function on all of the GameObjects on this Stage.</span>

<span class="sd">        :param str func_name: the function name to call on all our GameObjects using getattr</span>
<span class="sd">        :param Union[list,None] params: the \*args passed to that function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
                <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">params</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.detect"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.detect">[docs]</a>    <span class="k">def</span> <span class="nf">detect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">detector</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first GameObject in this Stage that - when passed to the detector function with params - returns True.</span>

<span class="sd">        :param callable detector: a function that returns a bool</span>
<span class="sd">        :param list params: the list of positional args that are passed to the detector</span>
<span class="sd">        :return: the first GameObject in this Stage that - when passed to the detector function with params - returns True</span>
<span class="sd">        :rtype: Union[Sprite,None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">params</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">detector</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="o">*</span><span class="n">params</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">sprite</span></div>

<div class="viewcode-block" id="Stage.locate"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.locate">[docs]</a>    <span class="k">def</span> <span class="nf">locate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">h</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">type_</span><span class="o">=</span><span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">),</span> <span class="n">collision_mask</span><span class="o">=</span><span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the first Collision found by colliding the given measurements (Rect) against this Stage&#39;s objects.</span>
<span class="sd">        Starts with all TiledTileLayer objects, then all other Sprites.</span>

<span class="sd">        :param int x: the x-coordinate of the Rect to check</span>
<span class="sd">        :param int y: the y-coordinate of the Rect to check</span>
<span class="sd">        :param int w: the width of the Rect to check</span>
<span class="sd">        :param int h: the height of the Rect to check</span>
<span class="sd">        :param int type_: the type of the Rect (has to match collision_mask of Stage&#39;s objects)</span>
<span class="sd">        :param int collision_mask: the collision mask of the Rect (only layers and Sprites that match this mask are checked)</span>
<span class="sd">        :return: the first Collision encountered</span>
<span class="sd">        :rtype: Union[Collision,None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">locate_obj</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">w</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">h</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">type_</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="n">collision_mask</span>

        <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_RECTS</span><span class="p">:</span>
            <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="p">,</span> <span class="n">DEBUG_RENDER_SPRITES_RECTS_COLOR</span><span class="p">,</span>
                             <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">((</span><span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                         <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">w</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">h</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">GameLoop</span><span class="o">.</span><span class="n">active_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>

        <span class="c1"># collide with all matching tile layers</span>
        <span class="k">for</span> <span class="n">tiled_tile_layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiled_tile_layers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">collide_simple_with_sprite</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;physics_collision_detector&quot;</span><span class="p">])</span>
                <span class="c1"># don&#39;t solve -&gt; just return</span>
                <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">col</span>

        <span class="c1"># collide with all Sprites (only if both collision masks match each others types)</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">sprite</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;physics_collision_detector&quot;</span><span class="p">](</span><span class="n">obj</span><span class="p">,</span> <span class="n">sprite</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">col</span>
        <span class="c1"># nothing found</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Stage.add_tiled_layer"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.add_tiled_layer">[docs]</a>    <span class="k">def</span> <span class="nf">add_tiled_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a pytmx.TiledElement to the Stage with all its tiles or objects.</span>
<span class="sd">        The TiledElement could either be converted into a TiledTileLayer or a TiledObjectGroup (these objects are generated in this function based on the</span>
<span class="sd">        pytmx equivalent being passed in).</span>

<span class="sd">        :param pytmx.pytmx.TiledElement pytmx_layer: the original pytmx object to derive our TiledTileLayer or TileObjectGroup from</span>
<span class="sd">        :param pytmx.pytmx.TiledMap pytmx_tiled_map: the original pytmx TiledMap object (the tmx file) to which this layer belongs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># a TiledObjectGroup (&quot;Object Layer&quot; in the tmx file)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledObjectGroup</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">pytmx_layer</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiled_object_groups</span><span class="p">,</span> <span class="s2">&quot;ERROR: TiledObjectGroup with name </span><span class="si">{}</span><span class="s2"> already exists in Stage!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">TiledObjectGroup</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_tiled_object_group</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="c1"># a TiledTileLayer (&quot;Tile Layer&quot; in the tmx file)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledTileLayer</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">pytmx_layer</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiled_tile_layers</span><span class="p">,</span> <span class="s2">&quot;ERROR: TiledTileLayer with name </span><span class="si">{}</span><span class="s2"> already exists in Stage!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">assert</span> <span class="s2">&quot;tile_sprite_handler&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> \
                <span class="s2">&quot;ERROR: a TiledTileLayer needs a tile_sprite_handler callable to generate all TileSprite objects in the layer!&quot;</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">TiledTileLayer</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tile_sprite_handler&quot;</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_tiled_tile_layer</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: pytmx_layer of type </span><span class="si">{}</span><span class="s2"> cannot be added to Stage. Needs to be pytmx.pytmx.TiledTileLayer or pytmx.pytmx.TiledObjectGroup!&quot;</span><span class="o">.</span>
                            <span class="nb">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span></div>

<div class="viewcode-block" id="Stage.add_tiled_object_group"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.add_tiled_object_group">[docs]</a>    <span class="k">def</span> <span class="nf">add_tiled_object_group</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tiled_object_group</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a TiledObjectGroup (all it&#39;s objects as single Sprites) to this Stage.</span>

<span class="sd">        :param TiledObjectGroup tiled_object_group:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># add the layer to our tiled_layers list</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_object_groups</span><span class="p">[</span><span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tiled_object_group</span>

        <span class="c1"># add the (already created) sprite-group to this stage under the name of the layer</span>
        <span class="k">assert</span> <span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">,</span> \
            <span class="s2">&quot;ERROR: trying to add a TiledObjectGroup to a Stage, but the Stage already has a sprite_group with the name of that layer (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span> \
                <span class="nb">format</span><span class="p">(</span><span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">[</span><span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tiled_object_group</span><span class="o">.</span><span class="n">sprite_group</span>

        <span class="c1"># add each single sprite of the group to the Stage</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="n">tiled_object_group</span><span class="o">.</span><span class="n">sprite_group</span><span class="o">.</span><span class="n">sprites</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tiled_object_group</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.add_tiled_tile_layer"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.add_tiled_tile_layer">[docs]</a>    <span class="k">def</span> <span class="nf">add_tiled_tile_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tiled_tile_layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a TiledTileLayer to this Stage.</span>
<span class="sd">        Puts it in the ordered to_render list, in the tiled_layers list.</span>

<span class="sd">        :param TiledTileLayer tiled_tile_layer: the TiledTileLayer to add to this Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># put the pytmx_layer into one of the collision groups (if not type==none)?</span>
        <span class="c1"># - this is useful for our solve_collisions method</span>
        <span class="c1">#if tiled_tile_layer.type != Sprite.get_type(&quot;none&quot;):</span>
        <span class="c1">#    self.tiled_layers_to_collide.append(tiled_tile_layer)</span>

        <span class="c1"># put only TiledTileLayers in to_render (iff do_render=true) and single Sprites (from the TiledObjectGroup) all ordered by render_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_tile_layers</span><span class="p">[</span><span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">tiled_tile_layer</span>

        <span class="c1"># add it to the to_render list and re-sort the list by render_order values (note: this list also contains single Sprites)</span>
        <span class="k">if</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tiled_tile_layer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">render_order</span><span class="p">)</span>

        <span class="c1"># capture ladders and other autobuild structures?</span>
        <span class="k">if</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;autobuild_objects&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span><span class="p">:</span>
            <span class="n">objects</span> <span class="o">=</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">capture_autobuilds</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">objects</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_sprite</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;autobuilds&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.add_sprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.add_sprite">[docs]</a>    <span class="k">def</span> <span class="nf">add_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">group_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new single Sprite to an existing or a new pygame.sprite.Group.</span>

<span class="sd">        :param Sprite sprite: the Sprite to be added to this Stage (the Sprite&#39;s position is defined in its rect.x/y properties)</span>
<span class="sd">        :param str group_name: the name of the group to which the GameObject should be added (group will not be created if it doesn&#39;t exist yet)</span>
<span class="sd">        :return: the Sprite that was added</span>
<span class="sd">        :rtype: Sprite</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># if the group doesn&#39;t exist yet, create it</span>
        <span class="k">if</span> <span class="n">group_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Group</span><span class="p">()</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">stage</span> <span class="o">=</span> <span class="bp">self</span>  <span class="c1"># set the Stage of this GameObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">sprite_groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sprite_groups</span><span class="p">[</span><span class="n">group_name</span><span class="p">])</span>

        <span class="c1"># add each single Sprite to the sorted (by render_order) to_render list and to the &quot;all&quot;-sprites list</span>
        <span class="c1"># - note: the to_render list also contains entire TiledTileLayer objects</span>
        <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">render_order</span><span class="p">)</span>

        <span class="c1"># trigger two events, one on the Stage with the object as target and one on the object with the Stage as target</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;added_to_stage&quot;</span><span class="p">,</span> <span class="n">sprite</span><span class="p">)</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;added_to_stage&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">sprite</span></div>

<div class="viewcode-block" id="Stage.remove_sprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.remove_sprite">[docs]</a>    <span class="k">def</span> <span class="nf">remove_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">:</span> <span class="n">Sprite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes a Sprite from this Stage by putting it in the remove_list for later removal.</span>

<span class="sd">        :param Sprite sprite: the Sprite to be removed from the Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.force_remove_sprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.force_remove_sprite">[docs]</a>    <span class="k">def</span> <span class="nf">force_remove_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">:</span> <span class="n">Sprite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force-removes the given Sprite immediately (without putting it in the remove_list first).</span>

<span class="sd">        :param Sprite sprite: the Sprite to be removed from the Stage</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># destroy the object</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">destroy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;removed_from_stage&quot;</span><span class="p">,</span> <span class="n">sprite</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.pause"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.pause">[docs]</a>    <span class="k">def</span> <span class="nf">pause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pauses playing the Stage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Stage.unpause"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.unpause">[docs]</a>    <span class="k">def</span> <span class="nf">unpause</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpauses playing the Stage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Stage.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called each frame by the GameLoop.</span>
<span class="sd">        Calls the tick method on all its Sprites (but only if the sprite is within the viewport).</span>

<span class="sd">        :param GameLoop game_loop: the GameLoop object that&#39;s currently running (and ticking all Stages)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_paused</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># do the ticking of all Sprite objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;pre_ticks&quot;</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span>

        <span class="c1"># only tick sprites that are within our viewport</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">respect_viewable_range</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">viewable_rect</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp_viewport</span><span class="o">.</span><span class="n">x</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">viewable_rect</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cmp_viewport</span><span class="o">.</span><span class="n">y</span>
            <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewable_rect</span><span class="o">.</span><span class="n">top</span> <span class="ow">and</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewable_rect</span><span class="o">.</span><span class="n">bottom</span> <span class="ow">and</span> \
                                <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewable_rect</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">viewable_rect</span><span class="o">.</span><span class="n">left</span><span class="p">:</span>
                    <span class="n">sprite</span><span class="o">.</span><span class="n">ignore_after_n_ticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tick_sprites_n_more_frames&quot;</span><span class="p">]</span>  <span class="c1"># reset to max</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tick_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">sprite</span><span class="o">.</span><span class="n">ignore_after_n_ticks</span> <span class="o">-=</span> <span class="mi">1</span>  <span class="c1"># if reaches 0 -&gt; ignore</span>
                    <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">ignore_after_n_ticks</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tick_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
                <span class="n">sprite</span><span class="o">.</span><span class="n">ignore_after_n_ticks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;tick_sprites_n_more_frames&quot;</span><span class="p">]</span>  <span class="c1"># always reset to max</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tick_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span>

        <span class="c1"># do the collision resolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;pre_collisions&quot;</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solve_collisions</span><span class="p">()</span>

        <span class="c1"># garbage collect destroyed GameObjects</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove_list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">force_remove_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_list</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">)</span></div>

<div class="viewcode-block" id="Stage.tick_sprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.tick_sprite">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">tick_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        ticks one single sprite</span>
<span class="sd">        :param Sprite sprite: the Sprite object to tick</span>
<span class="sd">        :param GameLoop game_loop: the GameLoop object that&#39;s currently playing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_EACH_TICK</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
            <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">tick</span><span class="p">(</span><span class="n">game_loop</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_AFTER_EACH_TICK</span><span class="p">:</span>
            <span class="n">sprite</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
            <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stage.solve_collisions"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.solve_collisions">[docs]</a>    <span class="k">def</span> <span class="nf">solve_collisions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Look for the objects layer and do each object against the main collision layer.</span>
<span class="sd">        Some objects in the objects layer do their own collision -&gt; skip those here (e.g. ladder climbing objects).</span>
<span class="sd">        After the main collision layer, do each object against each other.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># collide each object with all collidable layers (matching collision mask of object)</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="c1"># not ignored (one-tick) and if this game_object completely handles its own collisions within its tick -&gt; ignore it</span>
            <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">ignore_after_n_ticks</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sprite</span><span class="o">.</span><span class="n">handles_own_collisions</span> <span class="ow">and</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># collide with all matching tile layers</span>
                <span class="k">for</span> <span class="n">tiled_tile_layer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">tiled_tile_layers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="c1"># only collide, if one of the types of the layer matches one of the bits in the Sprite&#39;s collision_mask</span>
                    <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="n">tiled_tile_layer</span><span class="o">.</span><span class="n">collide_simple_with_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;physics_collision_detector&quot;</span><span class="p">])</span>
                        <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                            <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># collide all Sprites with all other Sprites (both ways!)</span>
        <span class="c1"># - only check if sprite1&#39;s collision_matrix matches sprite2&#39;s type</span>
        <span class="k">for</span> <span class="n">sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="c1"># not ignored (one-tick) and if this Sprite completely handles its own collisions within its tick -&gt; ignore it</span>
            <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">ignore_after_n_ticks</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">sprite</span><span class="o">.</span><span class="n">handles_own_collisions</span> <span class="ow">and</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">sprite2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sprite</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">sprite2</span> <span class="ow">and</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">type</span> <span class="ow">and</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">sprite</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;physics_collision_detector&quot;</span><span class="p">](</span><span class="n">sprite</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                            <span class="c1"># trigger &quot;collision&quot; for both Sprites</span>
                            <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                            <span class="n">sprite2</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">invert</span><span class="p">())</span></div>

<div class="viewcode-block" id="Stage.hide"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.hide">[docs]</a>    <span class="k">def</span> <span class="nf">hide</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hides the Stage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Stage.show"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unhides the Stage.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Stage.stop"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.stop">[docs]</a>    <span class="k">def</span> <span class="nf">stop</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stops playing the Stage (stops calling `tick` on all GameObjects).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">hide</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pause</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stage.start"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.start">[docs]</a>    <span class="k">def</span> <span class="nf">start</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Starts running the Stage (and calling all GameObject&#39;s `tick` method).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unpause</span><span class="p">()</span></div>

<div class="viewcode-block" id="Stage.render"><a class="viewcode-back" href="../spygame_reference.html#spygame.Stage.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called each frame by the GameLoop (after &#39;tick&#39; is called on all Stages).</span>
<span class="sd">        Renders all its layers (ordered by &#39;render_order&#39; property of the TiledTileLayer in the tmx file).</span>
<span class="sd">        TODO: renders Sprites that are not part of any layer.</span>

<span class="sd">        :param Display display: the Display object to render on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;pre_render&quot;</span><span class="p">,</span> <span class="n">display</span><span class="p">)</span>
        <span class="c1"># loop through the sorted to_render list and render all TiledTileLayer and Sprite objects in this list</span>
        <span class="k">for</span> <span class="n">layer_or_sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_render</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">layer_or_sprite</span><span class="p">,</span> <span class="s2">&quot;ignore_after_n_ticks&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">layer_or_sprite</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">display</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;post_render&quot;</span><span class="p">,</span> <span class="n">display</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TmxLayer"><a class="viewcode-back" href="../spygame_reference.html#spygame.TmxLayer">[docs]</a><span class="k">class</span> <span class="nc">TmxLayer</span><span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper class for the pytmx TiledObject class that can either represent a TiledTileLayer or a TiledObjectGroup.</span>
<span class="sd">    Needs to implement render and stores some spygame specific properties such as collision, render, etc.</span>

<span class="sd">    :param pytmx.pytmx.TiledElement tmx_layer_obj: the underlying pytmx TiledTileLayer</span>
<span class="sd">    :param pytmx.pytmx.TiledMap tmx_tiled_map: the underlying pytmx TiledMap object (representing the tmx file)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tmx_layer_obj</span><span class="p">,</span> <span class="n">tmx_tiled_map</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span> <span class="o">=</span> <span class="n">tmx_layer_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span> <span class="o">=</span> <span class="n">tmx_tiled_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">tmx_layer_obj</span><span class="o">.</span><span class="n">name</span>
        <span class="n">properties</span> <span class="o">=</span> <span class="n">tmx_layer_obj</span><span class="o">.</span><span class="n">properties</span>
        <span class="n">defaults</span><span class="p">(</span><span class="n">properties</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;do_render&quot;</span><span class="p">:</span> <span class="s2">&quot;true&quot;</span><span class="p">,</span> <span class="s2">&quot;render_order&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="n">properties</span></div>


<div class="viewcode-block" id="TiledTileLayer"><a class="viewcode-back" href="../spygame_reference.html#spygame.TiledTileLayer">[docs]</a><span class="k">class</span> <span class="nc">TiledTileLayer</span><span class="p">(</span><span class="n">TmxLayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper class for pytmx.pytmx.TiledTileLayer, which represents a &#39;normal&#39; tile layer in a tmx file.</span>
<span class="sd">    Reads in all tiles&#39; images into one Surface object so we can render the entire layer at once.</span>
<span class="sd">    Implements `render`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="n">tile_sprite_handler</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param pytmx.pytmx.TiledTileLayer pytmx_layer: the underlying pytmx TiledTileLayer</span>
<span class="sd">        :param pytmx.pytmx.TiledMap pytmx_tiled_map: the underlying pytmx TiledMap object (representing the tmx file)</span>
<span class="sd">        :param callable tile_sprite_handler: the callable that returns an ndarray, populated with TileSprite objects for storage in this layer</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">type_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">,</span> <span class="s2">&quot;none&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># get type mask of this layer from `type` property</span>
        <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

        <span class="c1"># an ndarray holding all single tiles (by x/y position) from this layer</span>
        <span class="c1"># non-existing tiles are not(!) stored in this ndarray and return None at the respective x/y position</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprites</span> <span class="o">=</span> <span class="n">tile_sprite_handler</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># update do_render indicator depending on some debug settings</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;do_render&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;true&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_DONT_RENDER_TILED_TILE_LAYERS</span><span class="p">))</span> <span class="ow">or</span> \
                         <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_COLLISION_TILES</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">render_order</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">properties</span><span class="p">[</span><span class="s2">&quot;render_order&quot;</span><span class="p">])</span>

        <span class="c1"># put this layer in one single Sprite that we can then blit on the display (with &#39;area=[some rect]&#39; to avoid drawing the entire layer each time)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># we are rendering this layer, need to store entire image in this structure</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_sprite_surface</span><span class="p">()</span>

<div class="viewcode-block" id="TiledTileLayer.build_sprite_surface"><a class="viewcode-back" href="../spygame_reference.html#spygame.TiledTileLayer.build_sprite_surface">[docs]</a>    <span class="k">def</span> <span class="nf">build_sprite_surface</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Builds the image (pygame.Surface) for this tile layer based on all found tiles in the layer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">surf</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Surface</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">),</span>
                              <span class="n">flags</span><span class="o">=</span><span class="n">pygame</span><span class="o">.</span><span class="n">SRCALPHA</span><span class="p">)</span>
        <span class="c1"># rendered collision layer</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_COLLISION_TILES</span><span class="p">):</span>
            <span class="c1"># red for normal collisions, light-blue for touch collisions</span>
            <span class="n">color</span> <span class="o">=</span> <span class="n">DEBUG_RENDER_COLLISION_TILES_COLOR_DEFAULT</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="n">DEBUG_RENDER_COLLISION_TILES_COLOR_OTHER</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image</span><span class="p">),</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">gid</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">tiles</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">iter_data</span><span class="p">()):</span>
                <span class="n">surf</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">(),</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">))</span>
                <span class="n">tile_props</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">get_tile_properties_by_gid</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{}</span>
                <span class="c1"># normal collision tiles</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;no_collision&quot;</span><span class="p">):</span>
                    <span class="n">pygame</span><span class="o">.</span><span class="n">draw</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">surf</span><span class="p">,</span> <span class="n">color</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">((</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">),</span>
                                                              <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">)),</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># &quot;normal&quot; layer (and no debug rendering)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">tiles</span><span class="p">():</span>
                <span class="n">surf</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="n">image</span><span class="o">.</span><span class="n">convert_alpha</span><span class="p">(),</span> <span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">))</span>

        <span class="n">pygame_sprite</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Sprite</span><span class="p">()</span>
        <span class="n">pygame_sprite</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">surf</span>
        <span class="n">pygame_sprite</span><span class="o">.</span><span class="n">rect</span> <span class="o">=</span> <span class="n">surf</span><span class="o">.</span><span class="n">get_rect</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">pygame_sprite</span></div>

<div class="viewcode-block" id="TiledTileLayer.render"><a class="viewcode-back" href="../spygame_reference.html#spygame.TiledTileLayer.render">[docs]</a>    <span class="k">def</span> <span class="nf">render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Blits a part of our Sprite&#39;s image onto the Display&#39;s Surface using the Display&#39;s offset attributes.</span>

<span class="sd">        :param Display display: the Display object to render on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">do_render</span><span class="p">,</span> <span class="s2">&quot;ERROR: TiledTileLayer.render() called but self.do_render is False!&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span><span class="p">,</span> <span class="n">Sprite</span><span class="p">),</span> <span class="s2">&quot;ERROR: TiledTileLayer.render() called but self.pygame_sprite is not a Sprite!&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span><span class="o">.</span><span class="n">rect</span><span class="p">)</span>  <span class="c1"># make a clone so we don&#39;t change the original Rect</span>
        <span class="c1"># apply the display offsets (camera)</span>
        <span class="n">r</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">r</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">r</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">width</span>
        <span class="n">r</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">display</span><span class="o">.</span><span class="n">height</span>
        <span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">blit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pygame_sprite</span><span class="o">.</span><span class="n">image</span><span class="p">,</span> <span class="n">dest</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">area</span><span class="o">=</span><span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="TiledTileLayer.capture_autobuilds"><a class="viewcode-back" href="../spygame_reference.html#spygame.TiledTileLayer.capture_autobuilds">[docs]</a>    <span class="k">def</span> <span class="nf">capture_autobuilds</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Captures all autobuild objects in this layer and returns them in a list of objects.</span>
<span class="sd">        Once an autobuild tile is found: searches neighboring tiles (starting to move right and down) for the same property and thus measures the object&#39;s</span>
<span class="sd">        width and height (in tiles).</span>

<span class="sd">        :return: list of generated autobuild objects</span>
<span class="sd">        :rtype: List[object]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># loop through each tile and look for ladder type property</span>
        <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">height</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">width</span><span class="p">):</span>
                <span class="n">tile_sprite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>  <span class="c1"># type: TileSprite</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tile_sprite</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">props</span> <span class="o">=</span> <span class="n">tile_sprite</span><span class="o">.</span><span class="n">tile_props</span>
                <span class="c1"># we hit the upper left corner of an autobuild object -&gt; spread out to find more neighboring similar tiles</span>
                <span class="n">ctor</span> <span class="o">=</span> <span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;autobuild_class&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ctor</span><span class="p">:</span>
                    <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctor</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="s2">&quot;ERROR: translation of tile (</span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">) property `autobuild_class` did not yield a defined class!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                    <span class="n">tile_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>  <span class="c1"># type: TileSprite</span>
                    <span class="n">tile_top</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="mi">1</span><span class="p">)]</span>  <span class="c1"># type: TileSprite</span>
                    <span class="k">if</span> <span class="n">tile_left</span> <span class="ow">and</span> <span class="n">tile_left</span><span class="o">.</span><span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;autobuild_class&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ctor</span> <span class="ow">or</span> \
                            <span class="n">tile_top</span> <span class="ow">and</span> <span class="n">tile_top</span><span class="o">.</span><span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;autobuild_class&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ctor</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="c1"># measure width and height</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">h</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">while</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">x2</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">width</span><span class="p">:</span>
                        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ts</span> <span class="ow">and</span> <span class="n">ts</span><span class="o">.</span><span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;autobuild_class&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ctor</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">w</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">x2</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="n">y2</span> <span class="o">=</span> <span class="n">y</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">while</span> <span class="kc">True</span> <span class="ow">and</span> <span class="n">y2</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">height</span><span class="p">:</span>
                        <span class="n">ts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[(</span><span class="n">x</span><span class="p">,</span> <span class="n">y2</span><span class="p">)]</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">ts</span> <span class="ow">and</span> <span class="n">ts</span><span class="o">.</span><span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;autobuild_class&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">ctor</span><span class="p">):</span>
                            <span class="k">break</span>
                        <span class="n">h</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="n">y2</span> <span class="o">+=</span> <span class="mi">1</span>

                    <span class="c1"># insert new object (all autobuild objects need to accept x, y, w, h in their constructors)</span>
                    <span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ctor</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">,</span> <span class="o">**</span><span class="n">props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;autobuild_kwargs&quot;</span><span class="p">,</span> <span class="p">{})))</span>
        <span class="k">return</span> <span class="n">objects</span></div>

<div class="viewcode-block" id="TiledTileLayer.get_overlapping_tiles"><a class="viewcode-back" href="../spygame_reference.html#spygame.TiledTileLayer.get_overlapping_tiles">[docs]</a>    <span class="k">def</span> <span class="nf">get_overlapping_tiles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the tile boundaries (which tiles does the sprite overlap with?).</span>

<span class="sd">        :param Sprite sprite: the sprite to test against</span>
<span class="sd">        :return: a tuple of (start-x. end-x, start-y, end-y) tile-coordinates to consider as overlapping with the given Sprite</span>
<span class="sd">        :rtype: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tile_start_x</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tile_end_x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">))</span>
        <span class="n">tile_start_y</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tile_end_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span><span class="p">,</span> <span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span></div>

<div class="viewcode-block" id="TiledTileLayer.collide_simple_with_sprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.TiledTileLayer.collide_simple_with_sprite">[docs]</a>    <span class="k">def</span> <span class="nf">collide_simple_with_sprite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">collision_detector</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collides a Sprite (that only obeys simple physics rules) with a TiledTileLayer and solves all detected collisions.</span>
<span class="sd">        The Sprite needs to have the properties vx and vy, which are interpreted as the Sprite&#39;s velocity.</span>
<span class="sd">        Ignores slopes.</span>

<span class="sd">        :param Sprite sprite: the Sprite to test for collisions against a TiledTileLayer</span>
<span class="sd">        :param callable collision_detector: the collision detector method to use (this is set in the Sprite&#39;s Stage&#39;s options)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span><span class="p">,</span> <span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_overlapping_tiles</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>

        <span class="c1"># require the Sprite to have a vx/vy (meaning handle its own physics)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="s2">&quot;vx&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="s2">&quot;vy&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">vx</span> <span class="o">&gt;</span> <span class="n">sprite</span><span class="o">.</span><span class="n">vy</span><span class="p">:</span>
                <span class="n">xy</span> <span class="o">=</span> <span class="s2">&quot;x&quot;</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">vx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">xy</span> <span class="o">=</span> <span class="s2">&quot;y&quot;</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">vy</span>
        <span class="c1"># if not, we assume 0.0 velocity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xy</span> <span class="o">=</span> <span class="s2">&quot;y&quot;</span>
            <span class="n">v</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># very simple algo: look through tile list (in no particular order) and return first tile that collides</span>
        <span class="c1"># None if no colliding tile found</span>
        <span class="k">for</span> <span class="n">tile_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">tile_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">tile_sprite</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">tile_sprite</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">collision_detector</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tile_sprite</span><span class="p">,</span> <span class="n">collision_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                         <span class="n">direction</span><span class="o">=</span><span class="n">xy</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="o">=</span><span class="n">v</span><span class="p">,</span> <span class="n">original_pos</span><span class="o">=</span><span class="p">(</span><span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">col</span>
        <span class="k">return</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="TileSprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.TileSprite">[docs]</a><span class="k">class</span> <span class="nc">TileSprite</span><span class="p">(</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class used by TiledTileLayer objects to have a means of representing single tiles in terms of Sprite objects</span>
<span class="sd">    (used for collision detector function).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">tile_props</span><span class="p">,</span> <span class="n">rect</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param TiledTileLayer layer: the TiledTileLayer object to which this tile belongs</span>
<span class="sd">        :param pytmx.pytmx.TiledMap pytmx_tiled_map: the tmx tiled-map object to which this tile belongs</span>
<span class="sd">                                                     (useful to have to look up certain map-side properties, e.g. tilewidth/height)</span>
<span class="sd">        :param int id_: tthe ID of the tile in the layer</span>
<span class="sd">        :param dict tile_props: the properties dict of this tile (values already translated into python types)</span>
<span class="sd">        :param Union[pygame.Rect,None] rect: the pygame.Rect representing the position and size of the tile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">width_height</span><span class="o">=</span><span class="p">(</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tiled_tile_layer</span> <span class="o">=</span> <span class="n">layer</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span> <span class="o">=</span> <span class="n">pytmx_tiled_map</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile</span> <span class="o">=</span> <span class="n">id_</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tile_props</span> <span class="o">=</span> <span class="n">tile_props</span>
        <span class="c1"># add the `dockable` type to all tiles</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;dockable&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="SlopedTileSprite"><a class="viewcode-back" href="../spygame_reference.html#spygame.SlopedTileSprite">[docs]</a><span class="k">class</span> <span class="nc">SlopedTileSprite</span><span class="p">(</span><span class="n">TileSprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    a TileSprite that supports storing some temporary calculations about a slope in the tile and its relation to a Sprite that&#39;s currently colliding</span>
<span class="sd">    with the TileSprite</span>
<span class="sd">    - used by the PlatformerPhysics Component when detecting and handling slope collisions</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">tile_props</span><span class="p">,</span> <span class="n">rect</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param TiledTileLayer layer: the TiledTileLayer object to which this tile belongs</span>
<span class="sd">        :param pytmx.pytmx.TiledMap pytmx_tiled_map: the tmx tiled-map object to which this tile belongs</span>
<span class="sd">                                                     (useful to have to look up certain map-side properties, e.g. tilewidth/height)</span>
<span class="sd">        :param int id_: tthe ID of the tile in the layer</span>
<span class="sd">        :param dict tile_props: the properties dict of this tile (values already translated into python types)</span>
<span class="sd">        :param Union[pygame.Rect,None] rect: the pygame.Rect representing the position and size of the tile</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="n">id_</span><span class="p">,</span> <span class="n">tile_props</span><span class="p">,</span> <span class="n">rect</span><span class="p">)</span>
        <span class="c1"># slope properties of the tile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;slope&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># the slope property of the tile in the tmx file (inverse steepness (1/m in y=mx+b) of the line that defines the slope)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;offset&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># the offset property of the tile in the tmx file (in px (b in y=mx+b))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_full</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">==</span> <span class="mf">0.0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">)</span>  <span class="c1"># is this a full collision tile?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>  <span class="c1"># store our highest y-value (height of this tile)</span>

<div class="viewcode-block" id="SlopedTileSprite.get_y"><a class="viewcode-back" href="../spygame_reference.html#spygame.SlopedTileSprite.get_y">[docs]</a>    <span class="k">def</span> <span class="nf">get_y</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the y value (in normal cartesian y-direction (positive values on up axis)) for a given x-value.</span>

<span class="sd">        :param int x: the x-value (x=0 for left edge of tile x=tilewidth for right edge of tile)</span>
<span class="sd">        :return: the calculated y-value</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># y = mx + b</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">*</span> <span class="nb">min</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_x</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">offset</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span></div>

<div class="viewcode-block" id="SlopedTileSprite.sloped_xy_pull"><a class="viewcode-back" href="../spygame_reference.html#spygame.SlopedTileSprite.sloped_xy_pull">[docs]</a>    <span class="k">def</span> <span class="nf">sloped_xy_pull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a so-called xy-pull on a Sprite object moving in x-direction in this sloped tile.</span>
<span class="sd">        An xy-pull is a change in the y-coordinate because of the x-movement (sliding up/down a slope while moving left/right).</span>

<span class="sd">        :param Sprite sprite: the Sprite object that&#39;s moving on the slope</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="c1"># the local x value for the Sprite on the tile&#39;s internal x-axis (0=left edge of tile)</span>
        <span class="n">x_local</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
        <span class="c1"># the absolute y-position that we will force the sprite into</span>
        <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">x_local</span><span class="p">)</span> <span class="o">-</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TiledObjectGroup"><a class="viewcode-back" href="../spygame_reference.html#spygame.TiledObjectGroup">[docs]</a><span class="k">class</span> <span class="nc">TiledObjectGroup</span><span class="p">(</span><span class="n">TmxLayer</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper class for the pytmx.TiledObjectGroup class, which represents an object layer in a tmx file.</span>
<span class="sd">    Generates all GameObjects specified in the layer (a.g. the agent, enemies, etc..).</span>
<span class="sd">    Implements `render` by looping through all GameObjects and rendering their Sprites one by one.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pytmx_layer</span><span class="p">:</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledObjectGroup</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">:</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">pytmx</span><span class="o">.</span><span class="n">TiledMap</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">pytmx_layer</span><span class="p">,</span> <span class="n">pytmx_tiled_map</span><span class="p">)</span>

        <span class="c1"># create the sprite group for this layer (all GameObjects will be added to this group)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite_group</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">sprite</span><span class="o">.</span><span class="n">Group</span><span class="p">()</span>

        <span class="c1"># construct each object from the layer (as a Sprite) and add them to the sprite_group of this layer</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="p">:</span>
            <span class="c1"># allow objects in the tmx file to be &#39;switched-off&#39; by making them invisible</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">obj</span><span class="o">.</span><span class="n">visible</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">obj_props</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">properties</span>

            <span class="c1"># if the (Sprite) class of the object is given, construct it here using its c&#39;tor</span>
            <span class="c1"># - classes are given as strings: e.g. sypg.Sprite, vikings.Viking, Agent (Agent class would be in __main__ module)</span>
            <span class="c1"># - first look in the tile&#39;s properties for the &#39;class&#39; field, only then try the &#39;type&#39; field directly of the object (manually given by designer)</span>
            <span class="n">class_global</span> <span class="o">=</span> <span class="n">obj_props</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;class&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span>
            <span class="k">if</span> <span class="n">class_global</span><span class="p">:</span>
                <span class="n">ctor</span> <span class="o">=</span> <span class="n">convert_type</span><span class="p">(</span><span class="n">class_global</span><span class="p">,</span> <span class="n">force_class</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctor</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="s2">&quot;ERROR: python class `</span><span class="si">{}</span><span class="s2">` for object in object-layer `</span><span class="si">{}</span><span class="s2">` not defined!&quot;</span><span class="o">.</span>\
                    <span class="nb">format</span><span class="p">(</span><span class="n">class_global</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

                <span class="c1"># get other kwargs for the Sprite&#39;s c&#39;tor</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">get_kwargs_from_obj_props</span><span class="p">(</span><span class="n">obj_props</span><span class="p">)</span>

                <span class="c1"># generate the Sprite</span>
                <span class="n">sprite</span> <span class="o">=</span> <span class="n">ctor</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1">## add the do_render and render_order to the new instance</span>
                <span class="c1">#sprite.do_render = (obj_props.get(&quot;do_render&quot;, &quot;true&quot;) == &quot;true&quot;)  # the default for objects is true</span>
                <span class="c1">#if sprite.do_render:</span>
                <span class="c1">#    sprite.render_order = int(obj_props.get(&quot;render_order&quot;, 50))  # the default for objects is 50</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sprite_group</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span></div>


<div class="viewcode-block" id="Collision"><a class="viewcode-back" href="../spygame_reference.html#spygame.Collision">[docs]</a><span class="k">class</span> <span class="nc">Collision</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple feature object that stores collision properties for collisions between two objects or between an object and a TiledTileLayer.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite1</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># hook into the first Sprite participating in this collision</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite2</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># hook into the second Sprite participating in this collision (this could be a TileSprite)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># True if a collision happened (usually True)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># how much do we have to move sprite1 to separate the two Sprites? (always negative)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># abs(distance)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># NOT SURE: the impulse of the collision on some mass (used for pushing heavy objects)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># x-component of the collision normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="mf">0.0</span>  <span class="c1"># y-component of the collision normal</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># (-distance * normal_x, -distance * normal_y) how much to we have to change x/y values for rect to separate the two sprites</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># None, &#39;x&#39; or &#39;y&#39; (direction in which we measure the collision; the other direction is ignored)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># velocity direction component (e.g. direction==&#39;x&#39; veloc==5 -&gt; moving right, veloc==-10.4 -&gt; moving left)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">original_pos</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>  <span class="c1"># the original x/y-position of sprite1 before the move that lead to the collision happened</span>

<div class="viewcode-block" id="Collision.invert"><a class="viewcode-back" href="../spygame_reference.html#spygame.Collision.invert">[docs]</a>    <span class="k">def</span> <span class="nf">invert</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Inverts this Collision in place to yield the Collision for the case that the two Sprites are switched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># flip the sprites</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sprite2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprite2</span> <span class="o">=</span> <span class="n">tmp</span>
        <span class="c1"># invert the normal and separate (leave distance negative, leave magnitude positive)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">normal_y</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separate</span> <span class="o">=</span> <span class="p">[</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># the direction veloc</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">direction_veloc</span>
        <span class="k">return</span> <span class="bp">self</span></div></div>


<span class="c1">## OBSOLETE CLASS</span>
<span class="c1">#class PlatformerCollision(Collision):</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#    A collision object that can be used by PlatformerPhysics to handle Collisions.</span>
<span class="c1">#    &quot;&quot;&quot;</span>
<span class="c1">#</span>
<span class="c1">#    def __init__(self):</span>
<span class="c1">#        super().__init__()</span>
<span class="c1">#        self.impact = 0.0  # the impulse of the collision on some mass (used for pushing heavy objects)</span>

<span class="c1">#        # OBSOLETE: these should all be no longer needed</span>
<span class="c1">#        # self.slope = False  # whether this is a collision with a sloped TileSprite of a TiledTileLayer</span>
                            <span class="c1"># (will also be False if obj1 collides with the Tile&#39;s rect, but obj1 is still in air (slope))</span>
<span class="c1">#        # self.slope_y_pull = 0  # amount of y that Sprite has to move up (negative) or down (positive) because of the collision (with a slope)</span>
<span class="c1">#        #self.slope_up_down = 0  # 0=no slope, -1=down slope, 1 = up slope</span>


<div class="viewcode-block" id="Component"><a class="viewcode-back" href="../spygame_reference.html#spygame.Component">[docs]</a><span class="k">class</span> <span class="nc">Component</span><span class="p">(</span><span class="n">GameObject</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Component can be added to and removed from other GameObjects.</span>
<span class="sd">    Use &quot;extend&quot; to make a Component&#39;s method be callable directly from the owning GameObject.</span>

<span class="sd">    :param str name: the name of the component (the name can be used to retrieve any GameObject&#39;s components via the [GameObject].components dict)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># to be set by Entity when this component gets added</span>

<div class="viewcode-block" id="Component.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.Component.added">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called when the component is added to a GameObject.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Component.removed"><a class="viewcode-back" href="../spygame_reference.html#spygame.Component.removed">[docs]</a>    <span class="k">def</span> <span class="nf">removed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called when the component is removed from a GameObject.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Component.extend"><a class="viewcode-back" href="../spygame_reference.html#spygame.Component.extend">[docs]</a>    <span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extends the given method (has to take self as 1st param) onto the GameObject, so that this method can be called directly from the GameObject.</span>
<span class="sd">        The extended method will take two self&#39;s (0=Component, 1=GameObject), thus selfs should be called &#39;comp&#39; and &#39;game_object&#39; OR &#39;self&#39; and &#39;game_object&#39;</span>

<span class="sd">        :param callable method: method, which to make callable from within the owning GameObject</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="s2">&quot;ERROR: need self.game_object in order to extend the method to that GameObject!&quot;</span>

        <span class="c1"># keep the original method under a different name (just in case it&#39;s still needed by the overwriting method)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="s2">&quot;_super_&quot;</span> <span class="o">+</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>

        <span class="c1"># use the MethodType function to bind the given method function to only this object (not any other instances of the GameObject&#39;s class)</span>
        <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">method</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">types</span><span class="o">.</span><span class="n">MethodType</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="Brain"><a class="viewcode-back" href="../spygame_reference.html#spygame.Brain">[docs]</a><span class="k">class</span> <span class="nc">Brain</span><span class="p">(</span><span class="n">Component</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A generic Brain class that has a command dict for other classes to be able to look up what the brain currently wants.</span>
<span class="sd">    Also has a main-switch to activate/deactivate the Brain.</span>
<span class="sd">    Should implement `tick` method and set self.commands each tick.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;brain&quot;</span><span class="p">,</span> <span class="n">commands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># main switch: if False, we don&#39;t do anything</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">commands</span><span class="p">:</span>
            <span class="n">commands</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">commands</span> <span class="o">=</span> <span class="p">{</span><span class="n">command</span><span class="p">:</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">command</span> <span class="ow">in</span> <span class="n">commands</span><span class="p">}</span>  <span class="c1"># the commands coming from the brain (e.g. `jump`, `sword`, `attack`, etc..)</span>

<div class="viewcode-block" id="Brain.reset"><a class="viewcode-back" href="../spygame_reference.html#spygame.Brain.reset">[docs]</a>    <span class="k">def</span> <span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets all commands to False.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="Brain.activate"><a class="viewcode-back" href="../spygame_reference.html#spygame.Brain.activate">[docs]</a>    <span class="k">def</span> <span class="nf">activate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes this Brain active: we will react to the GameLoop&#39;s keyboard events.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Brain.deactivate"><a class="viewcode-back" href="../spygame_reference.html#spygame.Brain.deactivate">[docs]</a>    <span class="k">def</span> <span class="nf">deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes this Brain inactive: we will not(!) react to the GameLoop&#39;s keyboard events (no exceptions).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>  <span class="c1"># set all commands to False</span></div>

<div class="viewcode-block" id="Brain.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.Brain.tick">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Needs to be called by the GameObject at some point during the GameObject&#39;s `tick` method.</span>

<span class="sd">        :param GameLoop game_loop: the currently playing GameLoop object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="SimpleHumanBrain"><a class="viewcode-back" href="../spygame_reference.html#spygame.SimpleHumanBrain">[docs]</a><span class="k">class</span> <span class="nc">SimpleHumanBrain</span><span class="p">(</span><span class="n">Brain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    looks for keys that match our stored commands and sets these commands to True if the key is pressed, False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
<div class="viewcode-block" id="SimpleHumanBrain.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.SimpleHumanBrain.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="SimpleHumanBrain.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.SimpleHumanBrain.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Needs to be called by the GameObject at some point during the GameObject&#39;s `tick` method.</span>
<span class="sd">        Translates all keys from the GameLoops&#39;s KeyboardInputs object into our command dict.</span>

<span class="sd">        :param GameLoop game_loop: the currently playing GameLoop object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># main switch is set to OFF</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># first reset everything to False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># current animation does not block: normal commands possible</span>
        <span class="k">for</span> <span class="n">key_code</span><span class="p">,</span> <span class="n">is_pressed</span> <span class="ow">in</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># look up the str description of the key</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">descriptions</span><span class="p">[</span><span class="n">key_code</span><span class="p">]</span>
            <span class="c1"># look up the key-to-command translation rules</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">desc</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_pressed</span></div></div>


<div class="viewcode-block" id="KeyboardBrainTranslation"><a class="viewcode-back" href="../spygame_reference.html#spygame.KeyboardBrainTranslation">[docs]</a><span class="k">class</span> <span class="nc">KeyboardBrainTranslation</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to represent a relationship between a pressed key and a command (or two commands)</span>
<span class="sd">    The normal relationship is: [some key]: when pressed -&gt; [command] is True; when not pressed -&gt; [command] is False</span>
<span class="sd">    But other, more complex relationships are supported as well.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># key-to-command flags</span>
    <span class="n">NORMAL</span> <span class="o">=</span> <span class="mh">0x0</span>  <span class="c1"># normal: when key down -&gt; command is True (this is essentially: DOWN_LEAVE_UP_LEAVE)</span>
    <span class="n">DOWN_ONE_TICK</span> <span class="o">=</span> <span class="mh">0x1</span>  <span class="c1"># when key down -&gt; command is True for only one tick (after that, key needs to be released to fire another command)</span>
    <span class="c1"># DOWN_LEAVE = 0x2  # when key down -&gt; command is x (and stays x as long as key is down)</span>
    <span class="n">UP_ONE_TICK</span> <span class="o">=</span> <span class="mh">0x2</span>  <span class="c1"># when key up -&gt; command is y for one frame</span>

    <span class="c1"># can only execute command if an animation is currently not playing or just completed (e.g. swinging sword)</span>
    <span class="n">BLOCK_REPEAT_UNTIL_ANIM_COMPLETE</span> <span class="o">=</span> <span class="mh">0x4</span>
    <span class="c1"># when key down -&gt; command is x (and stays x); when key gets released -&gt; command is y for one frame (BUT only after a certain animation has been completed)</span>
    <span class="n">BLOCK_OTHER_CMD_UNTIL_ANIM_COMPLETE</span> <span class="o">=</span> <span class="mh">0x8</span>

    <span class="c1"># some flags needed to describe the state for the DOWN_LEAVE_UP_ONE_TICK_WAIT_FOR_ANIM type of key-command-translation</span>
    <span class="n">STATE_NONE</span> <span class="o">=</span> <span class="mh">0x0</span>
    <span class="n">STATE_CHARGING</span> <span class="o">=</span> <span class="mh">0x1</span>  <span class="c1"># we are currently charging after key-down (when fully charged, we are ready to execute upon other_command)</span>
    <span class="n">STATE_FULLY_CHARGED</span> <span class="o">=</span> <span class="mh">0x2</span>  <span class="c1"># if set, we are fully charged and we will execute other_command as soon as the key is released</span>
    <span class="n">STATE_CMD_RECEIVED</span> <span class="o">=</span> <span class="mh">0x4</span>  <span class="c1"># if set, the key for the other_command has already been released, but we are still waiting for the charging to be complete</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">command</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">other_command</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">animation_to_complete</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str key: the key&#39;s description, e.g. `up` for K_UP</span>
<span class="sd">        :param str command: the `main` command&#39;s description; can be any string e.g. `fire`, `jump`</span>
<span class="sd">        :param int flags: keyboard-command behavior flags</span>
<span class="sd">        :param str other_command: a possible second command associated with the key (when key is released, e.g. `release_bow`)</span>
<span class="sd">        :param Union[list,str] animation_to_complete: animation(s) that needs to be completed in order for the other_command to be executable</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">key</span> <span class="o">=</span> <span class="n">key</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">command</span> <span class="o">=</span> <span class="n">command</span>

        <span class="k">assert</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">BLOCK_REPEAT_UNTIL_ANIM_COMPLETE</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">BLOCK_OTHER_CMD_UNTIL_ANIM_COMPLETE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> \
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">animation_to_complete</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">animation_to_complete</span><span class="p">,</span> <span class="nb">set</span><span class="p">),</span> <span class="s2">&quot;ERROR: animation_to_complete needs to be of type str or set!&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">other_command</span> <span class="o">=</span> <span class="n">other_command</span>
        <span class="c1"># this could be a set of anims (one of them has to be completed)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animation_to_complete</span> <span class="o">=</span> <span class="p">{</span><span class="n">animation_to_complete</span><span class="p">}</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">animation_to_complete</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">else</span> <span class="n">animation_to_complete</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the current state for the other_command (charging, charged, cmd_received)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_disabled</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># set to True for temporarily blocking this translation</span></div>


<div class="viewcode-block" id="AnimationLinkedBrain"><a class="viewcode-back" href="../spygame_reference.html#spygame.AnimationLinkedBrain">[docs]</a><span class="k">class</span> <span class="nc">AnimationLinkedBrain</span><span class="p">(</span><span class="n">Brain</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Brain that is linked to an Animation component and can thus subscribe to events triggered by that Component.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;brain&quot;</span><span class="p">,</span> <span class="n">commands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">commands</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># our GameObject&#39;s Animation Component (if any); needed for animation flags</span>

<div class="viewcode-block" id="AnimationLinkedBrain.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.AnimationLinkedBrain.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># search for an Animation component of our game_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;animation&quot;</span><span class="p">)</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="p">,</span> <span class="n">Animation</span><span class="p">),</span>\
            <span class="s2">&quot;ERROR: </span><span class="si">{}</span><span class="s2"> needs its GameObject to also have a Component called `animation` that&#39;s of type Animation!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="HumanPlayerBrain"><a class="viewcode-back" href="../spygame_reference.html#spygame.HumanPlayerBrain">[docs]</a><span class="k">class</span> <span class="nc">HumanPlayerBrain</span><span class="p">(</span><span class="n">AnimationLinkedBrain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An AnimationLinkedBrain that handles agent control (via the GameLoops keyboard registry).</span>
<span class="sd">    Supports special keyboard-&gt;command translations (e.g. key down -&gt; command A for one tick; key up -&gt; command B for one tick).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;brain&quot;</span><span class="p">,</span> <span class="n">key_brain_translations</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str name: the name of this component</span>
<span class="sd">        :param Union[list,None] key_brain_translations: list of KeyboardBrainTranslation objects or None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># stores the values of the keyboard_inputs in the previous tick (to catch changes in the keyboard state)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_prev</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># build our key_brain_translation dict to translate key inputs into commands</span>
        <span class="k">if</span> <span class="n">key_brain_translations</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">key_brain_translations</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">key_brain_translations</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_translations</span><span class="p">(</span><span class="n">key_brain_translations</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">animation_prev</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_paralyzed</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># is this brain paralyzed? (e.g. when agent is dizzy)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paralyzes_exceptions</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># keys that are still ok to be handled, even if paralyzed</span>

<div class="viewcode-block" id="HumanPlayerBrain.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.HumanPlayerBrain.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">added</span><span class="p">()</span>
        <span class="c1"># subscribe to anim.ends events</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;anim.ends&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;anim_ends&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="HumanPlayerBrain.anim_ends"><a class="viewcode-back" href="../spygame_reference.html#spygame.HumanPlayerBrain.anim_ends">[docs]</a>    <span class="k">def</span> <span class="nf">anim_ends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">anim</span><span class="p">,</span> <span class="n">anim_new</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="HumanPlayerBrain.add_translations"><a class="viewcode-back" href="../spygame_reference.html#spygame.HumanPlayerBrain.add_translations">[docs]</a>    <span class="k">def</span> <span class="nf">add_translations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key_brain_translations</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single or more KeyboardBrainTranslation object to our dict.</span>

<span class="sd">        :param Union[KeyboardBrainTranslation,str,dict,tuple] key_brain_translations: the keyboard-to-command translation to be added to this Brain</span>
<span class="sd">         (can be represented in different ways; see code)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># list: re-call this method one-by-one</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_brain_translations</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">trans</span> <span class="ow">in</span> <span class="n">key_brain_translations</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_translations</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span>
        <span class="c1"># str: key = command</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_brain_translations</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_translations</span><span class="p">(</span><span class="n">KeyboardBrainTranslation</span><span class="p">(</span><span class="n">key_brain_translations</span><span class="p">,</span> <span class="n">key_brain_translations</span><span class="p">))</span>
        <span class="c1"># tuple: pass as positional args into c&#39;tor (key,cmd,flags,other_cmd,anim_to_be_completed)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_brain_translations</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_translations</span><span class="p">(</span><span class="n">KeyboardBrainTranslation</span><span class="p">(</span><span class="o">*</span><span class="n">key_brain_translations</span><span class="p">))</span>
        <span class="c1"># dict: pass as kwargs into c&#39;tor</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_brain_translations</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_translations</span><span class="p">(</span><span class="n">KeyboardBrainTranslation</span><span class="p">(</span><span class="o">**</span><span class="n">key_brain_translations</span><span class="p">))</span>
        <span class="c1"># KeyboardBrainTranslation: take as is and store</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key_brain_translations</span><span class="p">,</span> <span class="n">KeyboardBrainTranslation</span><span class="p">):</span>
            <span class="k">assert</span> <span class="n">key_brain_translations</span><span class="o">.</span><span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_brain_translations</span><span class="p">,</span> <span class="s2">&quot;ERROR: key </span><span class="si">{}</span><span class="s2"> already in key_brain_translations dict!&quot;</span><span class="o">.</span> \
                <span class="nb">format</span><span class="p">(</span><span class="n">key_brain_translations</span><span class="o">.</span><span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">key_brain_translations</span><span class="p">[</span><span class="n">key_brain_translations</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">key_brain_translations</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_prev</span><span class="p">[</span><span class="n">key_brain_translations</span><span class="o">.</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># create the entry for the key (for faster lookup later without [dict].get())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">key_brain_translations</span><span class="o">.</span><span class="n">command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">key_brain_translations</span><span class="o">.</span><span class="n">other_command</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">key_brain_translations</span><span class="o">.</span><span class="n">other_command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># not supported type</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;ERROR: key_brain_translations parameter has wrong type; needs to be str, KeyboardBrainTranslation, tuple, or dict!&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="HumanPlayerBrain.remove_translation"><a class="viewcode-back" href="../spygame_reference.html#spygame.HumanPlayerBrain.remove_translation">[docs]</a>    <span class="k">def</span> <span class="nf">remove_translation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a single KeyboardBrainTranslation object to our dict.</span>

<span class="sd">        :param str key: the key (str) to be removed from our key-to-command translation dict</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">key_brain_translations</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

    <span class="c1">#def enable_translation(self, key):</span>
    <span class="c1">#    trans = self.key_brain_translations.get(key)</span>
    <span class="c1">#    if trans:</span>
    <span class="c1">#        trans.is_disabled = False</span>

    <span class="c1">#def disable_translation(self, key):</span>
    <span class="c1">#    trans = self.key_brain_translations.get(key)</span>
    <span class="c1">#    if trans:</span>
    <span class="c1">#        trans.is_disabled = True</span>

<div class="viewcode-block" id="HumanPlayerBrain.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.HumanPlayerBrain.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">:</span> <span class="n">GameLoop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Needs to be called by the GameObject at some point during the GameObject&#39;s `tick` method.</span>
<span class="sd">        Translates all keys from the GameLoops&#39;s KeyboardInputs object into our command dict.</span>

<span class="sd">        :param GameLoop game_loop: the currently playing GameLoop object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># main switch is set to OFF</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_active</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># support for `paralyzes` flag and `paralyzes_exceptions` is built into this class</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_paralyzed</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">Animation</span><span class="o">.</span><span class="n">get_flag</span><span class="p">(</span><span class="s2">&quot;paralyzes&quot;</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paralyzes_exceptions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;paralyzes_exceptions&quot;</span><span class="p">)</span>

        <span class="c1"># first reset everything to False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="c1"># current animation does not block: normal commands possible</span>
        <span class="k">for</span> <span class="n">key_code</span><span class="p">,</span> <span class="n">is_pressed</span> <span class="ow">in</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">keyboard_registry</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># look up the str description of the key</span>
            <span class="n">desc</span> <span class="o">=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">descriptions</span><span class="p">[</span><span class="n">key_code</span><span class="p">]</span>
            <span class="c1"># look up the key-to-command translation rules</span>
            <span class="n">trans</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">key_brain_translations</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">desc</span><span class="p">)</span>  <span class="c1"># type: KeyboardBrainTranslation</span>
            <span class="c1"># not a known key to this Brain OR this translation is (temporarily) disabled</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">trans</span> <span class="ow">or</span> <span class="n">trans</span><span class="o">.</span><span class="n">is_disabled</span> <span class="ow">or</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">is_paralyzed</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">paralyzes_exceptions</span> <span class="ow">or</span> <span class="n">desc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">paralyzes_exceptions</span><span class="p">)):</span>
                <span class="k">continue</span>
            <span class="c1"># normal translation</span>
            <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">flags</span> <span class="o">==</span> <span class="n">trans</span><span class="o">.</span><span class="n">NORMAL</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">trans</span><span class="o">.</span><span class="n">command</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_pressed</span>
            <span class="c1"># key is currently down</span>
            <span class="k">elif</span> <span class="n">is_pressed</span><span class="p">:</span>
                <span class="c1"># if we don&#39;t repeat the command -&gt; check whether this press is new and only then set the command</span>
                <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">DOWN_ONE_TICK</span><span class="p">:</span>
                    <span class="c1"># key was previously up -&gt; new press</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_prev</span><span class="p">[</span><span class="n">desc</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                        <span class="c1"># check for condition on the current anim (don&#39;t set command if a certain anim is currently playing)</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">BLOCK_REPEAT_UNTIL_ANIM_COMPLETE</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> \
                                <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="o">.</span><span class="n">animation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">trans</span><span class="o">.</span><span class="n">animation_to_complete</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">trans</span><span class="o">.</span><span class="n">command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># NORMAL: down -&gt; leave command=True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">trans</span><span class="o">.</span><span class="n">command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># key is currently up</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we fire a single-tick other_command if the key has just been released</span>
                <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">UP_ONE_TICK</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_prev</span><span class="p">[</span><span class="n">desc</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="c1"># we have an anim condition on other_command</span>
                    <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">BLOCK_OTHER_CMD_UNTIL_ANIM_COMPLETE</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">STATE_FULLY_CHARGED</span><span class="p">:</span>
                            <span class="c1"># fire command and reset all state flags</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">trans</span><span class="o">.</span><span class="n">other_command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                            <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="c1"># set the STATE_CMD_RECEIVED flag and wait for the charging to be complete</span>
                        <span class="k">elif</span> <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">STATE_CHARGING</span><span class="p">:</span>
                            <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">|=</span> <span class="n">trans</span><span class="o">.</span><span class="n">STATE_CMD_RECEIVED</span>
                    <span class="c1"># no anim condition</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">trans</span><span class="o">.</span><span class="n">other_command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="c1"># if we are waiting for other_command to be charged -&gt; check whether we have to keep the main command active (until charging is done)</span>
                <span class="k">elif</span> <span class="n">trans</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">BLOCK_OTHER_CMD_UNTIL_ANIM_COMPLETE</span> <span class="ow">and</span> <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">STATE_CHARGING</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">trans</span><span class="o">.</span><span class="n">command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="c1"># check for other command dependency on animation and start charging (or reset state)</span>
            <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">BLOCK_OTHER_CMD_UNTIL_ANIM_COMPLETE</span><span class="p">:</span>
                <span class="c1"># we are currently charging (playing the animation)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="o">.</span><span class="n">animation</span> <span class="ow">in</span> <span class="n">trans</span><span class="o">.</span><span class="n">animation_to_complete</span><span class="p">:</span>
                    <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">|=</span> <span class="n">trans</span><span class="o">.</span><span class="n">STATE_CHARGING</span>
                    <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">trans</span><span class="o">.</span><span class="n">STATE_FULLY_CHARGED</span>
                <span class="c1"># we are just done with the animation -&gt; set to fully charged</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">animation_prev</span> <span class="ow">in</span> <span class="n">trans</span><span class="o">.</span><span class="n">animation_to_complete</span><span class="p">:</span>
                    <span class="c1"># if we have already got the command -&gt; fire it now</span>
                    <span class="k">if</span> <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">&amp;</span> <span class="n">trans</span><span class="o">.</span><span class="n">STATE_CMD_RECEIVED</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">trans</span><span class="o">.</span><span class="n">command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="n">trans</span><span class="o">.</span><span class="n">other_command</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="c1"># otherwise, update the charging state and keep waiting for the key to be released</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">|=</span> <span class="n">trans</span><span class="o">.</span><span class="n">STATE_FULLY_CHARGED</span>
                        <span class="n">trans</span><span class="o">.</span><span class="n">state_other_command</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">trans</span><span class="o">.</span><span class="n">STATE_CHARGING</span>

            <span class="c1"># update keyboard_prev dict</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_prev</span><span class="p">[</span><span class="n">desc</span><span class="p">]</span> <span class="o">=</span> <span class="n">is_pressed</span>
            <span class="c1"># store previous animation</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">animation_prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="o">.</span><span class="n">animation</span></div></div>


<div class="viewcode-block" id="AIBrain"><a class="viewcode-back" href="../spygame_reference.html#spygame.AIBrain">[docs]</a><span class="k">class</span> <span class="nc">AIBrain</span><span class="p">(</span><span class="n">AnimationLinkedBrain</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An AnimationLinkedBrain that can handle simple left/right logic for 2D platformer monsters.</span>
<span class="sd">    The brain will take care of avoiding cliffs, but other than that always just walk from left to right and back.</span>
<span class="sd">    Overwrite this to implement more complex behaviors in the tick method.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;brain&quot;</span><span class="p">,</span> <span class="n">commands</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">commands</span><span class="p">:</span>
            <span class="n">commands</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">,</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">commands</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flipped</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># if True: character is turning left</span>

<div class="viewcode-block" id="AIBrain.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.AIBrain.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">added</span><span class="p">()</span>

        <span class="c1"># simple behavior: change our direction if we run into a wall</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;bump.right&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bumped&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;bump.left&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;bumped&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="AIBrain.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.AIBrain.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Needs to be called by the GameObject at some point during the GameObject&#39;s `tick` method.</span>

<span class="sd">        :param GameLoop game_loop: the currently playing GameLoop object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_anim</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">Animation</span><span class="o">.</span><span class="n">get_flag</span><span class="p">(</span><span class="s2">&quot;paralyzes&quot;</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># look for edges ahead -&gt; then change direction if one is detected</span>
        <span class="c1"># - makes sure an enemy character does not fall off a cliff</span>
        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">frame</span> <span class="o">%</span> <span class="mi">3</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">check_cliff_ahead</span><span class="p">())</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="n">obj</span><span class="o">.</span><span class="n">x_max</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">toggle_direction</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;left&quot;</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flipped</span> <span class="k">else</span> <span class="s2">&quot;right&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="AIBrain.bumped"><a class="viewcode-back" href="../spygame_reference.html#spygame.AIBrain.bumped">[docs]</a>    <span class="k">def</span> <span class="nf">bumped</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">toggle_direction</span><span class="p">()</span></div>

<div class="viewcode-block" id="AIBrain.toggle_direction"><a class="viewcode-back" href="../spygame_reference.html#spygame.AIBrain.toggle_direction">[docs]</a>    <span class="k">def</span> <span class="nf">toggle_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes the current direction (left to right or vice-versa)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flipped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flipped</span> <span class="ow">is</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="AIBrain.check_cliff_ahead"><a class="viewcode-back" href="../spygame_reference.html#spygame.AIBrain.check_cliff_ahead">[docs]</a>    <span class="k">def</span> <span class="nf">check_cliff_ahead</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether there is a cliff ahead (returns true if yes).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="n">tile_w</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">tilewidth</span>
        <span class="n">tile_h</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">tileheight</span>
        <span class="c1"># check below character (c=character sprite, _=locateObject (a stripe with x=x width=w-6 and height=3))</span>
        <span class="c1"># ccc    -&gt; walking direction</span>
        <span class="c1"># ccc</span>
        <span class="c1">#  _</span>
        <span class="n">w</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tile_w</span> <span class="o">*</span> <span class="mf">1.5</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">locate</span><span class="p">((</span><span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">tile_w</span> <span class="o">-</span> <span class="n">w</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flipped</span> <span class="k">else</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="o">+</span> <span class="n">tile_w</span><span class="p">),</span>
                               <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">tile_h</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span>
                               <span class="n">w</span><span class="p">,</span>
                               <span class="n">tile_h</span> <span class="o">*</span> <span class="mf">1.75</span><span class="p">,</span>
                               <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">col</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">sprite2</span><span class="p">,</span> <span class="n">LiquidBody</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span></div>

    <span class="c1"># checks whether an enemy is in sight</span>
<div class="viewcode-block" id="AIBrain.check_enemy_ahead"><a class="viewcode-back" href="../spygame_reference.html#spygame.AIBrain.check_enemy_ahead">[docs]</a>    <span class="k">def</span> <span class="nf">check_enemy_ahead</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="Animation"><a class="viewcode-back" href="../spygame_reference.html#spygame.Animation">[docs]</a><span class="k">class</span> <span class="nc">Animation</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Component that takes care of setting the image property of its owning Sprite object based on so-called &quot;animation settings&quot;.</span>
<span class="sd">    Animation settings are stored in a global registry under the name of the SpriteSheet object that holds the images that belong to the animation setting.</span>
<span class="sd">    The tick method has to be called by the Sprite&#39;s tick method in order for the Sprite&#39;s image to be changed on each tick.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># static animation-properties registry</span>
    <span class="c1"># - stores single animation records (these are NOT Animation objects, but simple dicts representing settings for single animation sequences)</span>
    <span class="n">animation_settings</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="c1"># some flags</span>
    <span class="n">animation_flags</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;none&quot;</span><span class="p">:</span>   <span class="mh">0x0</span><span class="p">,</span>
        <span class="c1"># if set: this animation does not change the Sprite&#39;s image depending on time, but they have to be set manually via the</span>
        <span class="c1"># frame property of the Animation component (which gives the SpriteSheet&#39;s frame, not the anim_settings frame-slot)</span>
        <span class="s2">&quot;manual&quot;</span><span class="p">:</span> <span class="mh">0x1</span><span class="p">,</span>
        <span class="s2">&quot;all&quot;</span><span class="p">:</span>    <span class="mh">0xffff</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">next_flag</span> <span class="o">=</span> <span class="mh">0x2</span>

<div class="viewcode-block" id="Animation.get_flag"><a class="viewcode-back" href="../spygame_reference.html#spygame.Animation.get_flag">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_flag</span><span class="p">(</span><span class="n">flags</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the bitmap code for an already existing Animation flag or for a new flag (the code will be created then).</span>
<span class="sd">        Flags are usually used to tell a Brain Component or the character directly what effects the animation has.</span>

<span class="sd">        :param str flags: the flag(s) (comma-separated), whose code(s) should be returned</span>
<span class="sd">        :return: the flag as an int; if many flags are given, returns a bitmask with all those bits set that represent the given flags</span>
<span class="sd">        :rtype: int</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">flag</span> <span class="ow">in</span> <span class="n">flags</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">flag</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_flags</span><span class="p">:</span>
                <span class="n">Animation</span><span class="o">.</span><span class="n">animation_flags</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span> <span class="o">=</span> <span class="n">Animation</span><span class="o">.</span><span class="n">next_flag</span>
                <span class="n">Animation</span><span class="o">.</span><span class="n">next_flag</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="n">ret</span> <span class="o">|=</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_flags</span><span class="p">[</span><span class="n">flag</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Animation.register_settings"><a class="viewcode-back" href="../spygame_reference.html#spygame.Animation.register_settings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">register_settings</span><span class="p">(</span><span class="n">settings_name</span><span class="p">,</span> <span class="n">settings</span><span class="p">,</span> <span class="n">register_events_on</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># we do not have this name registered yet</span>
        <span class="k">if</span> <span class="n">settings_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span><span class="p">:</span>
            <span class="k">assert</span> <span class="s2">&quot;default&quot;</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">,</span> <span class="s2">&quot;ERROR: no entry `default` in animation-settings. Each settings block needs a default animation name.&quot;</span>
            <span class="k">for</span> <span class="n">anim</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">anim</span> <span class="o">!=</span> <span class="s2">&quot;default&quot;</span><span class="p">:</span>
                    <span class="n">defaults</span><span class="p">(</span><span class="n">settings</span><span class="p">[</span><span class="n">anim</span><span class="p">],</span> <span class="p">{</span>
                        <span class="s2">&quot;rate&quot;</span><span class="p">:</span>          <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span><span class="p">,</span>  <span class="c1"># the rate with which to play this animation in 1/s</span>
                        <span class="s2">&quot;frames&quot;</span><span class="p">:</span>        <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>  <span class="c1"># the frames to play from our spritesheet (starts with 0)</span>
                        <span class="s2">&quot;priority&quot;</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>  <span class="c1"># which priority to use for next if next is given</span>
                        <span class="c1"># flags bitmap that determines the behavior of the animation (e.g. block controls during animation play, etc..)</span>
                        <span class="s2">&quot;flags&quot;</span><span class="p">:</span>         <span class="mi">0</span><span class="p">,</span>
                        <span class="s2">&quot;callbacks&quot;</span><span class="p">:</span>     <span class="kc">None</span><span class="p">,</span>
                        <span class="s2">&quot;loop&quot;</span><span class="p">:</span>          <span class="kc">True</span><span class="p">,</span>  <span class="c1"># whether to loop the animation when done</span>
                        <span class="s2">&quot;next&quot;</span><span class="p">:</span>          <span class="kc">None</span><span class="p">,</span>  <span class="c1"># which animation to play next (str or callable returning a str)</span>
                        <span class="s2">&quot;next_priority&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>  <span class="c1"># which priority to use for next if next is given</span>
                        <span class="s2">&quot;trigger&quot;</span><span class="p">:</span>       <span class="kc">None</span><span class="p">,</span>  <span class="c1"># which events to trigger on the game_object that plays this animation</span>
                        <span class="s2">&quot;trigger_data&quot;</span><span class="p">:</span>  <span class="p">[],</span>  <span class="c1"># *args data to pass to the event handler if trigger is given</span>
                        <span class="s2">&quot;properties&quot;</span><span class="p">:</span>    <span class="p">{},</span>    <span class="c1"># some custom properties of this anim</span>
                    <span class="p">})</span>
            <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span><span class="p">[</span><span class="n">settings_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">settings</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">register_events_on</span><span class="p">,</span> <span class="n">EventObject</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">from_iterable</span><span class="p">((</span><span class="s2">&quot;anim.&quot;</span> <span class="o">+</span> <span class="n">anim</span><span class="p">,</span> <span class="s2">&quot;anim_loop.&quot;</span> <span class="o">+</span> <span class="n">anim</span><span class="p">,</span> <span class="s2">&quot;anim_end.&quot;</span> <span class="o">+</span> <span class="n">anim</span><span class="p">)</span> <span class="k">for</span> <span class="n">anim</span> <span class="ow">in</span> <span class="n">settings</span><span class="p">))</span>
            <span class="n">register_events_on</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">)</span></div>

<div class="viewcode-block" id="Animation.get_settings"><a class="viewcode-back" href="../spygame_reference.html#spygame.Animation.get_settings">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_settings</span><span class="p">(</span><span class="n">spritesheet_name</span><span class="p">,</span> <span class="n">anim_setting</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">spritesheet_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span> <span class="ow">or</span> <span class="n">anim_setting</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span><span class="p">[</span><span class="n">spritesheet_name</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">Animation</span><span class="o">.</span><span class="n">animation_settings</span><span class="p">[</span><span class="n">spritesheet_name</span><span class="p">][</span><span class="n">anim_setting</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">animation</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># str: we are playing this animation; None: we are undefined -&gt; waiting for the next anim setup</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rate</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">3</span>  <span class="c1"># default rate in s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">has_changed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>  <span class="c1"># animation priority (takes the value of the highest priority animation that wants to be played simultaneously)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the current frame in the animation &#39;frames&#39; list OR: if self.animation is None: this is the actual frame from the SpriteSheet</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the current time after starting the animation in s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># custome properties of this Animation object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_rate</span> <span class="o">=</span> <span class="mf">3.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># True: half the time we are blinking</span>

<div class="viewcode-block" id="Animation.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.Animation.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># make sure our GameObject is actually a Sprite</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">Sprite</span><span class="p">),</span> <span class="s2">&quot;ERROR: Component Animation can only be added to a Sprite object!&quot;</span>

        <span class="c1"># tell our GameObject that we might trigger some &quot;anim...&quot; events on it</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;anim.start&quot;</span><span class="p">,</span> <span class="s2">&quot;anim.frame&quot;</span><span class="p">,</span> <span class="s2">&quot;anim.loop&quot;</span><span class="p">,</span> <span class="s2">&quot;anim.end&quot;</span><span class="p">)</span>

        <span class="c1"># extend some methods directly onto the GameObject</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">play_animation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blink_animation</span><span class="p">)</span></div>

<div class="viewcode-block" id="Animation.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.Animation.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Needs to be called by the GameObject at some point during the GameObject&#39;s `tick` method.</span>

<span class="sd">        :param GameLoop game_loop: the GameLoop that&#39;s currently playing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>

        <span class="c1"># blink stuff?</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">+=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
            <span class="c1"># blinking stops</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frame</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">blink_rate</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">frame</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># animation stuff?</span>
        <span class="n">anim_settings</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">animation</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">Animation</span><span class="o">.</span><span class="n">get_flag</span><span class="p">(</span><span class="s2">&quot;manual&quot;</span><span class="p">):</span>
            <span class="n">anim_settings</span> <span class="o">=</span> <span class="n">Animation</span><span class="o">.</span><span class="n">get_settings</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">anim_settings_name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">animation</span><span class="p">)</span>
            <span class="n">rate</span> <span class="o">=</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;rate&quot;</span><span class="p">]</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">rate</span>
            <span class="n">stepped</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">has_changed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_changed</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">+=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">&gt;</span> <span class="n">rate</span><span class="p">:</span>
                    <span class="n">stepped</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">//</span> <span class="n">rate</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">-=</span> <span class="n">stepped</span> <span class="o">*</span> <span class="n">rate</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">+=</span> <span class="n">stepped</span>
            <span class="c1"># we are changing frames</span>
            <span class="k">if</span> <span class="n">stepped</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># there are no more frames</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">]):</span>
                    <span class="c1"># this animation ends</span>
                    <span class="k">if</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;loop&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">or</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">]:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim.end&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
                        <span class="k">if</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;trigger&quot;</span><span class="p">]:</span>
                            <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;trigger&quot;</span><span class="p">],</span> <span class="o">*</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;trigger_data&quot;</span><span class="p">])</span>
                        <span class="c1"># `next` could be a callable as well returning a str to use as animation setting</span>
                        <span class="k">if</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">]:</span>
                            <span class="c1">#print(&quot;playing next animation {}\n&quot;.format(anim_settings[&quot;next&quot;]))</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">play_animation</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">]()</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next&quot;</span><span class="p">]),</span>
                                                <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;next_priority&quot;</span><span class="p">])</span>
                        <span class="k">return</span>
                    <span class="c1"># this animation loops</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim.loop&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">%=</span> <span class="nb">len</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">])</span>

                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim.frame&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>

        <span class="c1"># assign the correct image to the `image` field of the GameObject (already correctly x/y-flipped)</span>
        <span class="c1"># hidden: no image</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_hidden</span><span class="p">:</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># visible: some image</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">tiles_dict</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tiles</span>  <span class="c1"># no flipping</span>
            <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>
                    <span class="n">tiles_dict</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tiles_flipped_xy</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tiles_dict</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tiles_flipped_x</span>
            <span class="k">elif</span> <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]:</span>
                <span class="n">tiles_dict</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spritesheet</span><span class="o">.</span><span class="n">tiles_flipped_y</span>
            <span class="c1"># manual animation -&gt; frame in SpriteSheet directly set manually</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">Animation</span><span class="o">.</span><span class="n">get_flag</span><span class="p">(</span><span class="s2">&quot;manual&quot;</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">tiles_dict</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">)]</span>
            <span class="c1"># automatic animation: self.frame is the slot in the animation&#39;s frame list (not the SpriteSheet&#39;s!)</span>
            <span class="k">elif</span> <span class="n">anim_settings</span><span class="p">:</span>
                <span class="c1"># TEST DEBUG</span>
                <span class="n">frm</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">frame</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">frm</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">]):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BAD: anim=&#39;</span><span class="si">{}</span><span class="s2">&#39; frm </span><span class="si">{}</span><span class="s2"> &gt;= len(anim_settings[frames]) </span><span class="si">{}</span><span class="s2">!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">animation</span><span class="p">,</span> <span class="n">frm</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">])))</span>
                <span class="n">tile</span> <span class="o">=</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;frames&quot;</span><span class="p">][</span><span class="n">frm</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">tile</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tiles_dict</span><span class="p">):</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;BAD: anim=&#39;</span><span class="si">{}</span><span class="s2">&#39; tile </span><span class="si">{}</span><span class="s2"> &gt;= len(tiles_dict) </span><span class="si">{}</span><span class="s2">!</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">animation</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tiles_dict</span><span class="p">)))</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">tiles_dict</span><span class="p">[</span><span class="n">tile</span><span class="p">]</span></div>

<div class="viewcode-block" id="Animation.play_animation"><a class="viewcode-back" href="../spygame_reference.html#spygame.Animation.play_animation">[docs]</a>    <span class="k">def</span> <span class="nf">play_animation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_object</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plays an animation on our GameObject.</span>

<span class="sd">        :param GameObject game_object: the GameObject on which to play the animation; the animation has to be setup via register_settings with the name</span>
<span class="sd">          of the SpriteSheet of the GameObject</span>
<span class="sd">        :param str name: the name of the animation to play</span>
<span class="sd">        :param int priority: the priority with which to play this animation (if this method is called multiple times, it will pick the higher one)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">animation</span><span class="p">:</span>
            <span class="c1"># look up animation in list</span>
            <span class="n">anim_settings</span> <span class="o">=</span> <span class="n">Animation</span><span class="o">.</span><span class="n">get_settings</span><span class="p">(</span><span class="n">game_object</span><span class="o">.</span><span class="n">anim_settings_name</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">anim_settings</span><span class="p">,</span> <span class="s2">&quot;ERROR: animation-to-play (`</span><span class="si">{}</span><span class="s2">`) not found in spritesheet settings `</span><span class="si">{}</span><span class="s2">`!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">game_object</span><span class="o">.</span><span class="n">anim_settings_name</span><span class="p">)</span>

            <span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span> <span class="ow">or</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;priority&quot;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">priority</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">priority</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">animation</span> <span class="o">=</span> <span class="n">name</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">has_changed</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">frame</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># start each animation from 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span>
                <span class="c1"># set flags to sprite&#39;s properties</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;flags&quot;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">properties</span> <span class="o">=</span> <span class="n">anim_settings</span><span class="p">[</span><span class="s2">&quot;properties&quot;</span><span class="p">]</span>

                <span class="n">game_object</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;anim.start&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Animation.blink_animation"><a class="viewcode-back" href="../spygame_reference.html#spygame.Animation.blink_animation">[docs]</a>    <span class="k">def</span> <span class="nf">blink_animation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_object</span><span class="p">,</span> <span class="n">rate</span><span class="o">=</span><span class="mf">3.0</span><span class="p">,</span> <span class="n">duration</span><span class="o">=</span><span class="mf">3.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Blinks the GameObject with the given parameters.</span>

<span class="sd">        :param GameObject game_object: our GameObject to which blinking is applied</span>
<span class="sd">        :param float rate: the rate with which to blink (in 1/s)</span>
<span class="sd">        :param float duration: the duration of the blinking (in s); after the duration, the blinking stops</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_rate</span> <span class="o">=</span> <span class="n">rate</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_duration</span> <span class="o">=</span> <span class="n">duration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blink_time</span> <span class="o">=</span> <span class="mi">0</span></div></div>


<div class="viewcode-block" id="Dockable"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable">[docs]</a><span class="k">class</span> <span class="nc">Dockable</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A dockable component allows 1) for Sprites to dock to a so-called &quot;mother_ship&quot; and b) for Sprites to become &quot;mother_ships&quot; themselves (other Sprites can</span>
<span class="sd">    dock to this Sprite). Sprites that are docked to our mother_ship (this Component&#39;s Sprite) will be moved along with it when they stand on top.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DEFINITELY_DOCKED</span> <span class="o">=</span> <span class="mh">0x1</span>  <span class="c1"># this object is definitely docked to something right now</span>
    <span class="n">DEFINITELY_NOT_DOCKED</span> <span class="o">=</span> <span class="mh">0x2</span>  <span class="c1"># this object is definitely not docked to something right now</span>
    <span class="n">TO_BE_DETERMINED</span> <span class="o">=</span> <span class="mh">0x4</span>  <span class="c1"># the docking state of this object is currently being determined</span>
    <span class="n">PREVIOUSLY_DOCKED</span> <span class="o">=</span> <span class="mh">0x8</span>  <span class="c1"># if set, the object was docked to something in the previous frame</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;dockable&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param str name: the name of the Component</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docked_sprites</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># set that holds all Sprites (by GameObject id) currently docked to this one</span>
        <span class="c1"># holds the objects that we stand on and stood on previously:</span>
        <span class="c1"># slot 0=current state; slot 1=previous state (sometimes we need the previous state since the current state gets reset to 0 every step)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the reference to the object that we are currently docked to</span>

<div class="viewcode-block" id="Dockable.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># make sure our GameObject is a Sprite</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">Sprite</span><span class="p">),</span> <span class="s2">&quot;ERROR: game_object of Component Dockable must be of type Sprite (not </span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span> \
            <span class="nb">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="c1"># extend our GameObject with move (thereby overriding the Sprite&#39;s move method)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dockable.move"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This will &#39;overwrite&#39; the normal Sprite&#39;s `move` method by Component&#39;s extend.</span>

<span class="sd">        :param Sprite sprite: the GameObject that this Component belongs to (the Sprite to move around)</span>
<span class="sd">        :param Union[int,None] x: the amount in pixels to move in x-direction</span>
<span class="sd">        :param Union[int,None] y: the amount in pixels to move in y-direction</span>
<span class="sd">        :param bool absolute: whether x and y are given as absolute coordinates (default: False): in this case x/y=None means do not move in this dimension</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orig_x</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span>
        <span class="n">orig_y</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span>

        <span class="c1"># first call the original Sprite&#39;s move method</span>
        <span class="n">sprite</span><span class="o">.</span><span class="n">_super_move</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">absolute</span><span class="p">)</span>

        <span class="c1"># move all our docked Sprites along with us</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">absolute</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">docked_sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docked_sprites</span><span class="p">:</span>
                <span class="n">docked_sprite</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># translate into relative movement: we don&#39;t want the docked components to move to the given mothership&#39;s absolute values</span>
            <span class="n">x_move</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="n">orig_x</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="n">y_move</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="n">orig_y</span> <span class="k">if</span> <span class="n">y</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">docked_sprite</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docked_sprites</span><span class="p">:</span>
                <span class="n">docked_sprite</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">x_move</span><span class="p">,</span> <span class="n">y_move</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dockable.dock_to"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable.dock_to">[docs]</a>    <span class="k">def</span> <span class="nf">dock_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mother_ship</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A sprite lands on an elevator -&gt; couple the elevator to the sprite so that when the elevator moves, the sprite moves along with it.</span>
<span class="sd">        Only possible to dock to `dockable`-type objects.</span>

<span class="sd">        :param Sprite mother_ship: the Sprite to dock to (Sprite needs to have a dockable component)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="c1"># can only dock to dockable-type objects</span>
        <span class="k">if</span> <span class="n">mother_ship</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;dockable&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">DEFINITELY_DOCKED</span>
            <span class="k">if</span> <span class="n">prev</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">|=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">PREVIOUSLY_DOCKED</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span> <span class="o">=</span> <span class="n">mother_ship</span>
            <span class="c1"># add docked obj to mothership docked-obj-list (if present)</span>
            <span class="k">if</span> <span class="s2">&quot;dockable&quot;</span> <span class="ow">in</span> <span class="n">mother_ship</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                <span class="c1">#print(&quot;adding {} (id {}) to mothership {}&quot;.format(type(obj).__name__, obj.id, type(self.docked_to).__name__))</span>
                <span class="n">mother_ship</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">docked_sprites</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="Dockable.undock"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable.undock">[docs]</a>    <span class="k">def</span> <span class="nf">undock</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Undocks itself from the mothership.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">DEFINITELY_NOT_DOCKED</span>
        <span class="k">if</span> <span class="n">prev</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">|=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">PREVIOUSLY_DOCKED</span>
        <span class="c1"># remove docked obj from mothership docked-obj-list (if present)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span> <span class="ow">and</span> <span class="s2">&quot;dockable&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
            <span class="c1">#print(&quot;removing {} (id {}) from mothership {}&quot;.format(type(obj).__name__, obj.id, type(self.docked_to).__name__))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">docked_sprites</span><span class="o">.</span><span class="n">discard</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docked_to</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Dockable.undock_all_docked_objects"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable.undock_all_docked_objects">[docs]</a>    <span class="k">def</span> <span class="nf">undock_all_docked_objects</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        undocks all objects currently docked to this object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docked_sprites</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;dockable&quot;</span> <span class="ow">in</span> <span class="n">obj</span><span class="o">.</span><span class="n">components</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">undock</span><span class="p">()</span></div>

<div class="viewcode-block" id="Dockable.to_determine"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable.to_determine">[docs]</a>    <span class="k">def</span> <span class="nf">to_determine</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Changes our docking state to be undetermined (saves the current state as PREVIOUS flag).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">TO_BE_DETERMINED</span>
        <span class="k">if</span> <span class="n">prev</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">|=</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">PREVIOUSLY_DOCKED</span></div>

<div class="viewcode-block" id="Dockable.is_docked"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable.is_docked">[docs]</a>    <span class="k">def</span> <span class="nf">is_docked</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: True if the current state is definitely docked OR (to-be-determined AND previous state was docked)</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">&amp;</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">DEFINITELY_DOCKED</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">&amp;</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">TO_BE_DETERMINED</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">&amp;</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">PREVIOUSLY_DOCKED</span><span class="p">))</span></div>

<div class="viewcode-block" id="Dockable.state_unsure"><a class="viewcode-back" href="../spygame_reference.html#spygame.Dockable.state_unsure">[docs]</a>    <span class="k">def</span> <span class="nf">state_unsure</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :return: True if our current docking state is not 100% sure (TO_BE_DETERMINED)</span>
<span class="sd">        :rtype: bool</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">bool</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">docking_state</span> <span class="o">&amp;</span> <span class="n">Dockable</span><span class="o">.</span><span class="n">TO_BE_DETERMINED</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Elevator"><a class="viewcode-back" href="../spygame_reference.html#spygame.Elevator">[docs]</a><span class="k">class</span> <span class="nc">Elevator</span><span class="p">(</span><span class="n">Sprite</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple elevator/moving platform class.</span>
<span class="sd">    Can either go in x or in y direction, with a configurable speed and in between settable coordinate values.</span>
<span class="sd">    Has a Dockable Component to be able to carry characters standing on top of it.</span>
<span class="sd">    Is of type one_way_platform so one can jump on the Elevator also from below it.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="n">initial_veloc</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">max_pos</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">min_pos</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">image_file</span><span class="o">=</span><span class="s2">&quot;images/elevator.png&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="n">initial_veloc</span> <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="n">initial_veloc</span> <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_pos</span> <span class="o">=</span> <span class="n">max_pos</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_pos</span> <span class="o">=</span> <span class="n">min_pos</span>

        <span class="c1"># add Dockable component (so that objects can stand on the elevator and move along with it)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cmp_dockable</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">Dockable</span><span class="p">(</span><span class="s2">&quot;dockable&quot;</span><span class="p">))</span>  <span class="c1"># type: Dockable</span>

        <span class="c1"># adjust the type</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type</span> <span class="o">|=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;dockable,one_way_platform&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># don&#39;t do any collisions for this elevator (only other Sprites vs Elevator)</span>

<div class="viewcode-block" id="Elevator.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.Elevator.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moving elevator up and down OR left and right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_pos</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">min_pos</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pos</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_pos</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_pos</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_pos</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pos</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pos</span><span class="p">,</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PhysicsComponent"><a class="viewcode-back" href="../spygame_reference.html#spygame.PhysicsComponent">[docs]</a><span class="k">class</span> <span class="nc">PhysicsComponent</span><span class="p">(</span><span class="n">Component</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines an abstract generic physics component that can be added to agents (or enemies) to behave in the world.</span>
<span class="sd">    GameObject&#39;s that own this Comonent may have a Brain component as well in order to steer behavior of the agent in `tick`.</span>
<span class="sd">    Needs to override `tick` and `collision`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="PhysicsComponent.tile_sprite_handler"><a class="viewcode-back" href="../spygame_reference.html#spygame.PhysicsComponent.tile_sprite_handler">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">tile_sprite_handler</span><span class="p">(</span><span class="n">tile_sprite_class</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populates the tile_sprites dict of a TiledTileLayer with tile_sprite_class (e.g. TileSprite or SlopedTileSprite) objects.</span>

<span class="sd">        :param TiledTileLayer layer: the TiledTileLayer, whose tiles we would like to process and store (each one) in the returned np.ndarray</span>
<span class="sd">        :param type tile_sprite_class: the TiledSprite subclass to use for generating TileSprite objects</span>
<span class="sd">        :return: a 2D np.ndarray (x,y) with the created TileSprite objects for each x/y coordinate (None if there is no tile at a position)</span>
<span class="sd">        :rtype: np.ndarray (2D)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># set up ndarray</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">height</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">tile_sprite_class</span><span class="p">)</span>
        <span class="c1"># loop through each tile and generate TileSprites</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">gid</span> <span class="ow">in</span> <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_layer</span><span class="o">.</span><span class="n">iter_data</span><span class="p">():</span>
            <span class="c1"># skip empty tiles (gid==0)</span>
            <span class="k">if</span> <span class="n">gid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">tile_props</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">get_tile_properties_by_gid</span><span class="p">(</span><span class="n">gid</span><span class="p">)</span> <span class="ow">or</span> <span class="p">{}</span>
            <span class="c1"># go through dict and translate data types into proper python types (&quot;true&quot; -&gt; bool, 0.0 -&gt; float, etc..)</span>
            <span class="c1"># also keep autobuild kwargs in a separate dict</span>
            <span class="n">look_for_autobuild</span> <span class="o">=</span> <span class="p">(</span><span class="kc">True</span> <span class="k">if</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;autobuild_class&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="kc">False</span><span class="p">)</span>
            <span class="n">autobuild_kwargs</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">convert_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="c1"># a special autobuild kwarg (for the autobuild c&#39;tor)</span>
                <span class="k">if</span> <span class="n">look_for_autobuild</span> <span class="ow">and</span> <span class="n">key</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;P_&quot;</span><span class="p">:</span>
                    <span class="n">autobuild_kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">:]]</span> <span class="o">=</span> <span class="n">value</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tile_props</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

            <span class="k">if</span> <span class="n">look_for_autobuild</span><span class="p">:</span>
                <span class="n">tile_props</span><span class="p">[</span><span class="s2">&quot;autobuild_kwargs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">autobuild_kwargs</span>

            <span class="n">ret</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]</span> <span class="o">=</span> <span class="n">tile_sprite_class</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="p">,</span> <span class="n">gid</span><span class="p">,</span> <span class="n">tile_props</span><span class="p">,</span>
                                          <span class="n">pygame</span><span class="o">.</span><span class="n">Rect</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">y</span> <span class="o">*</span> <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">,</span>
                                                      <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span><span class="p">,</span> <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span></div>

    <span class="c1"># probably needs to be extended further by child classes</span>
<div class="viewcode-block" id="PhysicsComponent.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.PhysicsComponent.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="c1"># handle collisions</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># flag the GameObject as &quot;handles collisions itself&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">handles_own_collisions</span> <span class="o">=</span> <span class="kc">True</span></div>

    <span class="c1"># may determine x/y-speeds and movements of the GameObject (gravity, etc..)</span>
<div class="viewcode-block" id="PhysicsComponent.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.PhysicsComponent.tick">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">:</span> <span class="n">GameLoop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Needs to be called by the GameObject at some point during the GameObject&#39;s `tick` method.</span>

<span class="sd">        :param GameLoop game_loop: the currently playing GameLoop object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="PhysicsComponent.collision"><a class="viewcode-back" href="../spygame_reference.html#spygame.PhysicsComponent.collision">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the resolver for a Collision that happened between two Sprites under this PhysicsComponent.</span>

<span class="sd">        :param Collision col: the Collision object describing the collision that already happened between two sprites</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="ControlledPhysicsComponent"><a class="viewcode-back" href="../spygame_reference.html#spygame.ControlledPhysicsComponent">[docs]</a><span class="k">class</span> <span class="nc">ControlledPhysicsComponent</span><span class="p">(</span><span class="n">PhysicsComponent</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When added to a GameObject, checks for an existing Brain Component and creates a property (self.game_obj_cmp_brain) for easy access.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;physics&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the GameObject&#39;s HumanPlayerBrain component (used by Physics for steering and action control within `tick` method)</span>

<div class="viewcode-block" id="ControlledPhysicsComponent.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.ControlledPhysicsComponent.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">added</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;brain&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># if there is a Component named `brain` in the GameObject it has to be of type Brain</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">,</span> <span class="n">Brain</span><span class="p">),</span>\
            <span class="s2">&quot;ERROR: </span><span class="si">{}</span><span class="s2">&#39;s `brain` Component is not of type Brain!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TopDownPhysics"><a class="viewcode-back" href="../spygame_reference.html#spygame.TopDownPhysics">[docs]</a><span class="k">class</span> <span class="nc">TopDownPhysics</span><span class="p">(</span><span class="n">ControlledPhysicsComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines &quot;top-down-2D&quot;-step physics (agent can move in any of the 4 directions using any step-size (smooth walking)).</span>
<span class="sd">    To be addable to any character (player or enemy).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;physics&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="c1"># velocities/physics stuff</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span> <span class="o">=</span> <span class="mi">300</span>  <span class="c1"># running acceleration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span> <span class="o">=</span> <span class="mi">150</span>  <span class="c1"># max run-speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Vikings stop abruptly when running in one direction, then the other direction is pressed</span>

        <span class="c1"># environment stuff (TODO: where to get Level dimensions from?)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_min</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the minimum/maximum allowed positions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_min</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">=</span> <span class="mi">9000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">=</span> <span class="mi">9000</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">touching</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># bitmap with those bits set that the entity is currently touching (colliding with)</span>
        <span class="c1"># TODO: what does at_exit mean in terms of an MDP/RL-setting?</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="TopDownPhysics.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.TopDownPhysics.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">added</span><span class="p">()</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_max</span> <span class="o">-=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_max</span> <span class="o">-=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span>

        <span class="n">obj</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;bump.top&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.bottom&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.left&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.right&quot;</span><span class="p">)</span>  <span class="c1"># we will trigger these as well -&gt; register them</span></div>

    <span class="c1"># determines x/y-speeds and moves the GameObject</span>
<div class="viewcode-block" id="TopDownPhysics.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.TopDownPhysics.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Needs to be called by the GameObject at some point during the GameObject&#39;s `tick` method.</span>

<span class="sd">        :param GameLoop game_loop: the currently playing GameLoop object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
        <span class="c1"># accelerations</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ay</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">stage</span>

        <span class="c1"># entity has a brain component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">:</span>
            <span class="c1"># determine x speed</span>
            <span class="c1"># -----------------</span>
            <span class="c1"># user is trying to move left or right (or both?)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]:</span>
                <span class="c1"># only left is pressed</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                    <span class="n">ax</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span>  <span class="c1"># accelerate left</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># mirror sprite</span>
                <span class="c1"># user presses both keys (left and right) -&gt; just stop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># only right is pressed</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span>  <span class="c1"># accelerate right</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># stop immediately (vx=0; don&#39;t accelerate negatively)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># determine y speed</span>
            <span class="c1"># -----------------</span>
            <span class="c1"># user is trying to move up or down (or both?)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;up&quot;</span><span class="p">]:</span>
                <span class="c1"># only up is pressed</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                    <span class="n">ay</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span>  <span class="c1"># accelerate up</span>
                <span class="c1"># user presses both keys (up and down) -&gt; just stop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># only down is pressed</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;down&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                <span class="n">ay</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span>  <span class="c1"># accelerate down</span>
            <span class="c1"># stop immediately (vy=0; don&#39;t accelerate negatively)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># entity has no steering unit (speed = 0)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># TODO: check the entity&#39;s magnitude of vx and vy,</span>
        <span class="c1"># reduce the max dt_step if necessary to prevent skipping through objects.</span>
        <span class="n">dt_step</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="k">while</span> <span class="n">dt_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">30</span><span class="p">,</span> <span class="n">dt_step</span><span class="p">)</span>

            <span class="c1"># update x/y-velocity based on acceleration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">+=</span> <span class="n">ax</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">v_max</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">+=</span> <span class="n">ay</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">v_max</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">v_max</span>

            <span class="c1"># reset all touch flags before doing all the collision analysis</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># first move in x-direction and solve x-collisions</span>
            <span class="n">orig_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">dt</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                    <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collide_in_one_direction</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">,</span> <span class="n">orig_pos</span><span class="p">)</span>

            <span class="c1"># then move in y-direction and solve y-collisions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                    <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collide_in_one_direction</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">,</span> <span class="n">orig_pos</span><span class="p">)</span>

            <span class="n">dt_step</span> <span class="o">-=</span> <span class="n">dt</span></div>

<div class="viewcode-block" id="TopDownPhysics.collide_in_one_direction"><a class="viewcode-back" href="../spygame_reference.html#spygame.TopDownPhysics.collide_in_one_direction">[docs]</a>    <span class="k">def</span> <span class="nf">collide_in_one_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detects and solves all possible collisions between our GameObject and all Stage&#39;s objects (layers and Sprites) in one direction (x or y).</span>

<span class="sd">        :param Sprite sprite: the GameObject of this Component (the moving/colliding Sprite)</span>
<span class="sd">        :param str direction: either &quot;x&quot; or &quot;y&quot;</span>
<span class="sd">        :param float direction_veloc: the velocity in the given direction (x/y-component of the velocity vector)</span>
<span class="sd">        :param Tuple[int,int] original_pos: the position of the game_object before this collision detection execution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">stage</span>

        <span class="c1"># default layers</span>
        <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">tiled_tile_layers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">collide_with_collision_layer</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>
        <span class="c1"># simple sprites (e.g. enemies)</span>
        <span class="k">for</span> <span class="n">other_sprite</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sprite</span> <span class="ow">is</span> <span class="n">other_sprite</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">other_sprite</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">other_sprite</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="o">=</span><span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="o">=</span><span class="n">original_pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                    <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span></div>

<div class="viewcode-block" id="TopDownPhysics.collide_with_collision_layer"><a class="viewcode-back" href="../spygame_reference.html#spygame.TopDownPhysics.collide_with_collision_layer">[docs]</a>    <span class="k">def</span> <span class="nf">collide_with_collision_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collides a Sprite with a collision TiledTileLayer (type==default) and solves all detected collisions.</span>

<span class="sd">        :param Sprite sprite: the Sprite to test for collisions against a TiledTileLayer</span>
<span class="sd">        :param TiledTileLayer layer: the TiledTileLayer object in which to look for collision tiles (full of sloped)</span>
<span class="sd">        :param str direction: `x` or `y` direction in which the sprite is currently moving before this test</span>
<span class="sd">        :param float direction_veloc: the velocity in the given direction (could be negative or positive)</span>
<span class="sd">        :param Tuple[int,int] original_pos: the position of the sprite before the move that caused this collision test to be executed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine the tile boundaries (which tiles does the sprite overlap with?)</span>
        <span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span><span class="p">,</span> <span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">get_overlapping_tiles</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>

        <span class="c1"># if sprite is moving in +/-x-direction:</span>
        <span class="c1"># 1) move in columns from left to right (right to left) to look for tiles</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">direction_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">tile_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_x</span> <span class="k">if</span> <span class="n">direction_x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tile_end_x</span><span class="p">,</span> <span class="p">(</span><span class="n">tile_end_x</span> <span class="k">if</span> <span class="n">direction_x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tile_start_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">direction_x</span><span class="p">,</span> <span class="n">direction_x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tile_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># y-order doesn&#39;t matter</span>
                    <span class="n">tile_sprite</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">tile_sprite</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tile_sprite</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                            <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                            <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">direction_y</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">tile_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_y</span> <span class="k">if</span> <span class="n">direction_y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tile_end_y</span><span class="p">,</span> <span class="p">(</span><span class="n">tile_end_y</span> <span class="k">if</span> <span class="n">direction_y</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tile_start_y</span><span class="p">)</span> <span class="o">+</span> <span class="n">direction_y</span><span class="p">,</span> <span class="n">direction_y</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tile_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># x-order doesn&#39;t matter</span>
                    <span class="n">tile_sprite</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">tile_sprite</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tile_sprite</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                            <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                            <span class="k">return</span></div>

<div class="viewcode-block" id="TopDownPhysics.collision"><a class="viewcode-back" href="../spygame_reference.html#spygame.TopDownPhysics.collision">[docs]</a>    <span class="k">def</span> <span class="nf">collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="k">assert</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span><span class="p">,</span> <span class="s2">&quot;ERROR: game_object (</span><span class="si">{}</span><span class="s2">) of physics component is not identical with passed in col.sprite1 (</span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;sprite2&quot;</span><span class="p">),</span> <span class="s2">&quot;ERROR: no sprite2 in col-object!&quot;</span>
        <span class="n">other_obj</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite2</span>

        <span class="c1"># collided with a tile (from a layer)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_obj</span><span class="p">,</span> <span class="n">TileSprite</span><span class="p">):</span>
            <span class="n">tile_props</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">tile_props</span>
            <span class="c1"># colliding with an exit</span>
            <span class="c1"># TODO: what does exit mean? in a RL setting? end of episode?</span>
            <span class="k">if</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;exit&quot;</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;reached_exit&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>  <span class="c1"># let the level know</span>
                <span class="k">return</span>

        <span class="c1"># solve collision</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># top/bottom collisions</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">normal_y</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">*</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if normal_y &lt; 0 -&gt; vy is &gt; 0 -&gt; set to 0; if normal_x &gt; 0 -&gt; vy is &lt; 0 -&gt; set to 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;bottom&quot;</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;top&quot;</span><span class="p">),</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># left/right collisions</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">normal_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if normal_y &lt; 0 -&gt; vx is &gt; 0 -&gt; set to 0; if normal_y &gt; 0 -&gt; vx is &lt; 0 -&gt; set to 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;left&quot;</span><span class="p">),</span> <span class="n">col</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="PlatformerPhysics"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics">[docs]</a><span class="k">class</span> <span class="nc">PlatformerPhysics</span><span class="p">(</span><span class="n">ControlledPhysicsComponent</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines &quot;The Lost Vikings&quot;-like game physics.</span>
<span class="sd">    Supports: Running over sloped tiles, jumping, ladders, moving platforms and elevators, pushable heavy rocks, one-way-platforms</span>
<span class="sd">    To be addable to any character (player or enemy) or thing (e.g. a pushable rock)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># used repeatedly (recycle) for collision detection information being passed between the CollisionAlgorithm object and the physics Copmonents</span>
    <span class="c1"># collision_objects = (PlatformerCollision(), PlatformerCollision())</span>

<div class="viewcode-block" id="PlatformerPhysics.get_highest_tile"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.get_highest_tile">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">get_highest_tile</span><span class="p">(</span><span class="n">tiles</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">start_abs</span><span class="p">,</span> <span class="n">end_abs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the `highest` tile in a list (row or column) of sloped, full-collision or empty tiles.</span>

<span class="sd">        :param list tiles: the list of tiles to check</span>
<span class="sd">        :param str direction: the direction in which the list of tiles is arranged (x=row of tiles or y=column of tiles)</span>
<span class="sd">        :param int start_abs: the absolute leftmost x-value from where to check</span>
<span class="sd">        :param int end_abs: the absolute rightmost x-value from where to check</span>
<span class="sd">        :return: a tuple consisting of a) the highest SlopedTileSprite found in the list and b) the height value measured on a cartesian y-axis (positive=up)</span>
<span class="sd">        :rtype: Tuple[SlopedTileSprite,int]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># start with leftmost tile (measure max height for the two x points: sprite&#39;s leftmost edge and tile&#39;s right edge)</span>
        <span class="n">best_tile</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># the highest tile in this row (if not height==0.0)</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">tile</span><span class="p">:</span>
            <span class="n">max_y</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">start_abs</span> <span class="o">-</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="n">tile</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">))</span>
            <span class="n">best_tile</span> <span class="o">=</span> <span class="n">tile</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># then do all center tiles</span>
        <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">tiles</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">tile</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="n">slot</span><span class="p">]</span>
            <span class="n">max_</span> <span class="o">=</span> <span class="n">tile</span><span class="o">.</span><span class="n">max_y</span> <span class="k">if</span> <span class="n">tile</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">max_</span> <span class="o">&gt;</span> <span class="n">max_y</span><span class="p">:</span>
                <span class="n">max_y</span> <span class="o">=</span> <span class="n">max_</span>
                <span class="n">best_tile</span> <span class="o">=</span> <span class="n">tile</span>

        <span class="c1"># then do the rightmost tile (max between tiles left edge and sprite&#39;s right edge)</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">tiles</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">max_</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tile</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">end_abs</span> <span class="o">-</span> <span class="n">tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">),</span> <span class="n">tile</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="k">if</span> <span class="n">tile</span> <span class="k">else</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">max_</span> <span class="o">&gt;</span> <span class="n">max_y</span><span class="p">:</span>
            <span class="n">max_y</span> <span class="o">=</span> <span class="n">max_</span>
            <span class="n">best_tile</span> <span class="o">=</span> <span class="n">tile</span>

        <span class="c1"># TODO: store x-in and y-pull(push) in tile props (as temporary values)</span>
        <span class="k">return</span> <span class="n">best_tile</span><span class="p">,</span> <span class="n">max_y</span></div>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s2">&quot;physics&quot;</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># velocities</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># physics</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span> <span class="o">=</span> <span class="mi">300</span>  <span class="c1"># running acceleration</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx_max</span> <span class="o">=</span> <span class="mi">150</span>  <span class="c1"># max run-speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_fall_speed</span> <span class="o">=</span> <span class="mi">550</span>  <span class="c1"># maximum fall speed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># set to False to make this guy not be subject to y-gravity (e.g. while locked into ladder)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gravity_y</span> <span class="o">=</span> <span class="mf">9.8</span> <span class="o">*</span> <span class="mi">100</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">jump_speed</span> <span class="o">=</span> <span class="mi">330</span>  <span class="c1"># jump-power</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">disable_jump</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># if True: disable jumping so we don&#39;t keep jumping when action1 key keeps being pressed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">can_jump</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># set to False to make this guy not be able to jump</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Vikings stop abruptly when running in one direction, then the other direction is pressed</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">climb_speed</span> <span class="o">=</span> <span class="mi">70</span>  <span class="c1"># speed at which player can climb</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_before_ladder</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_pushable</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># set to True if a collision with the entity causes the entity to move a little</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_heavy</span> <span class="o">=</span> <span class="kc">False</span>  <span class="c1"># set to True if this object should squeeze other objects that are below it and cannot move away</span>
        <span class="c1"># set to a value &gt; 0 to define the squeezeSpeed at which this object gets squeezed by heavy objects (objects with is_heavy == True)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">squeeze_speed</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push_back_list</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># a list of push back x-forces that will be applied (if populated) frame by frame on our GameObject</span>
        <span class="c1"># if an up-slope (e.g. 20) does not reach it full-tiled right neighbor, would a sprite treat this as stairs and still climb up the full-tile</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">allow_stairs_climb</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># self.touching = 0  # bitmap with those bits set that the entity is currently touching (colliding with)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">at_wall</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_sinking_til</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># a y-pos at which point the GameObject will stop sinking into a LiquidBody</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># None if GameObject is not locked into a ladder; Ladder obj if obj is currently locked into a ladder (in climbing position)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># holds the ladder Sprite, if player is currently touching a Ladder (not locked in!), otherwise: None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">climb_frame_value</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># int([climb_frame_value]) determines the frame to use to display climbing position</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_dockable</span> <span class="o">=</span> <span class="kc">None</span>  <span class="c1"># type: Dockable; the GameObject&#39;s Dockable component (that we will add to the GameObject ourselves)</span>

<div class="viewcode-block" id="PlatformerPhysics.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">added</span><span class="p">()</span>

        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>

        <span class="c1"># add the Dockable Component to our GameObject (we need it this for us to work properly)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_dockable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">add_component</span><span class="p">(</span><span class="n">Dockable</span><span class="p">(</span><span class="s2">&quot;dockable&quot;</span><span class="p">))</span>

        <span class="c1"># add some bit-flags to the collision mask of our GameObject</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">|=</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default,ladder,liquid&quot;</span><span class="p">)</span>

        <span class="c1"># register events that we may trigger directly on the game_object</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;hit.particle&quot;</span><span class="p">,</span> <span class="s2">&quot;hit.liquid&quot;</span><span class="p">,</span> <span class="s2">&quot;squeezed.top&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.top&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.bottom&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.left&quot;</span><span class="p">,</span> <span class="s2">&quot;bump.right&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlatformerPhysics.lock_ladder"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.lock_ladder">[docs]</a>    <span class="k">def</span> <span class="nf">lock_ladder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Locks the GameObject into a ladder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span>
        <span class="c1"># switch off gravity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># lock obj to center of ladder (touched_ladder is always set to the one we are touching right now)</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">centerx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">centerx</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop x-movement</span>
        <span class="c1"># undock all objects currently docked to us (if any)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_dockable</span><span class="o">.</span><span class="n">undock_all_docked_objects</span><span class="p">()</span>
        <span class="c1"># store the type before it locked to the ladder and remove the dockable/one-way-platform types (if set)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">type_before_ladder</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">type</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;one_way_platform,dockable&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlatformerPhysics.unlock_ladder"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.unlock_ladder">[docs]</a>    <span class="k">def</span> <span class="nf">unlock_ladder</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Frees the GameObject from a ladder.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># restores the type we had before we locked into the ladder</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">type_before_ladder</span></div>

<div class="viewcode-block" id="PlatformerPhysics.push_back"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.push_back">[docs]</a>    <span class="k">def</span> <span class="nf">push_back</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pushes the GameObject in x direction for some number of frames (e.g. when being hit by an arrow). The force of the push is given as</span>
<span class="sd">        x-acceleration value being added to the already calculated normal physics acceleration values. E.g. the character&#39;s brain wants to go left:</span>
<span class="sd">        ax is then the running acceleration plus the value of the first item in the sequence. The sequence&#39;s first item is then removed.</span>

<span class="sd">        :param list sequence: a list of additive x-accelerations that will be applied (on top of the regular physics) to the GameObject frame by frame</span>
<span class="sd">         until the list is empty</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">push_back_list</span> <span class="o">=</span> <span class="n">sequence</span></div>

<div class="viewcode-block" id="PlatformerPhysics.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Needs to be called by the GameObject at some point during the GameObject&#39;s `tick` method.</span>
<span class="sd">        Determines x/y-speeds and moves the GameObject.</span>

<span class="sd">        :param GameLoop game_loop: the currently playing GameLoop object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">push_back_list</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">push_back_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="n">dockable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span>

        <span class="c1">#print(&quot;dt={} x={} vx={}&quot;.format(dt, obj.rect.x, self.vx))</span>

        <span class="c1"># entity has a brain component</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="p">:</span>
            <span class="c1"># determine x speed</span>
            <span class="c1"># -----------------</span>
            <span class="c1"># user is trying to move left or right (or both?)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;left&quot;</span><span class="p">]:</span>
                <span class="c1"># only left is pressed</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                    <span class="n">ax</span> <span class="o">+=</span> <span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span> <span class="ow">or</span> <span class="mi">999000000000</span><span class="p">)</span>  <span class="c1"># accelerate left</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># mirror other_sprite</span>

                    <span class="c1"># user is pressing left or right -&gt; leave on_ladder state</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
                <span class="c1"># user presses both keys (left and right) -&gt; just stop</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># only right is pressed</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="p">[</span><span class="s2">&quot;right&quot;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stops_abruptly_on_direction_change</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># stop first if still walking in other direction</span>
                <span class="n">ax</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">run_acceleration</span> <span class="ow">or</span> <span class="mi">999000000000</span>  <span class="c1"># accelerate right</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">flip</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="c1"># user is pressing left or right -&gt; leave on_ladder state</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
            <span class="c1"># stop immediately (vx=0; don&#39;t accelerate negatively)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># ax = 0; // already initalized to 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># determine y speed</span>
            <span class="c1"># -----------------</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># user is pressing &#39;up&#39; (ladder?)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;up&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="c1"># obj is currently locked into a ladder</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span><span class="p">:</span>
                    <span class="c1"># reached the top of the ladder -&gt; lock out of ladder</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">climb_speed</span>
                <span class="c1"># player locks into ladder</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&gt;=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lock_ladder</span><span class="p">()</span>
            <span class="c1"># user is pressing only &#39;down&#39; (ladder?)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;down&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span><span class="p">:</span>
                    <span class="c1"># we reached the bottom of the ladder -&gt; lock out of ladder</span>
                    <span class="k">if</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
                    <span class="c1"># move down</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">climb_speed</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="ow">and</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">lock_ladder</span><span class="p">()</span>
            <span class="c1"># jumping?</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">can_jump</span><span class="p">:</span>
                <span class="n">jump</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_brain</span><span class="o">.</span><span class="n">commands</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;jump&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">jump</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">disable_jump</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="ow">or</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">())</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">disable_jump</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">unlock_ladder</span><span class="p">()</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">jump_speed</span>
                        <span class="n">dockable</span><span class="o">.</span><span class="n">undock</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">disable_jump</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="c1"># entity has no steering unit (x-speed = 0)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># TODO: check the entity&#39;s magnitude of vx and vy,</span>
        <span class="c1"># reduce the max dt_step if necessary to prevent skipping through objects.</span>
        <span class="n">dt_step</span> <span class="o">=</span> <span class="n">dt</span>
        <span class="k">while</span> <span class="n">dt_step</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="mi">30</span><span class="p">,</span> <span class="n">dt_step</span><span class="p">)</span>

            <span class="c1"># update x/y-velocity based on acceleration</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">+=</span> <span class="n">ax</span> <span class="o">*</span> <span class="n">dt</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx_max</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx_max</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gravity_y</span> <span class="o">*</span> <span class="n">dt</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_fall_speed</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_fall_speed</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span>

            <span class="c1"># do we have to stop sinking?</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sinking_til</span> <span class="ow">and</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_sinking_til</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mf">0.0</span>

            <span class="c1"># reset all touch flags before doing all the collision analysis</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="c1"># self.slope_up_down = 0</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">at_wall</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="c1"># make docked state undetermined for now until we know more after the move + collision-detection</span>
                <span class="n">dockable</span><span class="o">.</span><span class="n">to_determine</span><span class="p">()</span>  <span class="c1"># we still keep in memory that we have been docked before and who we were docked to</span>

            <span class="c1"># first move in x-direction and solve x-collisions</span>
            <span class="n">orig_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">sx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">dt</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">sx</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
                <span class="c1"># if we were docked to a slope -&gt; move y component according to that slope&#39;s shape independent of y-speed</span>
                <span class="c1"># (and then still do the normal y-movement)</span>
                <span class="n">floor</span> <span class="o">=</span> <span class="n">dockable</span><span class="o">.</span><span class="n">docked_to</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">floor</span><span class="p">,</span> <span class="n">SlopedTileSprite</span><span class="p">)</span> <span class="ow">and</span> <span class="n">floor</span><span class="o">.</span><span class="n">slope</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">floor</span><span class="o">.</span><span class="n">sloped_xy_pull</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                    <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collide_in_one_direction</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">,</span> <span class="n">orig_pos</span><span class="p">)</span>

                <span class="c1">#print(&quot;dt={} sx={} vx={}&quot;.format(dt, sx, self.vx))</span>

            <span class="c1"># then move in y-direction and solve y-collisions</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">DEBUG_FLAGS</span> <span class="o">&amp;</span> <span class="n">DEBUG_RENDER_SPRITES_BEFORE_COLLISION_DETECTION</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="p">)</span>
                    <span class="n">game_loop</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">debug_refresh</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">collide_in_one_direction</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">,</span> <span class="n">orig_pos</span><span class="p">)</span>
                <span class="c1"># we are still not sure about our docked state after y-movement -&gt; confirm undock us</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_dockable</span><span class="o">.</span><span class="n">state_unsure</span><span class="p">():</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">game_obj_cmp_dockable</span><span class="o">.</span><span class="n">undock</span><span class="p">()</span>

            <span class="n">dt_step</span> <span class="o">-=</span> <span class="n">dt</span></div>

<div class="viewcode-block" id="PlatformerPhysics.collide_in_one_direction"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.collide_in_one_direction">[docs]</a>    <span class="k">def</span> <span class="nf">collide_in_one_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Detects and solves all possible collisions between our GameObject and all Stage&#39;s objects (layers and Sprites) in one direction (x or y).</span>

<span class="sd">        :param Sprite sprite: the GameObject of this Component (the moving/colliding Sprite)</span>
<span class="sd">        :param str direction: either &quot;x&quot; or &quot;y&quot;</span>
<span class="sd">        :param float direction_veloc: the velocity in the given direction (x/y-component of the velocity vector)</span>
<span class="sd">        :param Tuple[int,int] original_pos: the position of the game_object before this collision detection execution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stage</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">stage</span>

        <span class="c1"># default layers</span>
        <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">tiled_tile_layers</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">layer</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">collide_with_collision_layer</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>
        <span class="c1"># simple sprites (e.g. enemies)</span>
        <span class="k">for</span> <span class="n">other_sprite</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">sprites</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sprite</span> <span class="ow">is</span> <span class="n">other_sprite</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">&amp;</span> <span class="n">other_sprite</span><span class="o">.</span><span class="n">type</span><span class="p">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">other_sprite</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="o">=</span><span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="o">=</span><span class="n">original_pos</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">col</span><span class="p">:</span>
                    <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span></div>
        <span class="c1"># TODO: non-default layers (touch?)</span>
        <span class="c1"># for layer in stage.tiled_tile_layers.values():</span>
        <span class="c1">#    if not layer.type &amp; Sprite.get_type(&quot;default&quot;) and sprite.collision_mask &amp; layer.type:</span>
        <span class="c1">#        layer.collide(sprite, direction, direction_veloc, original_pos)</span>

<div class="viewcode-block" id="PlatformerPhysics.collide_with_collision_layer"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.collide_with_collision_layer">[docs]</a>    <span class="k">def</span> <span class="nf">collide_with_collision_layer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sprite</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collides a Sprite with a collision TiledTileLayer (type==default) and solves all detected collisions.</span>
<span class="sd">        Supports slopes of all shapes (given y = mx + b parameterized).</span>
<span class="sd">        Certain restrictions apply for the tiled landscape for this algorithm to work:</span>
<span class="sd">        - no upside-down slopes allowed (slopes on the ceiling)</span>
<span class="sd">        - TODO: what other restrictions?</span>

<span class="sd">        :param Sprite sprite: the Sprite to test for collisions against a TiledTileLayer</span>
<span class="sd">        :param TiledTileLayer layer: the TiledTileLayer object in which to look for collision tiles (full of sloped)</span>
<span class="sd">        :param str direction: `x` or `y` direction in which the sprite is currently moving before this test</span>
<span class="sd">        :param float direction_veloc: the velocity in the given direction (could be negative or positive)</span>
<span class="sd">        :param Tuple[int,int] original_pos: the position of the sprite before the move that caused this collision test to be executed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># determine the tile boundaries (which tiles does the sprite overlap with?)</span>
        <span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span><span class="p">,</span> <span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">get_overlapping_tiles</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>

        <span class="c1"># if sprite is moving in +/-x-direction:</span>
        <span class="c1"># 1) move in columns from left to right (right to left) to look for full collision tiles</span>
        <span class="c1"># - if the &#39;stairs&#39;-option is enabled: the full collision tile must not have any tile next to it (in negative direction_veloc direction)</span>
        <span class="c1"># that&#39;s an up-slope (towards the full collision tile)</span>
        <span class="c1"># - if the &#39;stairs&#39;-option is disabled: the full collision tile must not have a slope=1/-1 tile next to it that&#39;s an up slope (towards the full</span>
        <span class="c1"># collision tile)</span>
        <span class="c1"># 2) if one found, move Sprite out of it and that&#39;s it</span>
        <span class="c1"># 3) move again from top to bottom and in each row look for the highest slope under the Sprite</span>
        <span class="c1"># 4) if on e found that&#39;s not 0-height -&gt; process that (y-pull or y-push) and return</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="c1"># find full collision tiles (no reaching(!) slope neighbor in negative veloc direction)</span>
            <span class="c1"># - non-reaching slope neighbors are slopes whose highest point would not reach the full neighbor tile (is smaller than 1.0 * tileheight)</span>
            <span class="n">direction_x</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">tile_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_x</span> <span class="k">if</span> <span class="n">direction_x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tile_end_x</span><span class="p">,</span> <span class="p">(</span><span class="n">tile_end_x</span> <span class="k">if</span> <span class="n">direction_x</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">tile_start_x</span><span class="p">)</span> <span class="o">+</span> <span class="n">direction_x</span><span class="p">,</span> <span class="n">direction_x</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tile_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>  <span class="c1"># y-order doesn&#39;t matter</span>
                    <span class="n">tile_sprite</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">]</span>
                    <span class="c1"># TODO: make this work for non-full slope==0 tiles (e.g. half tiles where top half is missing)</span>
                    <span class="k">if</span> <span class="n">tile_sprite</span> <span class="ow">and</span> <span class="n">tile_sprite</span><span class="o">.</span><span class="n">is_full</span><span class="p">:</span>
                        <span class="c1"># is there a reaching slope in negative veloc direction? -&gt; return the neighbor reaching slope tile instead</span>
                        <span class="n">neighbor</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[(</span><span class="n">tile_x</span> <span class="o">-</span> <span class="n">direction_x</span><span class="p">),</span> <span class="n">tile_y</span><span class="p">]</span>
                        <span class="n">neighbor_border_y</span> <span class="o">=</span> <span class="n">neighbor</span><span class="o">.</span><span class="n">get_y</span><span class="p">(</span><span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tilewidth</span> <span class="k">if</span> <span class="n">direction_x</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span> <span class="k">if</span> <span class="n">neighbor</span> <span class="k">else</span> <span class="mi">0</span>
                        <span class="c1"># neighbor slope reaches til top of full tile OR neighbor slope-tile is at least 1px high and `stairs` option is enabled</span>
                        <span class="c1"># -&gt; do a y-collision on the full tile with low vy (to avoid crash/high impact)</span>
                        <span class="k">if</span> <span class="n">neighbor_border_y</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="c1"># neighbor slope reaches full tile OR stairs option enabled</span>
                            <span class="k">if</span> <span class="n">neighbor_border_y</span> <span class="o">&gt;=</span> <span class="n">tile_sprite</span><span class="o">.</span><span class="n">offset</span> <span class="o">*</span> <span class="n">layer</span><span class="o">.</span><span class="n">pytmx_tiled_map</span><span class="o">.</span><span class="n">tileheight</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">allow_stairs_climb</span><span class="p">:</span>
                                <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tile_sprite</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>
                            <span class="c1"># neighbor slope not high enough AND stairs option disabled -&gt; 1) bump up sprite on slope 2) solve x-collision against full tile</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="c1"># make sure the sprite is bumped up on the neighbor up-slope (this may already be done by the xy-pull if vx is not too high)</span>
                                <span class="k">if</span> <span class="n">sprite</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">is_docked</span><span class="p">():</span>
                                    <span class="n">sprite</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="p">(</span><span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">neighbor_border_y</span><span class="p">)))</span>
                                <span class="c1"># no stairs -&gt; bump against full tile from the side</span>
                                <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tile_sprite</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>
                        <span class="c1"># normal full-tile x-collision w/o neighbor slope</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tile_sprite</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>

                        <span class="k">assert</span> <span class="n">col</span><span class="p">,</span> <span class="s2">&quot;ERROR: there must be a col returned from collision detector for tile </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2"> neighbored by </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span>\
                            <span class="nb">format</span><span class="p">(</span><span class="n">tile_sprite</span><span class="o">.</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_sprite</span><span class="o">.</span><span class="n">tile_y</span><span class="p">,</span> <span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">tile_x</span> <span class="k">if</span> <span class="n">neighbor</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span><span class="p">),</span> <span class="p">(</span><span class="n">neighbor</span><span class="o">.</span><span class="n">tile_y</span> <span class="k">if</span> <span class="n">neighbor</span> <span class="k">else</span> <span class="s2">&quot;none&quot;</span><span class="p">))</span>

                        <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                        <span class="k">return</span>
            <span class="c1"># keep looking below (same algo as positive y-direction (falling))</span>

        <span class="c1"># if sprite is moving up: only check for full collision tiles (no upside-down/ceiling slopes supported yet)</span>
        <span class="k">elif</span> <span class="n">direction_veloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">tile_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_end_y</span><span class="p">,</span> <span class="n">tile_start_y</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">tile_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">tile_sprite</span> <span class="o">=</span> <span class="n">layer</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">tile_sprite</span> <span class="ow">and</span> <span class="n">tile_sprite</span><span class="o">.</span><span class="n">is_full</span><span class="p">:</span>
                        <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">tile_sprite</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>
                        <span class="k">assert</span> <span class="n">col</span><span class="p">,</span> <span class="s2">&quot;ERROR: there must be a col returned from collision detector for tile </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">)</span>
                        <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                        <span class="k">return</span>
            <span class="c1"># there was nothing above (no collision); have to return here not to go into following for-loop</span>
            <span class="k">return</span>

        <span class="c1"># either no full tile found for x-direction search</span>
        <span class="c1"># OR</span>
        <span class="c1"># y-direction and veloc &gt; 0:</span>
        <span class="c1"># move in rows from top to bottom, thereby - in each row - measuring the altitude of all tiles (slopes and full) and picking the</span>
        <span class="c1"># first highest tile in any row and then return after one highest tile (height &gt;0 px) is found</span>
        <span class="n">dockable</span> <span class="o">=</span> <span class="n">sprite</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span>
        <span class="n">is_docked</span> <span class="o">=</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">tile_y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_y</span><span class="p">,</span> <span class="n">tile_end_y</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">tiles_to_check</span> <span class="o">=</span> <span class="p">[</span><span class="n">layer</span><span class="o">.</span><span class="n">tile_sprites</span><span class="p">[</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">]</span> <span class="k">for</span> <span class="n">tile_x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">tile_start_x</span><span class="p">,</span> <span class="n">tile_end_x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
            <span class="p">(</span><span class="n">highest_tile</span><span class="p">,</span> <span class="n">highest_height</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_highest_tile</span><span class="p">(</span><span class="n">tiles_to_check</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">,</span> <span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span><span class="p">)</span>
            <span class="c1"># we found some high tile in this row -&gt; process and return</span>
            <span class="k">if</span> <span class="n">highest_tile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># y-direction (falling): deal with impact/docking/etc..</span>
                <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                    <span class="n">col</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="n">highest_tile</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">,</span> <span class="n">original_pos</span><span class="p">)</span>
                    <span class="k">assert</span> <span class="n">col</span><span class="p">,</span> <span class="s2">&quot;ERROR: there must be a col returned from collision detector (y) for tile </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">highest_tile</span><span class="o">.</span><span class="n">tile_x</span><span class="p">,</span> <span class="n">tile_y</span><span class="p">)</span>
                    <span class="c1"># fix our y-pull value via separate[1] (AABB does not know slopes, we have to adapt it to the slope&#39;s shape)</span>
                    <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">sprite</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="p">(</span><span class="n">highest_tile</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">highest_height</span><span class="p">))</span>
                    <span class="c1"># we were already docked on ground OR the y-pull is negative (up) -&gt; real collision</span>
                    <span class="k">if</span> <span class="n">is_docked</span> <span class="ow">or</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">sprite</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;collision&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                <span class="c1"># x-direction and no xy-pull applied yet b/c we are looking at a different slope tile than the docked one before</span>
                <span class="k">elif</span> <span class="n">highest_tile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dockable</span><span class="o">.</span><span class="n">docked_to</span><span class="p">:</span>
                    <span class="c1"># apply xy-pull to sprite (no collision)</span>
                    <span class="n">highest_tile</span><span class="o">.</span><span class="n">sloped_xy_pull</span><span class="p">(</span><span class="n">sprite</span><span class="p">)</span>
                    <span class="c1"># dock to this new tile (only if we are not currently in air)</span>
                    <span class="k">if</span> <span class="n">is_docked</span><span class="p">:</span>
                        <span class="n">dockable</span><span class="o">.</span><span class="n">dock_to</span><span class="p">(</span><span class="n">highest_tile</span><span class="p">)</span>
                <span class="c1"># keep docked tile the same</span>
                <span class="k">elif</span> <span class="n">is_docked</span><span class="p">:</span>
                    <span class="n">dockable</span><span class="o">.</span><span class="n">dock_to</span><span class="p">(</span><span class="n">dockable</span><span class="o">.</span><span class="n">docked_to</span><span class="p">)</span>

                <span class="k">return</span></div>

<div class="viewcode-block" id="PlatformerPhysics.collision"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.collision">[docs]</a>    <span class="k">def</span> <span class="nf">collision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets called (via event trigger &#39;collision&#39; (setup when this component is added to our GameObject)) when a collision is detected (e.g. by a layer).</span>

<span class="sd">        :param Collision col: the collision object of the detected collision (the first sprite in that Collision object must be our GameObject)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>
        <span class="k">assert</span> <span class="n">obj</span> <span class="ow">is</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span><span class="p">,</span> <span class="s2">&quot;ERROR: game_object (</span><span class="si">{}</span><span class="s2">) of physics component is not identical with passed in col.sprite1 (</span><span class="si">{}</span><span class="s2">)!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite1</span><span class="p">)</span>
        <span class="n">dockable</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;dockable&quot;</span><span class="p">]</span>

        <span class="k">assert</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="s2">&quot;sprite2&quot;</span><span class="p">),</span> <span class="s2">&quot;ERROR: no sprite2 in col-object!&quot;</span>
        <span class="n">other_obj</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite2</span>
        <span class="n">other_obj_physics</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;physics&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># getting hit by a particle (Arrow, ScorpionShot, Fireball, etc..)</span>
        <span class="k">if</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;particle&quot;</span><span class="p">):</span>
            <span class="c1"># shooter (this) is colliding with own shot -&gt; ignore</span>
            <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">shooter</span><span class="p">:</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;hit.particle&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                <span class="n">push_direction</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">!=</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">other_obj</span><span class="p">,</span> <span class="s2">&quot;vx&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">push_direction</span> <span class="o">!=</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">push_back</span><span class="p">([</span><span class="mi">500</span> <span class="o">*</span> <span class="n">push_direction</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># colliding with a one-way-platform: can only collide when coming from the top</span>
        <span class="c1"># -&gt; test early out here</span>
        <span class="k">if</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;one_way_platform&quot;</span><span class="p">):</span>
            <span class="c1"># other object is a ladder as well</span>
            <span class="k">if</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;ladder&quot;</span><span class="p">):</span>
                <span class="c1"># set touched_ladder to the ladder</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">touched_ladder</span> <span class="o">=</span> <span class="n">other_obj</span>
                <span class="c1"># we are locked into a ladder</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">on_ladder</span><span class="p">:</span>
                    <span class="k">return</span>
            <span class="c1"># we are x-colliding with the one-way-platform OR y-colliding in up direction OR y-colliding in down direction but not(!)</span>
            <span class="c1"># with the top of the one-way-platform -&gt; ignore collision and return</span>
            <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="n">col</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">original_pos</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="c1"># TODO: get rid of this:</span>
        <span class="c1"># a collision layer</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_obj</span><span class="p">,</span> <span class="n">TileSprite</span><span class="p">):</span>
            <span class="n">tile_props</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">tile_props</span>
            <span class="n">type_</span> <span class="o">=</span> <span class="n">tile_props</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;type&quot;</span><span class="p">)</span>
            <span class="c1"># colliding with an exit</span>
            <span class="k">if</span> <span class="n">type_</span> <span class="o">==</span> <span class="s2">&quot;exit&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">at_exit</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;reached_exit&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>  <span class="c1"># let the level know</span>
                <span class="k">return</span>
        <span class="c1"># a liquid body</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_obj</span><span class="p">,</span> <span class="n">LiquidBody</span><span class="p">):</span>
            <span class="c1"># just on first collision: pull up a little again, then slowly sink in (no more gravity)</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">collision_mask</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">is_sinking_til</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mf">0.01</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gravity</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;hit.liquid&quot;</span><span class="p">,</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">description</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># normal collision</span>
        <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">impact_x</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">)</span>
        <span class="n">impact_y</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">)</span>

        <span class="c1"># move away from the collision (back to where we were before)</span>
        <span class="n">x_orig</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span>
        <span class="n">y_orig</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># bottom collision</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.3</span><span class="p">:</span>
            <span class="c1"># a heavy object hit the ground -&gt; rock the stage</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_heavy</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">()</span> <span class="ow">and</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">stage</span><span class="o">.</span><span class="n">shake_viewport</span><span class="p">()</span>

            <span class="n">other_obj_dockable</span> <span class="o">=</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">components</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dockable&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

            <span class="c1"># squeezing something</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other_obj_physics</span><span class="p">,</span> <span class="n">PlatformerPhysics</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_heavy</span> <span class="ow">and</span> <span class="n">other_obj_physics</span><span class="o">.</span><span class="n">squeeze_speed</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> \
                    <span class="n">other_obj_dockable</span> <span class="ow">and</span> <span class="n">other_obj_dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">():</span>

                <span class="c1"># adjust the collision separation to the new squeezeSpeed</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="n">other_obj_physics</span><span class="o">.</span><span class="n">squeeze_speed</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_orig</span> <span class="o">-</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">other_obj_physics</span><span class="o">.</span><span class="n">squeeze_speed</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span><span class="p">),</span> <span class="n">absolute</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># otherwise, just undo the y-separation</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">obj</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="o">-</span><span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="n">other_obj_physics</span><span class="o">.</span><span class="n">squeeze_speed</span>
                <span class="n">other_obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;squeezed.top&quot;</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span>

            <span class="c1"># normal bottom collision</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="n">impact_y</span>
                <span class="n">dockable</span><span class="o">.</span><span class="n">dock_to</span><span class="p">(</span><span class="n">other_obj</span><span class="p">)</span>  <span class="c1"># dock to bottom object (collision layer, MovableRock, Ladder (top), etc..)</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.bottom&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># top collision</span>
        <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vy</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="n">impact_y</span>
            <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.top&quot;</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>

        <span class="c1"># left/right collisions</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">col</span><span class="o">.</span><span class="n">normal_x</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.3</span><span class="p">:</span>
            <span class="n">col</span><span class="o">.</span><span class="n">impact</span> <span class="o">=</span> <span class="n">impact_x</span>
            <span class="n">bump_wall</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># we hit a pushable object -&gt; check if it can move</span>
            <span class="k">if</span> <span class="n">other_obj_physics</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">other_obj_physics</span><span class="p">,</span> <span class="s2">&quot;is_pushable&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">other_obj_physics</span><span class="o">.</span><span class="n">is_pushable</span> <span class="ow">and</span> <span class="n">dockable</span><span class="o">.</span><span class="n">is_docked</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">push_an_object</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span>
                <span class="n">bump_wall</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="c1"># we hit a fixed wall (non-pushable)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">*</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># if normalX &lt; 0 -&gt; p.vx is &gt; 0 -&gt; set to 0; if normalX &gt; 0 -&gt; p.vx is &lt; 0 -&gt; set to 0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">bump_wall</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">if</span> <span class="n">bump_wall</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">other_obj</span><span class="o">.</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">Sprite</span><span class="o">.</span><span class="n">get_type</span><span class="p">(</span><span class="s2">&quot;default&quot;</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">at_wall</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">obj</span><span class="o">.</span><span class="n">trigger_event</span><span class="p">(</span><span class="s2">&quot;bump.&quot;</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;right&quot;</span> <span class="k">if</span> <span class="n">col</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="s2">&quot;left&quot;</span><span class="p">),</span> <span class="n">col</span><span class="p">)</span></div>

<div class="viewcode-block" id="PlatformerPhysics.push_an_object"><a class="viewcode-back" href="../spygame_reference.html#spygame.PlatformerPhysics.push_an_object">[docs]</a>    <span class="k">def</span> <span class="nf">push_an_object</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pusher</span><span class="p">,</span> <span class="n">col</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pushes a pushable other GameObject (assuming that this other object also has a PlatformerPhysics Component).</span>

<span class="sd">        :param pusher: the Sprite that&#39;s actively pushing against the other GameObject</span>
<span class="sd">        :param col: the Collision object (that caused the push) returned by the collision detector method</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">pushee</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">sprite2</span>  <span class="c1"># the object being pushed</span>
        <span class="n">orig_x</span> <span class="o">=</span> <span class="n">pushee</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span>
        <span class="n">pushee_phys</span> <span class="o">=</span> <span class="n">pushee</span><span class="o">.</span><span class="n">components</span><span class="p">[</span><span class="s2">&quot;physics&quot;</span><span class="p">]</span>
        <span class="c1"># calculate the amount to move in x-direction based on vx_max and the collision-separation</span>
        <span class="n">move_x</span> <span class="o">=</span> <span class="o">-</span> <span class="n">col</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pushee_phys</span><span class="o">.</span><span class="n">vx_max</span> <span class="o">/</span> <span class="n">col</span><span class="o">.</span><span class="n">direction_veloc</span><span class="p">)</span>
        <span class="c1"># adjust x-speed based on vx_max</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="n">pushee_phys</span><span class="o">.</span><span class="n">vx_max</span><span class="p">,</span> <span class="n">col</span><span class="o">.</span><span class="n">direction_veloc</span><span class="p">)</span>

        <span class="c1"># first move rock, then do a x-collision detection of the rock, then fix that collision (if any) -&gt; only then move the pusher</span>
        <span class="n">pushee</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">move_x</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># TODO: be careful not to overwrite the col object that&#39;s currently still being used by this method&#39;s caller</span>
        <span class="c1"># right now it&#39;s being overridden by the below call -&gt; it&#39;s not a problem yet because this collision object is only used further via the normal_x</span>
        <span class="c1"># property, which should stay the same</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">collide_in_one_direction</span><span class="p">(</span><span class="n">pushee</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span><span class="p">,</span> <span class="p">(</span><span class="n">orig_x</span><span class="p">,</span> <span class="n">pushee</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">))</span>
        <span class="c1"># re-align pusher with edge of pushee</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">vx</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">x_delta</span> <span class="o">=</span> <span class="n">pushee</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">pusher</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x_delta</span> <span class="o">=</span> <span class="n">pushee</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="o">-</span> <span class="n">pusher</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span>
        <span class="c1"># and we are done</span>
        <span class="n">pusher</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="n">x_delta</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Viewport"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport">[docs]</a><span class="k">class</span> <span class="nc">Viewport</span><span class="p">(</span><span class="n">Component</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A viewport is a component that can be added to a Stage to help that Stage render the scene depending on scrolling/obj_to_follow certain GameObjects</span>
<span class="sd">    - any GameObject with offset_x/y fields is supported, the Viewport will set these offsets to the Viewports x/y values</span>
<span class="sd">    before each render call</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param Display display: the Display object associated with this Viewport</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="s2">&quot;viewport&quot;</span><span class="p">)</span>  <span class="c1"># fix name to &#39;viewport&#39; (only one viewport per Stage)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">display</span>  <span class="c1"># the pygame display (Surface) to draw on; so far we only need it to get the display&#39;s dimensions</span>

        <span class="c1"># top/left corner (world coordinates) of the Viewport window</span>
        <span class="c1"># - will be used as offset_x/y for the Display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># parameters used for shaking the Viewport (if something heavy lands on the ground)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">is_shaking</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_y</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># the current shake-y-offset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_time_total</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_time_switch</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_frequency</span> <span class="o">=</span> <span class="mi">5</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="mf">1.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">directions</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="kc">None</span>

<div class="viewcode-block" id="Viewport.added"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.added">[docs]</a>    <span class="k">def</span> <span class="nf">added</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">,</span> <span class="n">Stage</span><span class="p">),</span> <span class="s2">&quot;ERROR: Viewport Component can only be added to a Stage, but game_objects is of type </span><span class="si">{}</span><span class="s2">!&quot;</span><span class="o">.</span>\
            <span class="nb">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;pre_render&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;pre_render&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">follow_object_with_viewport</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">unfollow_object_with_viewport</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">center_on_xy_with_viewport</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">move_to_xy_with_viewport</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shake_viewport</span><span class="p">)</span></div>

    <span class="c1"># EXTENSION methods (take self as well as GameObject as first two params)</span>
<div class="viewcode-block" id="Viewport.follow_object_with_viewport"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.follow_object_with_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">follow_object_with_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">obj_to_follow</span><span class="p">,</span> <span class="n">directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">bounding_box</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_speed</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes the viewport follow a GameObject (obj_to_follow).</span>

<span class="sd">        :param GameObject stage: our game_object (the Stage) that has `self` as component</span>
<span class="sd">        :param GameObject obj_to_follow: the GameObject that we should follow</span>
<span class="sd">        :param dict directions: dict with &#39;x&#39; and &#39;y&#39; set to either True or False depending on whether we follow only in x direction or y or both</span>
<span class="sd">        :param dict bounding_box: should contain min_x, max_x, min_y, max_y so we know the boundaries of the camera</span>
<span class="sd">        :param float max_speed: the max speed of the camera</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stage</span><span class="o">.</span><span class="n">off_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;follow&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">directions</span><span class="p">:</span>
            <span class="n">directions</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;x&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>

        <span class="c1"># this should be the level dimensions to avoid over-scrolling by the camera</span>
        <span class="c1"># - if we don&#39;t have a Level (just a Screen), use the display&#39;s size</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">bounding_box</span><span class="p">:</span>  <span class="c1"># get a default bounding box</span>
            <span class="c1"># TODO: this is very specific to us having always a Stage (with options[&#39;screen_obj&#39;]) as our owning stage</span>
            <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">width</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;width&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_width</span><span class="p">()</span>
            <span class="n">h</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">height</span> <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">game_object</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="s2">&quot;height&quot;</span><span class="p">)</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">surface</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
            <span class="n">bounding_box</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;min_x&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;min_y&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;max_x&quot;</span><span class="p">:</span> <span class="n">w</span><span class="p">,</span> <span class="s2">&quot;max_y&quot;</span><span class="p">:</span> <span class="n">h</span><span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">directions</span> <span class="o">=</span> <span class="n">directions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span> <span class="o">=</span> <span class="n">obj_to_follow</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span> <span class="o">=</span> <span class="n">bounding_box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span> <span class="o">=</span> <span class="n">max_speed</span>
        <span class="n">stage</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;follow&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">follow</span><span class="p">(</span><span class="n">first</span><span class="o">=</span><span class="p">(</span><span class="kc">False</span> <span class="k">if</span> <span class="n">max_speed</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="k">else</span> <span class="kc">True</span><span class="p">))</span>  <span class="c1"># start following</span></div>

<div class="viewcode-block" id="Viewport.unfollow_object_with_viewport"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.unfollow_object_with_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">unfollow_object_with_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Stops following.</span>

<span class="sd">        :param GameObject stage: our game_object (the Stage) that has `self` as component</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stage</span><span class="o">.</span><span class="n">off_event</span><span class="p">(</span><span class="s2">&quot;post_tick&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;follow&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span> <span class="o">=</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="Viewport.center_on_xy_with_viewport"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.center_on_xy_with_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">center_on_xy_with_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Centers the Viewport on a given x/y position (so that the x/y position is in the center of the screen afterwards).</span>

<span class="sd">        :param GameObject stage: our game_object (the Stage) that has `self` as component</span>
<span class="sd">        :param int x: the x position to center on</span>
<span class="sd">        :param int y: the y position to center on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">center_on</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Viewport.move_to_xy_with_viewport"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.move_to_xy_with_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">move_to_xy_with_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves the Viewport to the given x/y position (top-left corner, not center(!)).</span>

<span class="sd">        :param GameObject stage: our game_object (the Stage) that has `self` as Component</span>
<span class="sd">        :param int x: the x position to move to</span>
<span class="sd">        :param int y: the y position to move to</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">move_to</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span></div>

<div class="viewcode-block" id="Viewport.shake_viewport"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.shake_viewport">[docs]</a>    <span class="k">def</span> <span class="nf">shake_viewport</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stage</span><span class="p">,</span> <span class="n">time</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">frequency</span><span class="o">=</span><span class="mi">5</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shakes the Viewport object for the given time and with the given frequency.</span>

<span class="sd">        :param GameObject stage: our game_object (the Stage) that has `self` as Component</span>
<span class="sd">        :param float time: the amount of time (in sec) for which the Viewport should shake</span>
<span class="sd">        :param floar frequency: the frequency (in up/down shakes per second) with which we should shake; higher numbers mean more rapid shaking</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">is_shaking</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_time_total</span> <span class="o">=</span> <span class="n">time</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_frequency</span> <span class="o">=</span> <span class="n">frequency</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shake_time_switch</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="n">frequency</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># after this time, we have to switch direction (2 b/c up and down)</span></div>
    <span class="c1"># END: EXTENSION METHODS</span>

<div class="viewcode-block" id="Viewport.follow"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.follow">[docs]</a>    <span class="k">def</span> <span class="nf">follow</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">first</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Helper method to follow our self.obj_to_follow (should not be called by the API user).</span>
<span class="sd">        Called when the Stage triggers Event &#39;post_tick&#39; (passes GameLoop into it which is not used).</span>

<span class="sd">        :param GameLoop game_loop: the GameLoop that&#39;s currently playing</span>
<span class="sd">        :param bool first: whether this is the very first call to this function (if so, do a hard center on, otherwise a soft-center-on)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">follow_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span>
        <span class="n">follow_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">](</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span><span class="p">)</span> <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">])</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">directions</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span>

        <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">center_on</span> <span class="k">if</span> <span class="n">first</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">soft_center_on</span>
        <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">centerx</span> <span class="k">if</span> <span class="n">follow_x</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj_to_follow</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">centery</span> <span class="k">if</span> <span class="n">follow_y</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="Viewport.soft_center_on"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.soft_center_on">[docs]</a>    <span class="k">def</span> <span class="nf">soft_center_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Soft-centers on a given x/y position respecting the Viewport&#39;s max_speed property (unlike center_on).</span>

<span class="sd">        :param Union[int,None] x: the x position to center on (None if we should ignore the x position)</span>
<span class="sd">        :param Union[int,None] y: the y position to center on (None if we should ignore the y position)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>  <span class="c1"># //, this.followMaxSpeed);</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span><span class="p">:</span>
                <span class="n">dx</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;min_x&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;min_x&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">dx</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;max_x&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;max_x&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">width</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dx</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">+=</span> <span class="n">dx</span>

        <span class="k">if</span> <span class="n">y</span><span class="p">:</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span><span class="p">:</span>
                <span class="n">dy</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">copysign</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">max_speed</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;min_y&quot;</span><span class="p">]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;min_y&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">dy</span> <span class="o">&gt;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;max_y&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bounding_box</span><span class="p">[</span><span class="s2">&quot;max_y&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">height</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">dy</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">+=</span> <span class="n">dy</span></div>

<div class="viewcode-block" id="Viewport.center_on"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.center_on">[docs]</a>    <span class="k">def</span> <span class="nf">center_on</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Centers on a given x/y position without(!) respecting the Viewport&#39;s max_speed property (unlike soft_center_on).</span>

<span class="sd">        :param Union[int,None] x: the x position to center on (None if we should ignore the x position)</span>
<span class="sd">        :param Union[int,None] y: the y position to center on (None if we should ignore the y position)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span></div>

<div class="viewcode-block" id="Viewport.move_to"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.move_to">[docs]</a>    <span class="k">def</span> <span class="nf">move_to</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Moves the Viewport to a given x/y position (top-left corner, not centering) without(!) respecting the Viewport&#39;s max_speed property.</span>

<span class="sd">        :param Union[int,None] x: the x position to move to (None if we should ignore the x position)</span>
<span class="sd">        :param Union[int,None] y: the y position to move to (None if we should ignore the y position)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">if</span> <span class="n">y</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">game_object</span>  <span class="c1"># ?? why</span></div>

<div class="viewcode-block" id="Viewport.tick"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.tick">[docs]</a>    <span class="k">def</span> <span class="nf">tick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">game_loop</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_shaking</span><span class="p">:</span>
            <span class="n">dt</span> <span class="o">=</span> <span class="n">game_loop</span><span class="o">.</span><span class="n">dt</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">shake_time_total</span> <span class="o">-=</span> <span class="n">dt</span></div>
            <span class="c1"># done shaking</span>

<div class="viewcode-block" id="Viewport.pre_render"><a class="viewcode-back" href="../spygame_reference.html#spygame.Viewport.pre_render">[docs]</a>    <span class="k">def</span> <span class="nf">pre_render</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">display</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the offset property of the given Display so that it matches our (previously) calculated x/y values.</span>

<span class="sd">        :param Display display: the Display, whose offset we will change here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">offsets</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">y</span></div></div>


<div class="viewcode-block" id="Screen"><a class="viewcode-back" href="../spygame_reference.html#spygame.Screen">[docs]</a><span class="k">class</span> <span class="nc">Screen</span><span class="p">(</span><span class="n">EventObject</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Screen object has a play and a done method that need to be implemented.</span>
<span class="sd">    The play method stages the Screen on a Stage.</span>
<span class="sd">    The done method can do some cleanup.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;start&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># type: int</span>

        <span class="c1"># handle keyboard inputs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">,</span> <span class="n">KeyboardInputs</span><span class="p">([]))</span>  <span class="c1"># type: KeyboardInputs</span>
        <span class="c1"># our Display object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;display&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># type: Display</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;max_fps&quot;</span><span class="p">,</span> <span class="mi">60</span><span class="p">)</span>  <span class="c1"># type: float</span>

<div class="viewcode-block" id="Screen.play"><a class="viewcode-back" href="../spygame_reference.html#spygame.Screen.play">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="Screen.done"><a class="viewcode-back" href="../spygame_reference.html#spygame.Screen.done">[docs]</a>    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="SimpleScreen"><a class="viewcode-back" href="../spygame_reference.html#spygame.SimpleScreen">[docs]</a><span class="k">class</span> <span class="nc">SimpleScreen</span><span class="p">(</span><span class="n">Screen</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple Screen that has support for labels and sprites (static images) shown on the screen.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sprites</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sprites&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;sprites&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="p">[])</span>
        <span class="c1"># labels example: {x: Q.width / 2, y: 220, w: 150, label: &quot;NEW GAME&quot;, color: &quot;white&quot;, align: &quot;left&quot;, weight: &quot;900&quot;, size: 22, family: &quot;Fixedsys&quot;},</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;labels&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;labels&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span> <span class="k">else</span> <span class="p">[])</span>
        <span class="c1">## TODO: audio? self.audio = kwargs[&quot;audio&quot;] if &quot;audio&quot; in kwargs else []</span>

<div class="viewcode-block" id="SimpleScreen.screen_func"><a class="viewcode-back" href="../spygame_reference.html#spygame.SimpleScreen.screen_func">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">screen_func</span><span class="p">(</span><span class="n">stage</span><span class="p">:</span> <span class="n">Stage</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Defines this screen&#39;s Stage setup.</span>
<span class="sd">        Stage functions are used to setup a Stage (before playing it).</span>

<span class="sd">        :param Stage stage: the Stage to be setup</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get the Screen object (instance) from the options</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="n">stage</span><span class="o">.</span><span class="n">options</span><span class="p">[</span><span class="s2">&quot;screen_obj&quot;</span><span class="p">]</span>

        <span class="c1"># insert labels to screen</span>
        <span class="k">for</span> <span class="n">label_def</span> <span class="ow">in</span> <span class="n">screen</span><span class="o">.</span><span class="n">labels</span><span class="p">:</span>
            <span class="c1"># generate new Font object</span>
            <span class="n">font</span> <span class="o">=</span> <span class="n">pygame</span><span class="o">.</span><span class="n">font</span><span class="o">.</span><span class="n">Font</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">])</span>
            <span class="n">surf</span> <span class="o">=</span> <span class="n">font</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;text&quot;</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pygame</span><span class="o">.</span><span class="n">Color</span><span class="p">(</span><span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;color&quot;</span><span class="p">]))</span>
            <span class="n">sprite</span> <span class="o">=</span> <span class="n">Sprite</span><span class="p">(</span><span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">label_def</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">surf</span><span class="p">)</span>
            <span class="n">stage</span><span class="o">.</span><span class="n">add_sprite</span><span class="p">(</span><span class="n">sprite</span><span class="p">,</span> <span class="s2">&quot;labels&quot;</span><span class="p">)</span>

        <span class="c1"># insert objects to screen</span>
        <span class="k">for</span> <span class="n">game_obj</span> <span class="ow">in</span> <span class="n">screen</span><span class="o">.</span><span class="n">game_objects</span><span class="p">:</span>
            <span class="n">stage</span><span class="o">.</span><span class="n">add_sprite</span><span class="p">(</span><span class="n">game_obj</span><span class="p">,</span> <span class="s2">&quot;sprites&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleScreen.play"><a class="viewcode-back" href="../spygame_reference.html#spygame.SimpleScreen.play">[docs]</a>    <span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plays the Screen.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># start screen (will overwrite the old 0-stage (=main-stage))</span>
        <span class="c1"># - also, will give our keyboard-input setup to the new GameLoop object</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">stage_screen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SimpleScreen</span><span class="o">.</span><span class="n">screen_func</span><span class="p">,</span> <span class="n">stage_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimpleScreen.done"><a class="viewcode-back" href="../spygame_reference.html#spygame.SimpleScreen.done">[docs]</a>    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;we&#39;re done!&quot;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Level"><a class="viewcode-back" href="../spygame_reference.html#spygame.Level">[docs]</a><span class="k">class</span> <span class="nc">Level</span><span class="p">(</span><span class="n">Screen</span><span class="p">,</span> <span class="n">metaclass</span><span class="o">=</span><span class="n">ABCMeta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Level class adds tmx file support to the Screen.</span>
<span class="sd">    TiledTileLayers (background, collision, foreground, etc..) as well as single Sprite objects can be defined in the tmx file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># TODO: warn here if keyboard_inputs is given (should be given in tmx file exclusively)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">tmx_file</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tmx_file&quot;</span><span class="p">,</span> <span class="s2">&quot;data/&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;.tmx&quot;</span><span class="p">)</span>
        <span class="c1"># load in the world&#39;s tmx file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span> <span class="o">=</span> <span class="n">pytmx</span><span class="o">.</span><span class="n">load_pygame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tmx_file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">width</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">width</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">tilewidth</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">height</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">tileheight</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">register_event</span><span class="p">(</span><span class="s2">&quot;mastered&quot;</span><span class="p">,</span> <span class="s2">&quot;aborted&quot;</span><span class="p">,</span> <span class="s2">&quot;lost&quot;</span><span class="p">)</span>

        <span class="c1"># get keyboard_inputs directly from the pytmx object</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="p">:</span>
            <span class="n">key_list</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">properties</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">key_list</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;ERROR: tmx file needs a global map property `keyboard_inputs` such as e.g. `up,down,left,right`&quot;</span>
            <span class="n">descriptions</span> <span class="o">=</span> <span class="n">key_list</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">KeyboardInputs</span><span class="p">(</span><span class="n">descriptions</span><span class="p">)</span>

    <span class="c1"># populates a Stage with this Level by going through the tmx file layer by layer and adding it</span>
    <span class="c1"># - unlike SimpleScreen, uses only the tmx file for adding things to the Stage</span>
<div class="viewcode-block" id="Level.screen_func"><a class="viewcode-back" href="../spygame_reference.html#spygame.Level.screen_func">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">screen_func</span><span class="p">(</span><span class="n">stage</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up the Stage by adding all layers (one-by-one) from the tmx file to the Stage.</span>

<span class="sd">        :param Stage stage:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="p">,</span> <span class="n">Level</span><span class="p">),</span> <span class="s2">&quot;ERROR: screen property of a Stage that uses Level.screen_func to stage a Screen must be a Level object!&quot;</span>

        <span class="c1"># force add the default physics functions to the Stage&#39;s options</span>
        <span class="n">defaults</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">options</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;components&quot;</span><span class="p">:</span> <span class="p">[</span><span class="n">Viewport</span><span class="p">(</span><span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">display</span><span class="p">)],</span>
                                 <span class="s2">&quot;physics_collision_detector&quot;</span><span class="p">:</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">collide</span><span class="p">,</span>
                                 <span class="s2">&quot;tile_sprite_handler&quot;</span><span class="p">:</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">PhysicsComponent</span><span class="o">.</span><span class="n">tile_sprite_handler</span><span class="p">,</span> <span class="n">TileSprite</span><span class="p">)</span>
                                 <span class="p">})</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">tmx_obj</span><span class="o">.</span><span class="n">layers</span><span class="p">:</span>
            <span class="n">stage</span><span class="o">.</span><span class="n">add_tiled_layer</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">stage</span><span class="o">.</span><span class="n">screen</span><span class="o">.</span><span class="n">tmx_obj</span><span class="p">)</span></div>

<div class="viewcode-block" id="Level.play"><a class="viewcode-back" href="../spygame_reference.html#spygame.Level.play">[docs]</a>    <span class="k">def</span> <span class="nf">play</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Start level (stage the scene; will overwrite the old 0-stage (=main-stage)).</span>
<span class="sd">        The options-object below will be also stored in [Stage object].options.</span>
<span class="sd">        Child Level classes only need to do these three things: a) stage a screen, b) register some possible events, c) play a new game loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">stage_screen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">stage_idx</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;tile_sprite_handler&quot;</span><span class="p">:</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="n">PhysicsComponent</span><span class="o">.</span><span class="n">tile_sprite_handler</span><span class="p">,</span> <span class="n">TileSprite</span><span class="p">),</span>
            <span class="c1">#&quot;components&quot;: [Viewport(self.display)]</span>
        <span class="p">})</span>

        <span class="c1"># activate level triggers</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;agent_reached_exit&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;done&quot;</span><span class="p">,</span> <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># play a new GameLoop giving it some options</span>
        <span class="n">GameLoop</span><span class="o">.</span><span class="n">play_a_loop</span><span class="p">(</span><span class="n">screen_obj</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span></div>

<div class="viewcode-block" id="Level.done"><a class="viewcode-back" href="../spygame_reference.html#spygame.Level.done">[docs]</a>    <span class="k">def</span> <span class="nf">done</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">get_stage</span><span class="p">()</span><span class="o">.</span><span class="n">stop</span><span class="p">()</span>

        <span class="c1"># switch off keyboard</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">keyboard_inputs</span><span class="o">.</span><span class="n">update_keys</span><span class="p">([])</span>  <span class="c1"># empty list -&gt; no more keys</span></div></div>


<div class="viewcode-block" id="Game"><a class="viewcode-back" href="../spygame_reference.html#spygame.Game">[docs]</a><span class="k">class</span> <span class="nc">Game</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object that serves as a container for Screen and Level objects.</span>
<span class="sd">    Manages displaying the screens (start screen, menus, etc..) and playable levels of the game.</span>
<span class="sd">    Also keeps a Display object (and determines its size), which is used for rendering and displaying the game.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">instantiated</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">screens_and_levels</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s2">&quot;spygame Demo!&quot;</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="mi">60</span><span class="p">,</span> <span class="n">debug_flags</span><span class="o">=</span><span class="n">DEBUG_NONE</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param list screens_and_levels: a list of Screen and Level definitions. Each item is a dict with</span>
<span class="sd">        :param int width: the width of the screen in pixels (0 for auto)</span>
<span class="sd">        :param int height: the height of the screen in pixels (0 for auto)</span>
<span class="sd">        :param str title: the title of the game (will be displayed as the game Window caption)</span>
<span class="sd">        :param int max_fps: the max. number of frames in one second (could be less if Game runs slow, but never more)</span>
<span class="sd">        :param int debug_flags: a bitmap for setting different debug flags (see global variables DEBUG_...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="ow">not</span> <span class="n">Game</span><span class="o">.</span><span class="n">instantiated</span><span class="p">,</span> <span class="s2">&quot;ERROR: can only create one </span><span class="si">{}</span><span class="s2"> object!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">Game</span><span class="o">.</span><span class="n">instantiated</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># init the pygame module (if this did not already happen)</span>
        <span class="n">pygame</span><span class="o">.</span><span class="n">init</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">screens_by_name</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># holds the Screen objects by key=level-name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">screens</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># list of screens</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels_by_name</span> <span class="o">=</span> <span class="p">{}</span>  <span class="c1"># holds the Level objects by key=level-name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">levels</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># sorted list of levels</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span> <span class="o">=</span> <span class="n">max_fps</span>

        <span class="c1"># try this: set debug flags globally</span>
        <span class="k">global</span> <span class="n">DEBUG_FLAGS</span>
        <span class="n">DEBUG_FLAGS</span> <span class="o">=</span> <span class="n">debug_flags</span>

        <span class="c1"># create the Display object for the entire game: we pass it to all levels and screen objects</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">display</span> <span class="o">=</span> <span class="n">Display</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>  <span class="c1"># use widthxheight for now (default); this will be reset to the largest Level dimensions further below</span>

        <span class="c1"># our levels (if any) determine the size of the display</span>
        <span class="n">get_w_from_levels</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">width</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>
        <span class="n">get_h_from_levels</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">height</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="kc">False</span>

        <span class="c1"># initialize all screens and levels</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">screen_or_level</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">screens_and_levels</span><span class="p">):</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="s2">&quot;screen</span><span class="si">{:02d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
            <span class="n">id_</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">keyboard_inputs</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;keyboard_inputs&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="n">max_fps</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;max_fps&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_fps</span><span class="p">)</span>

            <span class="c1"># Screen class has to be given since Screen (as a default) would be abstract</span>
            <span class="k">assert</span> <span class="s2">&quot;class&quot;</span> <span class="ow">in</span> <span class="n">screen_or_level</span><span class="p">,</span> <span class="s2">&quot;ERROR: Game object needs the &#39;class&#39; property for all given Screens and Levels!&quot;</span>
            <span class="k">assert</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">screen_or_level</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">],</span> <span class="n">Screen</span><span class="p">),</span> <span class="s2">&quot;ERROR: Game object needs the &#39;class&#39; property to be a subclass of Screen!&quot;</span>
            <span class="n">class_</span> <span class="o">=</span> <span class="n">screen_or_level</span><span class="p">[</span><span class="s2">&quot;class&quot;</span><span class="p">]</span>
            <span class="c1"># only distinguish between Level and &quot;regular&quot; Screen</span>
            <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">class_</span><span class="p">,</span> <span class="n">Level</span><span class="p">):</span>
                <span class="n">level</span> <span class="o">=</span> <span class="n">class_</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">,</span> <span class="n">keyboard_inputs</span><span class="o">=</span><span class="n">keyboard_inputs</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="n">max_fps</span><span class="p">,</span> <span class="o">**</span><span class="n">screen_or_level</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels_by_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">level</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
                <span class="c1"># register events</span>
                <span class="n">level</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;mastered&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;level_mastered&quot;</span><span class="p">)</span>
                <span class="n">level</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;aborted&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;level_aborted&quot;</span><span class="p">)</span>
                <span class="n">level</span><span class="o">.</span><span class="n">on_event</span><span class="p">(</span><span class="s2">&quot;lost&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;level_lost&quot;</span><span class="p">)</span>
                <span class="c1"># store level dimensions for display</span>
                <span class="k">if</span> <span class="n">get_w_from_levels</span> <span class="ow">and</span> <span class="n">level</span><span class="o">.</span><span class="n">width</span> <span class="o">&gt;</span> <span class="n">width</span><span class="p">:</span>
                    <span class="n">width</span> <span class="o">=</span> <span class="n">level</span><span class="o">.</span><span class="n">width</span>
                <span class="k">if</span> <span class="n">get_h_from_levels</span> <span class="ow">and</span> <span class="n">level</span><span class="o">.</span><span class="n">height</span> <span class="o">&gt;</span> <span class="n">height</span><span class="p">:</span>
                    <span class="n">height</span> <span class="o">=</span> <span class="n">level</span><span class="o">.</span><span class="n">height</span>
            <span class="c1"># a Screen</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">screen</span> <span class="o">=</span> <span class="n">class_</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="nb">id</span><span class="o">=</span><span class="n">id_</span><span class="p">,</span> <span class="n">display</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="p">,</span> <span class="n">keyboard_inputs</span><span class="o">=</span><span class="n">keyboard_inputs</span><span class="p">,</span> <span class="n">max_fps</span><span class="o">=</span><span class="n">max_fps</span><span class="p">,</span> <span class="o">**</span><span class="n">screen_or_level</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">screens_by_name</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">screen</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">screens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">screen</span><span class="p">)</span>

        <span class="c1"># now that we know all Level sizes, change the dims of the pygame.display if width and/or height were Level-dependent</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">get_w_from_levels</span> <span class="ow">and</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">get_h_from_levels</span> <span class="ow">and</span> <span class="n">height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="c1"># static method</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">display</span><span class="o">.</span><span class="n">change_dims</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span>

<div class="viewcode-block" id="Game.get_next_level"><a class="viewcode-back" href="../spygame_reference.html#spygame.Game.get_next_level">[docs]</a>    <span class="k">def</span> <span class="nf">get_next_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        returns the next level (if exists) as object; None if no next level</span>

<span class="sd">        :param Level level: the Level, whose next Level we would like to get</span>
<span class="sd">        :return: the next Level after level; None if no next Level exists</span>
<span class="sd">        :rtype: Union[Level,None]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">next_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">levels</span><span class="p">[(</span><span class="n">level</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">else</span> <span class="n">level</span><span class="o">.</span><span class="n">id</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
            <span class="n">next_</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">next_</span></div>

<div class="viewcode-block" id="Game.level_mastered"><a class="viewcode-back" href="../spygame_reference.html#spygame.Game.level_mastered">[docs]</a>    <span class="k">def</span> <span class="nf">level_mastered</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a level has been successfully finished -&gt; play next one</span>

<span class="sd">        :param Level level: the Level object that has been mastered</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">next_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_level</span><span class="p">(</span><span class="n">level</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">next_</span><span class="p">:</span>
            <span class="n">next_</span><span class="o">.</span><span class="n">play</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;All done!! Congrats!!&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">level_aborted</span><span class="p">(</span><span class="n">level</span><span class="p">)</span></div>

<div class="viewcode-block" id="Game.level_lost"><a class="viewcode-back" href="../spygame_reference.html#spygame.Game.level_lost">[docs]</a>    <span class="k">def</span> <span class="nf">level_lost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        a level has been lost</span>

<span class="sd">        :param Level level: the Level object in which the loss happened</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Game Over!&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">level_aborted</span><span class="p">(</span><span class="n">level</span><span class="p">)</span></div>

<div class="viewcode-block" id="Game.level_aborted"><a class="viewcode-back" href="../spygame_reference.html#spygame.Game.level_aborted">[docs]</a>    <span class="k">def</span> <span class="nf">level_aborted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        aborts the level and tries to play the &quot;start&quot; screen</span>

<span class="sd">        :param Level level: the Level object that has been aborted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Stage</span><span class="o">.</span><span class="n">clear_stages</span><span class="p">()</span>
        <span class="n">screen</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">screens_by_name</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;start&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">screen</span><span class="p">:</span>
            <span class="n">screen</span><span class="o">.</span><span class="n">play</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quit</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="CollisionAlgorithm"><a class="viewcode-back" href="../spygame_reference.html#spygame.CollisionAlgorithm">[docs]</a><span class="k">class</span> <span class="nc">CollisionAlgorithm</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A static class that is used to store a collision algorithm.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># the default collision objects</span>
    <span class="c1"># - can be overridden via the collide method</span>
    <span class="n">default_collision_objects</span> <span class="o">=</span> <span class="p">(</span><span class="n">Collision</span><span class="p">(),</span> <span class="n">Collision</span><span class="p">())</span>

<div class="viewcode-block" id="CollisionAlgorithm.collide"><a class="viewcode-back" href="../spygame_reference.html#spygame.CollisionAlgorithm.collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="nd">@abstractmethod</span>
    <span class="k">def</span> <span class="nf">collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        solves a simple spatial collision problem for two Sprites (that have a rect property)</span>
<span class="sd">        - defaults to SAT collision between two objects</span>
<span class="sd">        - thanks to doc&#39;s at: http://www.sevenson.com.au/actionscript/sat/</span>
<span class="sd">        - TODO: handle angles on objects</span>
<span class="sd">        - TODO: handle velocities of sprites prior to collision to calculate correct normals</span>

<span class="sd">        :param Sprite sprite1: sprite 1</span>
<span class="sd">        :param Sprite sprite2: sprite 2 (the other sprite)</span>
<span class="sd">        :param Union[None,Tuple[Collision]] collision_objects: the two always-recycled returnable Collision instances (aside from None); if None,</span>
<span class="sd">            use our default ones</span>
<span class="sd">        :param Union[Tuple[int],None] original_pos: the position of sprite1 before doing the move that lead to this collision-detection call</span>
<span class="sd">        :return: a Collision object with all details of the collision between the two Sprites (None if there is no collision)</span>
<span class="sd">        :rtype: Union[None,Collision]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span></div></div>


<div class="viewcode-block" id="AABBCollision"><a class="viewcode-back" href="../spygame_reference.html#spygame.AABBCollision">[docs]</a><span class="k">class</span> <span class="nc">AABBCollision</span><span class="p">(</span><span class="n">CollisionAlgorithm</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A simple axis-aligned bounding-box collision mechanism which only works on Pygame rects.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="AABBCollision.collide"><a class="viewcode-back" href="../spygame_reference.html#spygame.AABBCollision.collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">original_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># TODO: actually, we only need one collision object as we should always only resolve one object at a time</span>

        <span class="c1"># TODO: utilize direction veloc information to only return the smallest separation collision</span>

        <span class="c1"># use default CollisionObjects?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">collision_objects</span><span class="p">:</span>
            <span class="n">collision_objects</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">default_collision_objects</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="n">AABBCollision</span><span class="o">.</span><span class="n">try_collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="o">.</span><span class="n">is_collided</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># fill in some more values in the recycled Collision object before returning it</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">ret</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">normal_x</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">ret</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">normal_y</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">original_pos</span><span class="p">:</span>
            <span class="n">original_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">original_pos</span> <span class="o">=</span> <span class="n">original_pos</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="AABBCollision.try_collide"><a class="viewcode-back" href="../spygame_reference.html#spygame.AABBCollision.try_collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">try_collide</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">collision_obj</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">direction_veloc</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        does the actual AABB collision test</span>

<span class="sd">        :param Sprite o1: object 1</span>
<span class="sd">        :param Sprite o2: object 2</span>
<span class="sd">        :param Collision collision_obj: the collision object to be populated</span>
<span class="sd">        :param str direction: the direction in which we have to measure a collision (x or y)</span>
<span class="sd">        :param float direction_veloc: the velocity value in the given x- or y-direction</span>
<span class="sd">        :return: the populated Collision object</span>
<span class="sd">        :rtype: Collision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span> <span class="ow">or</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;ERROR: parameter direction needs to be either &#39;x&#39; or &#39;y&#39;!&quot;</span>

        <span class="c1"># reset the recycled collision object</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">direction_veloc</span> <span class="o">=</span> <span class="n">direction_veloc</span>

        <span class="c1"># overlap?</span>
        <span class="k">if</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="ow">and</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="ow">and</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&gt;</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="ow">and</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="o">&lt;</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span><span class="p">:</span>
            <span class="n">collision_obj</span><span class="o">.</span><span class="n">sprite1</span> <span class="o">=</span> <span class="n">o1</span>
            <span class="n">collision_obj</span><span class="o">.</span><span class="n">sprite2</span> <span class="o">=</span> <span class="n">o2</span>
            <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction_veloc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="k">elif</span> <span class="n">direction_veloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">-</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">)</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="mf">1.0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">direction_veloc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span>
                <span class="k">elif</span> <span class="n">direction_veloc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">-</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span><span class="p">)</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="n">collision_obj</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">collision_obj</span> <span class="k">if</span> <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="k">else</span> <span class="kc">None</span></div></div>


<span class="c1"># TODO: SATCollisions are WIP</span>
<div class="viewcode-block" id="SATCollision"><a class="viewcode-back" href="../spygame_reference.html#spygame.SATCollision">[docs]</a><span class="k">class</span> <span class="nc">SATCollision</span><span class="p">(</span><span class="n">CollisionAlgorithm</span><span class="p">):</span>
    <span class="n">normal</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]</span>

<div class="viewcode-block" id="SATCollision.collide"><a class="viewcode-back" href="../spygame_reference.html#spygame.SATCollision.collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">original_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># use default CollisionObjects?</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">collision_objects</span><span class="p">:</span>
            <span class="n">collision_objects</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">default_collision_objects</span>

        <span class="c1"># do AABB first for a likely early out</span>
        <span class="c1"># TODO: right now, we only have pygame.Rect anyway, so these are AABBs</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">bottom</span> <span class="o">&lt;</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">top</span> <span class="ow">or</span>
                    <span class="n">sprite2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span> <span class="ow">or</span> <span class="n">sprite2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">right</span> <span class="o">&lt;</span> <span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">test</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">try_collide</span><span class="p">(</span><span class="n">sprite1</span><span class="p">,</span> <span class="n">sprite2</span><span class="p">,</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">test</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">try_collide</span><span class="p">(</span><span class="n">sprite2</span><span class="p">,</span> <span class="n">sprite1</span><span class="p">,</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">test</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># pick the best collision from the two</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">&lt;</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">magnitude</span> <span class="k">else</span> <span class="n">collision_objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">ret</span><span class="o">.</span><span class="n">is_collided</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="c1"># fill in some more values in the recycled Collision object before returning it</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">ret</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">normal_x</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">separate</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span> <span class="n">ret</span><span class="o">.</span><span class="n">distance</span> <span class="o">*</span> <span class="n">ret</span><span class="o">.</span><span class="n">normal_y</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">original_pos</span><span class="p">:</span>
            <span class="n">original_pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sprite1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>
        <span class="n">ret</span><span class="o">.</span><span class="n">original_pos</span> <span class="o">=</span> <span class="n">original_pos</span>

        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="SATCollision.calculate_normal"><a class="viewcode-back" href="../spygame_reference.html#spygame.SATCollision.calculate_normal">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">calculate_normal</span><span class="p">(</span><span class="n">points</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
        <span class="n">pt1</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">pt2</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">points</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">pt2</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">pt2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">pt1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">dist</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dist</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/=</span> <span class="n">dist</span>
            <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/=</span> <span class="n">dist</span></div>

<div class="viewcode-block" id="SATCollision.dot_product_against_normal"><a class="viewcode-back" href="../spygame_reference.html#spygame.SATCollision.dot_product_against_normal">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">dot_product_against_normal</span><span class="p">(</span><span class="n">point</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="p">(</span><span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">point</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="SATCollision.try_collide"><a class="viewcode-back" href="../spygame_reference.html#spygame.SATCollision.try_collide">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">try_collide</span><span class="p">(</span><span class="n">o1</span><span class="p">,</span> <span class="n">o2</span><span class="p">,</span> <span class="n">collision_obj</span><span class="p">,</span> <span class="n">flip</span><span class="p">):</span>
        <span class="n">shortest_dist</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># the following only works for AABBs, we will have to change that once objects start rotating or being non-rects</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="p">[[</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">],</span>
              <span class="p">[</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">],</span> <span class="p">[</span><span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o1</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">]]</span>

        <span class="n">p2</span> <span class="o">=</span> <span class="p">[[</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">],</span> <span class="p">[</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span><span class="p">],</span>
              <span class="p">[</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">width</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">],</span> <span class="p">[</span><span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">o2</span><span class="o">.</span><span class="n">rect</span><span class="o">.</span><span class="n">height</span><span class="p">]]</span>

        <span class="c1"># loop through all axes of sprite1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)):</span>
            <span class="n">SATCollision</span><span class="o">.</span><span class="n">calculate_normal</span><span class="p">(</span><span class="n">p1</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

            <span class="n">min1</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">dot_product_against_normal</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max1</span> <span class="o">=</span> <span class="n">min1</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p1</span><span class="p">)):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">dot_product_against_normal</span><span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">min1</span><span class="p">:</span>
                    <span class="n">min1</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">max1</span><span class="p">:</span>
                    <span class="n">max1</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="n">min2</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">dot_product_against_normal</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">max2</span> <span class="o">=</span> <span class="n">min2</span>

            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">p2</span><span class="p">)):</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">dot_product_against_normal</span><span class="p">(</span><span class="n">p2</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">min2</span><span class="p">:</span>
                    <span class="n">min2</span> <span class="o">=</span> <span class="n">tmp</span>
                <span class="k">if</span> <span class="n">tmp</span> <span class="o">&gt;</span> <span class="n">max2</span><span class="p">:</span>
                    <span class="n">max2</span> <span class="o">=</span> <span class="n">tmp</span>

            <span class="n">d1</span> <span class="o">=</span> <span class="n">min1</span> <span class="o">-</span> <span class="n">max2</span>
            <span class="n">d2</span> <span class="o">=</span> <span class="n">min2</span> <span class="o">-</span> <span class="n">max1</span>

            <span class="k">if</span> <span class="n">d1</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">d2</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span>

            <span class="n">min_dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">max2</span> <span class="o">-</span> <span class="n">min1</span><span class="p">)</span> <span class="o">*</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">flip</span><span class="p">:</span>
                <span class="n">min_dist</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">min_dist_abs</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">min_dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">min_dist_abs</span> <span class="o">&lt;</span> <span class="n">shortest_dist</span><span class="p">:</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">sprite1</span> <span class="o">=</span> <span class="n">o1</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">sprite2</span> <span class="o">=</span> <span class="n">o2</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">min_dist</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">magnitude</span> <span class="o">=</span> <span class="n">min_dist_abs</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">=</span> <span class="n">SATCollision</span><span class="o">.</span><span class="n">normal</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">distance</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_x</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">collision_obj</span><span class="o">.</span><span class="n">normal_y</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>

                <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">shortest_dist</span> <span class="o">=</span> <span class="n">min_dist_abs</span>

        <span class="c1"># return the actual collision</span>
        <span class="k">return</span> <span class="n">collision_obj</span> <span class="k">if</span> <span class="n">collision_obj</span><span class="o">.</span><span class="n">is_collided</span> <span class="k">else</span> <span class="kc">None</span></div></div>


<div class="viewcode-block" id="defaults"><a class="viewcode-back" href="../spygame_reference.html#spygame.defaults">[docs]</a><span class="k">def</span> <span class="nf">defaults</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">defaults_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Adds all key/value pairs from defaults_dict into dictionary, but only if dictionary doesn&#39;t have the key defined yet.</span>

<span class="sd">    :param dict dictionary: the target dictionary</span>
<span class="sd">    :param dict defaults_dict: the source (default) dictionary to take the keys from (only if they are not defined in dictionary</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">defaults_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dictionary</span><span class="p">:</span>  <span class="c1"># overwrite only if key is missing</span>
            <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<span class="c1"># OBSOLETE: use</span>
<div class="viewcode-block" id="extend"><a class="viewcode-back" href="../spygame_reference.html#spygame.extend">[docs]</a><span class="k">def</span> <span class="nf">extend</span><span class="p">(</span><span class="n">dictionary</span><span class="p">,</span> <span class="n">extend_dict</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extends the dictionary with extend_dict, thereby overwriting existing keys.</span>

<span class="sd">    :param dict dictionary: the target dictionary</span>
<span class="sd">    :param dict extend_dict: the source (extension) dictionary to take the keys from (even if they are not defined in dictionary)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">extend_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>  <span class="c1"># overwrite no matter what</span></div>


<div class="viewcode-block" id="convert_type"><a class="viewcode-back" href="../spygame_reference.html#spygame.convert_type">[docs]</a><span class="k">def</span> <span class="nf">convert_type</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">force_class</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts the given value from a string (or other) type into the most likely type.</span>
<span class="sd">    E.g.</span>
<span class="sd">    &#39;some text&#39; -&gt; &#39;some text&#39; (str)</span>
<span class="sd">    &#39;1&#39; -&gt; 1 (int)</span>
<span class="sd">    &#39;-51&#39; -&gt; -51 (int)</span>
<span class="sd">    &#39;0.1&#39; -&gt; 0.1 (float)</span>
<span class="sd">    &#39;true&#39; -&gt; True (bool)</span>
<span class="sd">    &#39;False&#39; -&gt; False (bool)</span>
<span class="sd">    [1, 2, 3] -&gt; [1, 2, 3] (list)</span>
<span class="sd">    spygame.Ladder -&gt; &lt;type spygame.Ladder&gt; (a python class object; can be used as a ctor to construct objects of that class)</span>

<span class="sd">    :param any value: the given value to be converted to the most-likely python type</span>
<span class="sd">    :param bool force_class: if True, we will interpret even simple strings (starting with upper case but without any dots) as class names (e.g. Ladder)</span>
<span class="sd">    :return: the converted value</span>
<span class="sd">    :rtype: any</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">as_str</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="c1"># int</span>
    <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;-?</span><span class="se">\\</span><span class="s1">d+&#39;</span><span class="p">,</span> <span class="n">as_str</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="c1"># float</span>
    <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;-?\d+\.\d+&#39;</span><span class="p">,</span> <span class="n">as_str</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="c1"># bool</span>
    <span class="k">elif</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;(true|false)&#39;</span><span class="p">,</span> <span class="n">as_str</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">I</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;True&quot;</span><span class="p">,</span> <span class="s2">&quot;true&quot;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">match_obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;^((.+)\.)?([A-Z][a-zA-Z0-9]+)$&#39;</span><span class="p">,</span> <span class="n">as_str</span><span class="p">)</span>
        <span class="c1"># a class with preceding modules (force_class does not have to be set to trigger this detection)</span>
        <span class="k">if</span> <span class="n">match_obj</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">module_</span><span class="p">,</span> <span class="n">class_</span> <span class="o">=</span> <span class="n">match_obj</span><span class="o">.</span><span class="n">groups</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="s2">&quot;__main__&quot;</span><span class="p">)</span>  <span class="c1"># if no module given, assume a class defined in __main__</span>
            <span class="n">ctor</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="n">module_</span><span class="p">],</span> <span class="n">class_</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctor</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="s2">&quot;ERROR: the string </span><span class="si">{}</span><span class="s2">.</span><span class="si">{}</span><span class="s2"> does not resolve into a defined class!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">module_</span><span class="p">,</span> <span class="n">class_</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ctor</span>
        <span class="c1"># a class (no modules, but force_class is set to True)</span>
        <span class="k">elif</span> <span class="n">force_class</span><span class="p">:</span>
            <span class="n">match_obj</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">fullmatch</span><span class="p">(</span><span class="s1">&#39;^([A-Z][a-zA-Z0-9]+)$&#39;</span><span class="p">,</span> <span class="n">as_str</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">match_obj</span><span class="p">:</span>
                <span class="p">(</span><span class="n">class_</span><span class="p">)</span> <span class="o">=</span> <span class="n">match_obj</span><span class="o">.</span><span class="n">groups</span><span class="p">()</span>
                <span class="n">ctor</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">modules</span><span class="p">[</span><span class="s2">&quot;__main__&quot;</span><span class="p">],</span> <span class="n">class_</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ctor</span><span class="p">,</span> <span class="nb">type</span><span class="p">),</span> <span class="s2">&quot;ERROR: the string </span><span class="si">{}</span><span class="s2"> does not resolve into a defined class!&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">class_</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">ctor</span>
        <span class="c1"># str (or list or others)</span>
        <span class="k">return</span> <span class="n">value</span></div>


<div class="viewcode-block" id="get_kwargs_from_obj_props"><a class="viewcode-back" href="../spygame_reference.html#spygame.get_kwargs_from_obj_props">[docs]</a><span class="k">def</span> <span class="nf">get_kwargs_from_obj_props</span><span class="p">(</span><span class="n">obj_props</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    returns a kwargs dict retrieved from a single object&#39;s properties in a level-tmx TiledObjectGroup</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">obj_props</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="c1"># special cases</span>
        <span class="c1"># a spritesheet (filename)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;tsx&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sprite_sheet&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">SpriteSheet</span><span class="p">(</span><span class="s2">&quot;data/&quot;</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="s2">&quot;.tsx&quot;</span><span class="p">)</span>
        <span class="c1"># an image_file</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;img&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;image_file&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;images/&quot;</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="s2">&quot;.png&quot;</span>
        <span class="c1"># a width/height information for the collision box</span>
        <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s2">&quot;width_height&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;width_height&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">convert_type</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)))</span>
        <span class="c1"># vanilla kwarg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">convert_type</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">kwargs</span></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../index.html">spygame 0.1a8 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="index.html" >Module code</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2017, ducandu GmbH.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.2.
    </div>
  </body>
</html>